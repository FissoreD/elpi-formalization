\usepackage[newfloat,outputdir=.aux]{minted}
\usepackage{bussproofs}
\usepackage{xspace}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{todonotes}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{mdframed}  % For creating a bordered box
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}

% \usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\newcommand{\subst}[1][]{\ensuremath{\sigma#1}\xspace}
\newcommand{\alt}[1][]{\ensuremath{\mathcal{A}#1}\xspace}
\newcommand{\g}[1][]{\ensuremath{\mathcal{G}#1}\xspace}
\newcommand{\clause}[1][]{\ensuremath{\mathcal{C}#1}\xspace}
\newcommand{\pred}[1][]{\texttt{p#1}\xspace}

\newenvironment{boxedproof}
{\begin{mdframed}\begin{proof}}
      {\end{proof}\end{mdframed}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Languages: start

\newcommand{\lang}[1]{\texttt{#1}\xspace}

\newcommand{\prolog}{\lang{prolog}}
\newcommand{\mixtus}{\lang{mixtus}}
\newcommand{\mercury}{\lang{mercury}}
\newcommand{\twelf}{\lang{twelf}}
\newcommand{\elpi}{\lang{elpi}}
\newcommand{\coq}{\lang{coq}}

\newcommand{\Mercury}{\lang{Mercury}}
\newcommand{\Elpi}{\lang{Elpi}}
\newcommand{\Coq}{\lang{Coq}}
\newcommand{\lamprolog}{\lang{$\lambda$prolog}}
\newcommand{\pf}{\ensuremath{L_\lambda}}

% Languages: end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{elpicode}{%
  \vspace{0.2em}%
  \VerbatimEnvironment
  \begin{minted}[fontsize=\small,autogobble,escapeinside=~~,mathescape=true,frame=leftline,framerule=0pt,framesep=1em]{'elpi.py:ElpiLexer -x'}%
}{%
  \end{minted}%
  \vspace{0.2em}%
}
\newcommand{\elpiIn}[1]{\mintinline[fontsize=\small,escapeinside=~~]{'elpi.py:ElpiLexer -x'}{#1}}
\newcommand{\modeAlone}[1]{\elpiIn{~\PYG{k+kMode}{#1:}~}}
\newcommand{\uvar}{\elpiIn{uvar}\xspace}

\newenvironment{coqcode}{%
  \vspace{0.2em}%
  \VerbatimEnvironment
  \begin{minted}[fontsize=\small,autogobble,escapeinside=~~,mathescape=true,frame=leftline,framerule=0pt,framesep=1em,texcomments]{coq}%
}{%
  \end{minted}%
  \vspace{0.2em}%
}
\newcommand{\coqIn}[1]{\mintinline[fontsize=\small,escapeinside=~~]{coq}{#1}}


% goal{program}{goal}{alternatives}
\newcommand{\run}{\texttt{run}}
\newcommand{\call}{\texttt{Call}}
\newcommand{\cut}{\texttt{Cut}}
\newcommand{\goal}{\texttt{Goal}}
\newcommand{\unify}{\texttt{unify}\xspace}
\newcommand{\match}{\texttt{match}\xspace}
\newcommand{\impl}{\texttt{=>}}
\renewcommand{\pi}{\texttt{pi}}
\newcommand{\cdash}{\texttt{:-}} % colon-dash
\newcommand{\tailcut}{\texttt{tail\_cut}\xspace}
\newcommand{\arr}{\rightsquigarrow}

% runCmd{goal[]}{alts[]}{subst}{alts_res}{subst_res}
\newcommand{\runCmd}[5]{\ensuremath{\run\ #1\ #2\ #3 \arr (#4, #5)}}
\newcommand{\callCmd}[3]{\ensuremath{(\call\ #1\ #2\ #3)}\xspace}
\newcommand{\goalCmd}[3]{\ensuremath{\goal\ #1\ #2\ #3}\xspace}
\newcommand{\clauseCmd}[3]{\ensuremath{#1\ #2\ \cdash\ #3}}
\newcommand{\implCmd}[2]{\ensuremath{#1\ \impl\ #2}}
\newcommand{\piCmd}[2]{\ensuremath{\pi\ #1\text{\textbackslash}\ #2}}

\newcommand{\unifyCmd}[4]{\ensuremath{\unify\ #1\ #2\ #3 \arr #4}}
\newcommand{\matchCmd}[4]{\ensuremath{\match\ #1\ #2\ #3 \arr #4}}

\newcommand{\tailcutCmd}[2]{\ensuremath{\tailcut\ #1\ #2}\xspace}

\newcommand{\Cons}[1]{\ensuremath{#1::}}
\newcommand{\ConsHd}[1]{\ensuremath{(#1::}\xspace}
\newcommand{\ConsTl}[1]{\ensuremath{#1)}\xspace}
\newcommand{\EmptyList}{\ensuremath{[\ ]}}

\newcommand{\EmptySubst}{\ensuremath{\varepsilon}}

\newcommand{\prog}[1][]{\ensuremath{\mathcal{P}#1}\xspace}
\newcommand{\evdash}{\ensuremath{\colondash}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Derivation system: start
\newenvironment{myRule}[1]{%
   \begin{minipage}{#1\textwidth}
   \centering
   \begin{prooftree}%
  } % Here will be put the body
  {
    \end{prooftree}
    \vspace{2pt}
    \end{minipage}
  }

\newcommand{\ruleName}[1]{\ensuremath{r_{#1}}\xspace}
\newcommand{\RightLabelM}[1]{\RightLabel{\scriptsize #1}}

\newcommand{\ruleFail}{\ruleName{\bot}}
\newcommand{\ruleCall}{\ruleName{c}}
\newcommand{\ruleBang}{\ruleName{!}}
\newcommand{\ruleStop}{\ruleName{\EmptyList}}
\newcommand{\ruleUnif}{\ruleName{=}}
\newcommand{\ruleImpl}{\ruleName{\Rightarrow}}
\newcommand{\rulePi}{\ruleName{\forall}}

\newcommand{\ruleStopM}[1]{
  \begin{myRule}{#1}
    % STOP
    \AxiomC{}
    \RightLabelM{\ruleStop}
    \UnaryInfC{\runCmd{\EmptyList}{\alt}{\subst}{\alt}{\subst}}
  \end{myRule}
}

\newcommand{\ruleUnifM}[1]{
  \begin{myRule}{#1}
    % UNIF
    \AxiomC{$\text{\unify}\ m\ x\ y\ \subst\ \subst[']$}
    \AxiomC{\runCmd{\g}{\alt}{\subst[']}{\alt[']}{\subst['']}}
    \RightLabelM{\ruleUnif}
    \BinaryInfC{\runCmd{\ConsHd{\goalCmd{\_}{(x =_m y)}{\_}}\ConsTl{\g}}{\alt}{\subst}{\alt[']}{\subst['']}}
  \end{myRule}
}

\newcommand{\ruleFailM}[1]{
  \begin{myRule}{#1}
    % FAIL
    \AxiomC{\texttt{fail} \subst g}
    \AxiomC{\runCmd{a}{\alt}{\subst[']}{\alt[']}{\subst['']}}
    \RightLabelM{\ruleFail}
    \BinaryInfC{\runCmd{\ConsHd{g}\ConsTl{\_}}{\ConsHd{\subst['],a}\ConsTl{\alt}}{\subst}{\alt[']}{\subst['']}}
  \end{myRule}%
}

\newcommand{\ruleBangM}[1]{
  \begin{myRule}{#1}
    % CUT
    \AxiomC{\runCmd{\g}{\alt}{\subst}{\alt[']}{\subst[']}}
    \RightLabelM{\ruleBang}
    \UnaryInfC{\runCmd{\ConsHd{\goalCmd{\_}{\cut}{\alt}}\ConsTl{\g}}{\_}{\subst}{\alt[']}{\subst[']}}
  \end{myRule}
}

\newcommand{\ruleCallM}[1]{
  \begin{myRule}{#1}
    % CALL
    % \AxiomC{\prog p = \ConsHd{(p\ i'\ o' \evdash b)}\ConsTl{bs}}
    % \AxiomC{$\mathcal{U} \gets {[i = i', o = o']}$}
    % \AxiomC{\runCmd{(({\mathcal{U}\ @\ b})_a\ @\ gl)}{(bs_a\ @\ a)}{s}{a'}{s'}}
    % \RightLabelM{\ruleCall}
    % \TrinaryInfC{\runCmd{\ConsHd{(\prog, \call{p}{i}{o}, \_)}\ConsTl{gl}}{a}{s}{a'}{s'}}
    % 
    \AxiomC{$\mathcal{F}(\prog, p, i, o, \subst, \alt) = \ConsHd{(\_,g)}\ConsTl{new\_alt}$}
    \AxiomC{\runCmd{(g\ @\ \g)}{(new\_alt\ @\ \alt)}{\subst}{\alt[']}{\subst[']}}
    \RightLabelM{\ruleCall}
    \BinaryInfC{\runCmd{\ConsHd{\goalCmd{\prog}{\callCmd{p}{i}{o}}{\_}}\ConsTl{\g}}{\alt}{\subst}{\alt[']}{\subst[']}}
  \end{myRule}
}

\newcommand{\ruleImplM}[1]{
  \begin{myRule}{#1}
    % IMPL
    \AxiomC{\runCmd{\ConsHd{(\goalCmd{(H + \prog)}{B}{\alt})}\ConsTl{\g}}{\alt[']}{\subst}{\alt['']}{\subst[']}}
    \RightLabelM{\ruleImpl}
    \UnaryInfC{\runCmd{\ConsHd{\goalCmd{\prog}{(\implCmd{H}{B})}{\alt}}\ConsTl{\g}}{\alt[']}{\subst}{\alt['']}{\subst[']}}
  \end{myRule}
}

\newcommand{\rulePiM}[1]{
  \begin{myRule}{#1}
    % PI
    \AxiomC{\runCmd{\ConsHd{\goalCmd{((\texttt{local }x) +\prog)}{B}{\alt}}\ConsTl{\g}}{\alt[']}{\subst}{\alt['']}{\subst[']}}
    \RightLabelM{\rulePi}
    \UnaryInfC{\runCmd{\ConsHd{\goalCmd{\prog}{(\piCmd{x}{B})}{\alt}}\ConsTl{\g}}{\alt[']}{\subst}{\alt['']}{\subst[']}}
  \end{myRule}
}

% Derivation system: end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\newcommand{\customlabel}[2]{%
  \protected@write \@auxout {}{\string \newlabel {#1}{{\ensuremath{#2}}{\thepage}{#2}{#1}{}} }%
  \hypertarget{#1}{\ensuremath{#2}}
}
\makeatother