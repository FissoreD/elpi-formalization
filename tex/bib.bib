@inproceedings{1990Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  editor    = {Rovan, Branislav},
  title     = {Retractions in comparing prolog semantics (extended abstract)},
  booktitle = {Mathematical Foundations of Computer Science 1990},
  year      = {1990},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {180--186},
  abstract  = {We present an operational model O and a continuation based denotational model D for a uniform variant of Prolog, including the cut operator. The two semantical definitions make use of higher order transformations $\Phi$ and $\Psi$, respectively. We prove O and D equivalent in a novel way by comparing yet another pair of higher order transformations $\Phi$ and $\Psi$, that yield $\Phi$ and $\Psi$, respectively, by application of a suitable abstraction operator.},
  isbn      = {978-3-540-47185-1}
}

@inproceedings{1989Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  editor    = {D{\'i}az, Josep
               and Orejas, Fernando},
  title     = {Continuation semantics for PROLOG with cut},
  booktitle = {TAPSOFT '89},
  year      = {1989},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {178--192},
  abstract  = {We present a denotational continuation semantics for PROLOG with cut. First a uniform language ℬ is studied, which captures the control flow aspects of PROLOG. The denotational semantics for ℬ is proven equivalent to a transition system based operational semantics. The congruence proof relies on the representation of the operational semantics as a chain of approximations and on a convenient induction principle. Finally, we interpret the abstract language ℬ such that we obtain equivalent denotational and operational models for PROLOG itself.},
  isbn      = {978-3-540-46116-6}
}


@article{2003Andrews,
  author     = {Andrews, James H.},
  title      = {The witness properties and the semantics of the Prolog cut},
  year       = {2003},
  issue_date = {January 2003},
  publisher  = {Cambridge University Press},
  address    = {USA},
  volume     = {3},
  number     = {1},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068402001540},
  doi        = {10.1017/S1471068402001540},
  abstract   = {The semantics of the Prolog ‘cut’ construct is explored in the context of some desirable properties of logic programming systems, referred to as the witness properties. The witness properties concern the operational consistency of responses to queries. A generalization of Prolog with negation as failure and cut is described, and shown not to have the witness properties. A restriction of the system is then described, which preserves the choice and first-solution behaviour of cut but allows the system to have the witness properties. The notion of cut in the restricted system is more restricted than the Prolog hard cut, but retains the useful first-solution behaviour of hard cut, not retained by other proposed cuts such as the ‘soft cut’. It is argued that the restricted system achieves a good compromise between the power and utility of the Prolog cut and the need for internal consistency in logic programming systems. The restricted system is given an abstract semantics, which depends on the witness properties; this semantics suggests that the restricted system has a deeper connection to logic than simply permitting some computations which are logical. Parts of this paper appeared previously in a different form in the Proceedings of the 1995 International Logic Programming Symposium (Andrews, 1995).},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {1–59},
  numpages   = {59},
  keywords   = {abstract semantics, cut, depth-first search, negation as failure, operational semantics}
}

@article{1996Somogy,
  title    = {The execution algorithm of mercury, an efficient purely declarative logic programming language},
  journal  = {The Journal of Logic Programming},
  volume   = {29},
  number   = {1},
  pages    = {17-64},
  year     = {1996},
  note     = {High-Performance Implementations of Logic Programming Systems},
  issn     = {0743-1066},
  doi      = {https://doi.org/10.1016/S0743-1066(96)00068-4},
  url      = {https://www.sciencedirect.com/science/article/pii/S0743106696000684},
  author   = {Zoltan Somogyi and Fergus Henderson and Thomas Conway},
  abstract = {We introduce Mercury, a new purely declarative logic programming language designed to provide the support that groups of application programmers need when building large programs. Mercury's strong type, mode, and determinism systems improve program reliability by catching many errors at compile time. We present a new and relatively simple execution model that takes advantage of the information these systems provide, yielding very efficient code. The Mercury compiler uses this execution model to generate portable C code. Our benchmarking shows that the code generated by our implementation is significantly faster than the code generated by mature optimizing implementations of other logic programming languages.}
}

@article{1989Warren,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jul,
  pages      = {451–481},
  numpages   = {31}
}

@article{1991Sahlin,
  author     = {Sahlin, Dan},
  title      = {Determinacy analysis for full Prolog},
  year       = {1991},
  issue_date = {Sept. 1991},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {26},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/115866.115869},
  doi        = {10.1145/115866.115869},
  journal    = {SIGPLAN Not.},
  month      = may,
  pages      = {23–30},
  numpages   = {8}
}

@inproceedings{1996mogensen,
  author    = {Mogensen, Torben \AE{}.},
  title     = {A Semantics-Based Determinacy Analysis for Prolog with Cut},
  year      = {1996},
  isbn      = {3540620648},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  booktitle = {Proceedings of the Second International Andrei Ershov Memorial Conference on Perspectives of System Informatics},
  pages     = {374–385},
  numpages  = {12}
}

@inproceedings{king2005,
  author  = {Lu, Lunjin and King, Andy},
  year    = {2005},
  month   = {04},
  pages   = {108-123},
  title   = {Determinacy Inference for Logic Programs},
  volume  = {3444},
  isbn    = {978-3-540-25435-5},
  journal = {Lecture Notes in Computer Science},
  doi     = {10.1007/978-3-540-31987-0_9}
}

@inproceedings{king2006,
  author    = {King, Andy
               and Lu, Lunjin
               and Genaim, Samir},
  editor    = {Etalle, Sandro
               and Truszczy{\'{n}}ski, Miros{\l}aw},
  title     = {Detecting Determinacy in Prolog Programs},
  booktitle = {Logic Programming},
  year      = {2006},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {132--147},
  abstract  = {In program development it is useful to know that a call to a Prolog program will not inadvertently leave a choice-point on the stack. Determinacy inference has been proposed for solving this problem yet the analysis was found to be wanting in that it could not infer determinacy conditions for programs that contained cuts or applied certain tests to select a clause. This paper shows how to remedy these serious deficiencies. It also addresses the problem of identifying those predicates which can be rewritten in a more deterministic fashion. To this end, a radically new form of determinacy inference is introduced, which is founded on ideas in ccp, that is capable of reasoning about the way bindings imposed by a rightmost goal can make a leftmost goal deterministic.},
  isbn      = {978-3-540-36636-2}
}


@article{2011king,
  title     = {RedAlert: Determinacy inference for Prolog},
  author    = {Kriener, Jael and King, Andy},
  journal   = {Theory and Practice of Logic Programming},
  volume    = {11},
  number    = {4-5},
  pages     = {537--553},
  year      = {2011},
  publisher = {Cambridge University Press}
}

@article{1996henderson,
  author = {Henderson, Fergus and Somogyi, Zoltan and Conway, Thomas},
  year   = {1996},
  month  = {08},
  pages  = {},
  title  = {Determinism analysis in the Mercury compiler}
}

@inproceedings{1987vanroy,
  title        = {Improving the execution speed of compiled Prolog with modes, clause selection, and determinism},
  author       = {Van Roy, Peter and Demoen, Bart and Willems, Yves D},
  booktitle    = {TAPSOFT'87: Proceedings of the International Joint Conference on Theory and Practice of Software Development Pisa, Italy, March 23--27, 1987 2},
  pages        = {111--125},
  year         = {1987},
  organization = {Springer}
}

@inproceedings{2002overton,
  author    = {Overton, David and Somogyi, Zoltan and Stuckey, Peter J.},
  title     = {Constraint-based mode analysis of mercury},
  year      = {2002},
  isbn      = {1581135289},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/571157.571169},
  doi       = {10.1145/571157.571169},
  abstract  = {Recent logic programming languages, such as Mercury and HAL, require type, mode and determinism declarations for predicates. This information allows the generation of efficient target code and the detection of many errors at compile-time. Unfortunately, mode checking in such languages is difficult. One of the main reasons is that, for each predicate mode declaration, the compiler is required to decide which parts of the procedure bind which variables, and how conjuncts in the predicate definition should be re-ordered to enforce this behaviour. Current mode checking systems limit the possible modes that may be used because they do not keep track of aliasing information, and have only a limited ability to infer modes, since inference does not perform reordering. In this paper we develop a mode inference system for Mercury based on mapping each predicate to a system of Boolean constraints that describe where its variables can be produced. This allows us handle programs that are not supported by the existing system.},
  booktitle = {Proceedings of the 4th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  pages     = {109–120},
  numpages  = {12},
  keywords  = {Boolean constraints, mode analysis, modes},
  location  = {Pittsburgh, PA, USA},
  series    = {PPDP '02}
}

% @article{1994apt,
%   title     = {Reasoning about Prolog programs: from modes through types to assertions},
%   author    = {Apt, Krzysztof R and Marchiori, Elena},
%   journal   = {Formal Aspects of Computing},
%   volume    = {6},
%   pages     = {743--765},
%   year      = {1994},
%   publisher = {Springer}
% }

@article{1994apt-oc,
  author     = {Apt, Krzysztof R. and Pellegrini, Alessandro},
  title      = {On the occur-check-free PROLOG programs},
  year       = {1994},
  issue_date = {May 1994},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {16},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/177492.177673},
  doi        = {10.1145/177492.177673},
  abstract   = {In most PROLOG implementations, for efficiency occur-check is omitted from the unification algorithm. This paper provides natural syntactic conditions that allow the occur-check to be safely omitted. The established results apply to most well-known PROLOG programs, including those that use difference lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs, we show their usefulness for proving absence of floundering. Finally, we propose a program transformation that transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = may,
  pages      = {687–726},
  numpages   = {40},
  keywords   = {PROLOG programs, moded programs, occur-check problem, unification algorithm}
}

@inproceedings{1996pfenning,
  author    = {Rohwedder, Ekkehard
               and Pfenning, Frank},
  editor    = {Nielson, Hanne Riis},
  title     = {Mode and termination checking for higher-order logic programs},
  booktitle = {Programming Languages and Systems --- ESOP '96},
  year      = {1996},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {296--310},
  abstract  = {We consider how mode (such as input and output) and termination properties of typed higher-order constraint logic programming languages may be declared and checked effectively. The systems that we present have been validated through an implementation and numerous case studies.},
  isbn      = {978-3-540-49942-8}
}
