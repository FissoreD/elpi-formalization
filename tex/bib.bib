@inproceedings{1990Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  xeditor    = {Rovan, Branislav},
  title     = {Retractions in comparing prolog semantics},
  booktitle = {Mathematical Foundations of Computer Science},
  year      = {1990},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {180--186},
  abstract  = {We present an operational model O and a continuation based denotational model D for a uniform variant of Prolog, including the cut operator. The two semantical definitions make use of higher order transformations $\Phi$ and $\Psi$, respectively. We prove O and D equivalent in a novel way by comparing yet another pair of higher order transformations $\Phi$ and $\Psi$, that yield $\Phi$ and $\Psi$, respectively, by application of a suitable abstraction operator.},
  isbn      = {978-3-540-47185-1}
}

@inproceedings{1989Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  editor    = {D{\'i}az, Josep
               and Orejas, Fernando},
  title     = {Continuation semantics for PROLOG with cut},
  booktitle = {TAPSOFT '89},
  year      = {1989},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {178--192},
  abstract  = {We present a denotational continuation semantics for PROLOG with cut. First a uniform language ℬ is studied, which captures the control flow aspects of PROLOG. The denotational semantics for ℬ is proven equivalent to a transition system based operational semantics. The congruence proof relies on the representation of the operational semantics as a chain of approximations and on a convenient induction principle. Finally, we interpret the abstract language ℬ such that we obtain equivalent denotational and operational models for PROLOG itself.},
  isbn      = {978-3-540-46116-6}
}

@misc{qi2009,
  title         = {An Implementation of the Language Lambda Prolog Organized around Higher-Order Pattern Unification},
  author        = {Xiaochu Qi},
  year          = {2009},
  eprint        = {0911.5203},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/0911.5203}
}

@inproceedings{2003Andrews,
  author     = {Andrews, James H.},
  title      = {The witness properties and the semantics of the Prolog cut},
  year       = {2003},
  issue_date = {January 2003},
  publisher  = {Cambridge University Press},
  xaddress    = {USA},
  volume     = {3},
  number     = {1},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068402001540},
  doi        = {10.1017/S1471068402001540},
  abstract   = {The semantics of the Prolog ‘cut’ construct is explored in the context of some desirable properties of logic programming systems, referred to as the witness properties. The witness properties concern the operational consistency of responses to queries. A generalization of Prolog with negation as failure and cut is described, and shown not to have the witness properties. A restriction of the system is then described, which preserves the choice and first-solution behaviour of cut but allows the system to have the witness properties. The notion of cut in the restricted system is more restricted than the Prolog hard cut, but retains the useful first-solution behaviour of hard cut, not retained by other proposed cuts such as the ‘soft cut’. It is argued that the restricted system achieves a good compromise between the power and utility of the Prolog cut and the need for internal consistency in logic programming systems. The restricted system is given an abstract semantics, which depends on the witness properties; this semantics suggests that the restricted system has a deeper connection to logic than simply permitting some computations which are logical. Parts of this paper appeared previously in a different form in the Proceedings of the 1995 International Logic Programming Symposium (Andrews, 1995).},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {1–59},
  numpages   = {59},
  keywords   = {abstract semantics, cut, depth-first search, negation as failure, operational semantics}
}

@inproceedings{1996Somogy,
  title    = {The execution algorithm of mercury, an efficient purely declarative logic programming language},
  journal  = {The Journal of Logic Programming},
  volume   = {29},
  number   = {1},
  pages    = {17-64},
  year     = {1996},
  note     = {High-Performance Implementations of Logic Programming Systems},
  issn     = {0743-1066},
  doi      = {https://doi.org/10.1016/S0743-1066(96)00068-4},
  url      = {https://www.sciencedirect.com/science/inproceedings/pii/S0743106696000684},
  author   = {Zoltan Somogyi and Fergus Henderson and Thomas Conway},
  abstract = {We introduce Mercury, a new purely declarative logic programming language designed to provide the support that groups of application programmers need when building large programs. Mercury's strong type, mode, and determinism systems improve program reliability by catching many errors at compile time. We present a new and relatively simple execution model that takes advantage of the information these systems provide, yielding very efficient code. The Mercury compiler uses this execution model to generate portable C code. Our benchmarking shows that the code generated by our implementation is significantly faster than the code generated by mature optimizing implementations of other logic programming languages.}
}

@inproceedings{1989Warren,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {ACM},
  xaddress    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jul,
  pages      = {451–481},
  numpages   = {31}
}

@inproceedings{1991Sahlin,
  author     = {Sahlin, Dan},
  title      = {Determinacy analysis for full Prolog},
  year       = {1991},
  issue_date = {Sept. 1991},
  publisher  = {ACM},
  xaddress    = {New York, NY, USA},
  volume     = {26},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/115866.115869},
  doi        = {10.1145/115866.115869},
  journal    = {SIGPLAN Not.},
  month      = may,
  pages      = {23–30},
  numpages   = {8}
}

@inproceedings{1996mogensen,
  author    = {Mogensen, Torben \AE{}.},
  title     = {A Semantics-Based Determinacy Analysis for Prolog with Cut},
  year      = {1996},
  isbn      = {3540620648},
  publisher = {Springer-Verlag},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of the Second International Andrei Ershov Memorial Conference on Perspectives of System Informatics},
  pages     = {374–385},
  numpages  = {12}
}

@inproceedings{king2005,
  author  = {Lu, Lunjin and King, Andy},
  year    = {2005},
  month   = {04},
  pages   = {108-123},
  title   = {Determinacy Inference for Logic Programs},
  volume  = {3444},
  isbn    = {978-3-540-25435-5},
  journal = {Lecture Notes in Computer Science},
  doi     = {10.1007/978-3-540-31987-0_9}
}

@inproceedings{king2006,
  author    = {King, Andy
               and Lu, Lunjin
               and Genaim, Samir},
  editor    = {Etalle, Sandro
               and Truszczy{\'{n}}ski, Miros{\l}aw},
  title     = {Detecting Determinacy in Prolog Programs},
  booktitle = {Logic Programming},
  year      = {2006},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {132--147},
  abstract  = {In program development it is useful to know that a call to a Prolog program will not inadvertently leave a choice-point on the stack. Determinacy inference has been proposed for solving this problem yet the analysis was found to be wanting in that it could not infer determinacy conditions for programs that contained cuts or applied certain tests to select a clause. This paper shows how to remedy these serious deficiencies. It also addresses the problem of identifying those predicates which can be rewritten in a more deterministic fashion. To this end, a radically new form of determinacy inference is introduced, which is founded on ideas in ccp, that is capable of reasoning about the way bindings imposed by a rightmost goal can make a leftmost goal deterministic.},
  isbn      = {978-3-540-36636-2}
}


@inproceedings{2011king,
  title     = {RedAlert: Determinacy inference for Prolog},
  author    = {Kriener, Jael and King, Andy},
  journal   = {Theory and Practice of Logic Programming},
  volume    = {11},
  number    = {4-5},
  pages     = {537--553},
  year      = {2011},
  publisher = {Cambridge University Press}
}

@inproceedings{1996henderson,
  author = {Henderson, Fergus and Somogyi, Zoltan and Conway, Thomas},
  year   = {1996},
  month  = {08},
  booktitle = {Proceedings of Australian Computer Science Conference},
  pages  = {337-346},
  title  = {Determinism analysis in the Mercury compiler}
}

@inproceedings{1987vanroy,
  title        = {Improving the execution speed of compiled Prolog with modes, clause selection, and determinism},
  author       = {Van Roy, Peter and Demoen, Bart and Willems, Yves D},
  booktitle    = {TAPSOFT'87: Proceedings of the International Joint Conference on Theory and Practice of Software Development Pisa, Italy, March 23--27, 1987 2},
  pages        = {111--125},
  year         = {1987},
  organization = {Springer}
}

@inproceedings{2002overton,
  author    = {Overton, David and Somogyi, Zoltan and Stuckey, Peter J.},
  title     = {Constraint-based mode analysis of mercury},
  year      = {2002},
  isbn      = {1581135289},
  publisher = {ACM},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/571157.571169},
  doi       = {10.1145/571157.571169},
  abstract  = {Recent logic programming languages, such as Mercury and HAL, require type, mode and determinism declarations for predicates. This information allows the generation of efficient target code and the detection of many errors at compile-time. Unfortunately, mode checking in such languages is difficult. One of the main reasons is that, for each predicate mode declaration, the compiler is required to decide which parts of the procedure bind which variables, and how conjuncts in the predicate definition should be re-ordered to enforce this behaviour. Current mode checking systems limit the possible modes that may be used because they do not keep track of aliasing information, and have only a limited ability to infer modes, since inference does not perform reordering. In this paper we develop a mode inference system for Mercury based on mapping each predicate to a system of Boolean constraints that describe where its variables can be produced. This allows us handle programs that are not supported by the existing system.},
  booktitle = {Proceedings of the 4th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  pages     = {109–120},
  numpages  = {12},
  keywords  = {Boolean constraints, mode analysis, modes},
  location  = {Pittsburgh, PA, USA},
  series    = {PPDP '02}
}

@inproceedings{1994apt-oc,
  author     = {Apt, Krzysztof R. and Pellegrini, Alessandro},
  title      = {On the occur-check-free PROLOG programs},
  year       = {1994},
  issue_date = {May 1994},
  publisher  = {ACM},
  xaddress    = {New York, NY, USA},
  volume     = {16},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/177492.177673},
  doi        = {10.1145/177492.177673},
  abstract   = {In most PROLOG implementations, for efficiency occur-check is omitted from the unification algorithm. This paper provides natural syntactic conditions that allow the occur-check to be safely omitted. The established results apply to most well-known PROLOG programs, including those that use difference lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs, we show their usefulness for proving absence of floundering. Finally, we propose a program transformation that transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = may,
  pages      = {687–726},
  numpages   = {40},
  keywords   = {PROLOG programs, moded programs, occur-check problem, unification algorithm}
}

@inproceedings{1996pfenning,
  author    = {Rohwedder, Ekkehard
               and Pfenning, Frank},
  editor    = {Nielson, Hanne Riis},
  title     = {Mode and termination checking for higher-order logic programs},
  booktitle = {Programming Languages and Systems --- ESOP '96},
  year      = {1996},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {296--310},
  abstract  = {We consider how mode (such as input and output) and termination properties of typed higher-order constraint logic programming languages may be declared and checked effectively. The systems that we present have been validated through an implementation and numerous case studies.},
  isbn      = {978-3-540-49942-8}
}

@inproceedings{tassi2018,
  title       = {{Elpi: an extension language for Coq (Metaprogramming Coq in the Elpi $\lambda$Prolog dialect)}},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01637063},
  booktitle   = {{The Fourth International Workshop on Coq for Programming Languages}},
  xaddress     = {Los Angeles (CA), United States},
  year        = {2018},
  month       = Jan,
  keywords    = {Coq ; $\lambda$Prolog ; metaprogramming ; extension language},
  pdf         = {https://inria.hal.science/hal-01637063v1/file/coqpl2018.pdf},
  hal_id      = {hal-01637063},
  hal_version = {v1}
}

@inproceedings{tassi2019,
  title       = {Deriving proved equality tests in {C}oq-{E}lpi},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01897468},
  booktitle   = {Proceedings of ITP},
  xaddress     = {Portland, United States},
  year        = {2019},
  month       = Sep,
  series =      {LIPIcs},
  doi         = {10.4230/LIPIcs.CVIT.2016.23},
  keywords    = {Induction ; Coq ; Equality test ; Parametricity translation ; Containers},
  pdf         = {https://inria.hal.science/hal-01897468v2/file/induction.pdf},
  hal_id      = {hal-01897468},
  hal_version = {v2}
}

@inproceedings{tassi2023,
  author    = {Gr\'{e}goire, Benjamin and L\'{e}chenet, Jean-Christophe and Tassi, Enrico},
  title     = {Practical and Sound Equality Tests, Automatically},
  year      = {2023},
  isbn      = {9798400700262},
  publisher = {ACM},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3573105.3575683},
  doi       = {10.1145/3573105.3575683},
  abstract  = {In this paper we describe the design and implementation of feqb, a tool that synthesizes sound equality tests for inductive data types in the dependent type theory of the Coq system. Our procedure scales to large inductive data types, as in hundreds of constructors, since the terms and proofs it synthesizes are linear in the size of the inductive type. Moreover it supports some forms of dependently typed arguments and sigma types pairing data with proofs of decidable properties. Finally feqb handles deeply nested containers without requiring any human intervention.},
  booktitle = {Proceedings of CPP},
  xbooktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages     = {167–181},
  numpages  = {15},
  keywords  = {program synthesis, decision procedure, computational complexity, Elpi, Coq},
  xlocation  = {Boston, MA, USA},
  xseries    = {CPP 2023}
}

@inproceedings{fissore2023,
  title       = {{A new Type-Class solver for Coq in Elpi}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-04467855},
  booktitle   = {{The Coq Workshop}},
  xaddress     = {Bialystok, Poland},
  year        = {2023},
  month       = Jul,
  keywords    = {type classes ; coq ; lambda-prolog},
  pdf         = {https://inria.hal.science/hal-04467855v1/file/coq2023_TC-elpi.pdf},
  hal_id      = {hal-04467855},
  hal_version = {v1}
}

@inproceedings{Fissore2024,
author = {Fissore, Davide and Tassi, Enrico},
title = {Higher-Order unification for free!: Reusing the meta-language unification for the object language},
year = {2024},
isbn = {9798400709692},
publisher = {ACM},
xaddress = {New York, NY, USA},
url = {https://doi.org/10.1145/3678232.3678233},
doi = {10.1145/3678232.3678233},
abstract = {Specifying and implementing a proof system from scratch requires significant effort. Logical Frameworks and Higher Order Logic Programming Languages provide dedicated, high-level meta languages to facilitate this task in two ways: 1) variable binding and substitution are for free when meta language binders represent object logic ones; 2) proof construction, and proof search, are greatly simplified by leveraging the unification procedure provided by the meta language. Notable examples of meta languages are Elf [21], Twelf [23], λ Prolog [16], Beluga [24], Abella [8] and Isabelle [31] which have been used to implement or specify many formal systems such as First Order Logic [5], Set Theory [20], Higher Order Logic [19], and the Calculus of Constructions [4]. The object logic we are interested in is Coq’s type theory [28]. We aim to develop a higher-order unification-based proof search procedure using the meta language Elpi [3], a dialect of λ Prolog. Elpi’s equational theory includes βη -equivalence and features a higher-order unification procedure ≃ m for the pattern fragment [15]. Elpi offers an encoding of Coq terms that is suitable for meta programming [6, 9, 26, 27] but that restricts ≃ m to first-order unification problems only. We refer to this basic encoding as <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 1</AltText><File name="ppdp2024-1-inline1" type="svg"/></Formula>. In this paper we translate unification problems in <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 2</AltText><File name="ppdp2024-1-inline2" type="svg"/></Formula> to an alternative encoding called <Formula format="inline"><TexMath><?TeX $mathcal {M}$?></TexMath><AltText>Math 3</AltText><File name="ppdp2024-1-inline3" type="svg"/></Formula>, from which we derive ≃ o, the higher-order unification procedure of <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 4</AltText><File name="ppdp2024-1-inline4" type="svg"/></Formula>. ≃ o honours βη -equivalence for terms within the pattern fragment, and allows for the use of heuristics when the terms fall outside the pattern fragment. Moreover, as ≃ o delegates most of the work to ≃ m, it can be used to efficiently simulate a logic program in <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 5</AltText><File name="ppdp2024-1-inline5" type="svg"/></Formula> by taking advantage of unification-related optimizations of the meta language, such as clause indexing.},
booktitle = {Proceedings of PPDP},
articleno = {3},
pages = {1-13},
keywords = {Higher-Order Unification, Logic Programming, Meta-Programming},
xlocation = {Milano, Italy},
xseries = {PPDP '24}
}
@book{1991ait-wam,
  author    = {Aït-Kaci, Hassan},
  title     = {Warren's Abstract Machine: A Tutorial Reconstruction},
  publisher = {The MIT Press},
  year      = {1991},
  month     = {08},
  abstract  = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.Contents Introduction • Unification—Pure and Simple • Flat Resolution • Prolog • Optimizing the Design • Conclusion • Appendixes},
  isbn      = {9780262255585},
  doi       = {10.7551/mitpress/7160.001.0001},
  url       = {https://doi.org/10.7551/mitpress/7160.001.0001}
}


@inproceedings{1991miller-pf,
  author    = {Miller, Dale},
  xeditor    = {Schroeder-Heister, Peter},
  title     = {A logic programming language with lambda-abstraction, function variables, and simple unification},
  booktitle = {Extensions of Logic Programming},
  year      = {1991},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {253--281},
  abstract  = {It has been argued elsewhere that a logic programming language with function variables and $\lambda$-abstractions within terms makes a very good meta-programming language, especially when an object language contains notions of bound variables and scope. The $\lambda$Prolog logic programming language and the closely related Elf and Isabelle systems provide meta-programs with both function variables and $\lambda$-abstractions by containing implementations of higher-order unification. In this paper, we present a logic programming language, called L$\lambda$, that also contains both function variables and $\lambda$-abstractions, but certain restriction are placed on occurrences of function variables. As a result, an implementation of L$\lambda$ does not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using L$\lambda$ as a meta-programming language are presented.},
  isbn      = {978-3-540-46879-0}
}

@inproceedings{1992nadathur,
  author    = {Nadathur, Gopalan and Pfenning, Frank},
  title     = {The Type System of a Higher-Order Logic Programming Language},
  year      = {1992},
  publisher = {Duke University},
  xaddress   = {USA},
  abstract  = {The type system of the logic programming language $lambda$Prolog is discussed. The incorporation of higher-order notions within this language requires the use of a typing scheme to distinguish between expressions of different function types. Thus $lambda$Prolog is a (strongly) typed language, in contrast to the typeless language that underlies the idea of descriptive types in logic programming. The typing discipline that is employed in the language is based on the notion of simple types in the $lambda$-calculus. This form of typing enforces arity restrictions on functions and predicates and provides a builtin functional hierarchy over terms. The language contains a facility for defining new primitive types and thus permits finer grained distinctions to be introduced by the user. Further, the use of type variables and type constructors provides a form of polymorphism that is similar in certain respects to that present in the language ML. The notion of type checking in $lambda$Prolog is discussed and shown to be an operation that can be performed at the time of compilation. The value of typing distinctions in determining the clarity of programs and their usefulness in conjunction with type checking in preventing run-time errors due to type violations is also discussed. In addition to their function in type checking, types also have a major role in determining computations in the logic programming context. We discuss this aspect of types that is in contrast to their behavior in other programming paradigms and we show how this leads to a presence of types in the runtime environment. While typing has several advantages, it is sometimes to the programmer''s advantage to be able to omit their mention. Type reconstruction provides a means for filling missing type information in and we discuss issues pertinent to this process in the context of $lambda$Prolog.}
}

@inproceedings{1988pfenning,
  author    = {Pfenning, F. and Elliott, C.},
  title     = {Higher-order abstract syntax},
  year      = {1988},
  isbn      = {0897912691},
  publisher = {ACM},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/53990.54010},
  doi       = {10.1145/53990.54010},
  abstract  = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
  booktitle = {Proceedings of PLDI},
  pages     = {199–208},
  numpages  = {10},
  location  = {Atlanta, Georgia, USA},
  xseries    = {PLDI '88}
}

@InProceedings{cohen_et_al:LIPIcs.FSCD.2020.34,
  author =      {Cohen, Cyril and Sakaguchi, Kazuhiko and Tassi, Enrico},
  title =       {{Hierarchy Builder: Algebraic hierarchies Made Easy in Coq with Elpi}},
  booktitle =   {Proceedings of FSCD},
  pages =       {34:1--34:21},
  series =      {LIPIcs},
  ISBN =        {978-3-95977-155-9},
  ISSN =        {1868-8969},
  year =        {2020},
  volume =      {167},
  xeditor =      {Ariola, Zena M.},
  xpublisher =   {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  xaddress =     {Dagstuhl, Germany},
  URL =         {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2020.34},
  URN =         {urn:nbn:de:0030-drops-123562},
  doi =         {10.4230/LIPIcs.FSCD.2020.34},
  annote =      {Keywords: Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, \lambdaProlog},
}

@book{Miller_Nadathur_2012,
  place={Cambridge},
  title={Programming with Higher-Order Logic},
  publisher={Cambridge University Press},
  author={Miller, Dale and Nadathur, Gopalan},
  year={2012}
}


@InProceedings{dunchev15lpar,
  author =       "Cvetan Dunchev and Ferruccio Guidi and Claudio Sacerdoti Coen and Enrico Tassi",
  title =        "{ELPI:} Fast, Embeddable, $\lambda${Prolog} Interpreter",
  booktitle =    "Proceedings of LPAR",
  xeditor =       "Martin Davis and Ansgar Fehnker and Annabelle McIver and Andrei Voronkov",
  series =       "LNCS",
  publisher="Springer",
  volume =       "9450",
  pages =        "460--468",
  year =         "2015",
  URL =          "https://inria.hal.science/hal-01176856v1",
  doi =          "10.1007/978-3-662-48899-7\_32",
}


@inproceedings{TASSI_2019,
  title     = {Implementing type theory in higher order constraint logic programming},
  author    = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  journal   = {Mathematical Structures in Computer Science},
  booktitle   = {Mathematical Structures in Computer Science},
  volume    = {29},
  number    = {8},
  pages     = {1125--1150},
  year      = {2019},
  publisher = {Cambridge University Press},
  DOI={10.1017/S0960129518000427},
}

@inproceedings{Miller2018MechanizedMR,
  title={Mechanized Metatheory Revisited},
  author={Dale A. Miller},
  journal={Journal of Automated Reasoning},
  booktitle={Journal of Automated Reasoning},
  year={2018},
  volume={63},
  pages={625-665},
}

@inproceedings{wadler1996-hs,
  author     = {Hall, Cordelia V. and Hammond, Kevin and Peyton Jones, Simon L. and Wadler, Philip L.},
  title      = {Type classes in Haskell},
  year       = {1996},
  issue_date = {March 1996},
  publisher  = {ACM},
  xaddress    = {New York, NY, USA},
  volume     = {18},
  number     = {2},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/227699.227700},
  doi        = {10.1145/227699.227700},
  abstract   = {This article defines a set of type inference rules for resolving overloading introduced by type classes, as used in the functional programming language Haskell. Programs including type classes are transformed into ones which may be typed by standard Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to Haskell programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the transformed program.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = mar,
  pages      = {109–138},
  numpages   = {30},
  keywords   = {Haskell, functional programming, type classes, types}
}


@InProceedings{sozeau2008-tc,
author="Sozeau, Matthieu and Oury, Nicolas",
title="First-Class Type Classes",
booktitle="Proceedings of TPHOLs",
year="2008",
publisher="Springer",
xaddress="Berlin, Heidelberg",
pages="278--293",
abstract="Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.",
isbn="978-3-540-71067-7"
}


@inproceedings{nakamura1986,
  author    = {Nakamura, Katsuhiko},
  title     = {Control of Logic Program Execution Based on the Functional Relations},
  year      = {1986},
  isbn      = {3540164928},
  publisher = {Springer-Verlag},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of ICLP},
  pages     = {505–512},
  numpages  = {8}
}