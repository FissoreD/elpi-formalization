
% [checkCmd ctx1 func1 tm ctx2 func2]
\newcommand{\checkL}{\texttt{check}\ensuremath{_L}}
\newcommand{\checkCmd}[6][\prog]{\ensuremath{\checkk\ #1\ #4\ (#2,\ #3)\ \!= (#5, #6)}}
% \newcommand{\checkCmd}[6][\prog]{\ensuremath{\checkk\ #1\ #4\ (#2,\ #3)\ \!\arr (#5, #6)}}
\newcommand{\checkLCmd}[5]{\ensuremath{\checkL\ #3\ #1\ #2\ = (#4, #5)}}
% \newcommand{\checkLCmd}[5]{\ensuremath{\checkL\ #3\ #1\ #2\ \arr (#4, #5)}}
\newcommand{\checkClause}[3][\prog]{\ensuremath{\checkc\ #1\ #2\ #3}}

% \newcommand{\ruleCheckName}[1]{\ensuremath{C_{#1}}\xspace}
\newcommand{\ruleCheckName}[2]{\customlabel{#1}{\ensuremath{C_{#2}}}}

\newcommand{\ruleCheckClause}{\ruleCheckName{rule:check-clause}{\cdash}}
\newcommand{\ruleCheckClauseM}[1]{
  \begin{myRule}{#1}
    % Clause
    \AxiomC{
      \Shortstack{
      { \ensuremath{\mutExclAll\ \prog\ (\clauseCmd{p}{\vecL{t}}{\vecL{bs}})} }
      {
        \ensuremath{
          \ctx\ p = \dtype{\func}{\func[_i]}{\func[_o]} 
           \ \ \;\quad\quad\qquad \fold\ \checkCmd{\ctx[']}{\detI}{\vecL{bs}}{\ctx['']}{\func[']}
          \quad\ \subCmd{\func'}{\func}
        }
      }
      {
        \ensuremath{
          \fold\ \assumeCmd{\ctx}{\vecL{(\func[_i],t_i)}}{\!\!}{\ctx[']}
          \quad \map\ \inferCmdArr[1]{\ctx['']}{\vecL{t_o}}{\vecL{(\func[_o'],\top)}}
          \qquad\qquad\quad\ \vecL{\func[_o'] \mySub \func[_o]}}
        }
      }
    }
    \RightLabelM{\ruleCheckClause}
    \UnaryInfC{\checkClause{\ctx}{(\clauseCmd{p}{\vecL{t}}{\vecL{bs}})}}
  \end{myRule}
}

\newcommand{\ruleCheckCut}{\ruleCheckName{rule:check-cut}{!}}
\newcommand{\ruleCheckCutM}[1]{
  \begin{myRule}{#1}
    % CUT
    \AxiomC{}
    \RightLabelM{\ruleCheckCut}
    \UnaryInfC{\checkCmd{\ctx}{\_}{\cut}{\ctx}{\detI}}
  \end{myRule}
}

\newcommand{\ruleCheckUnif}{\ruleCheckName{rule:check-unif}{=}}
\newcommand{\ruleCheckUnifM}[1]{
  \begin{myRule}{#1}
    % UNIF
    \AxiomC{
      \stackanchor
      {\ensuremath{\inferCmdArr{\ctx}{A}{(\func[_A],\top)}}}
      {\ensuremath{\inferCmdArr{\ctx}{B}{(\func[_B],\top)}}}}
    \AxiomC{\ensuremath{\func{_{AB}} = \minT\ \func{_A}\ \func{_B}}}
    % \AxiomC{\ensuremath{\func{_{AB}} = \minT\ \func{_A}\ \func{_B}}}
    \AxiomC{
      \stackanchor
      {\ensuremath{\assumeCmd{\ctx}{\func{_{AB}}}{A}{\ctx[']}}}
      {\ensuremath{\assumeCmd{\ctx[']}{\func{_{AB}}}{B}{\ctx['']}}}}
    \RightLabelM{\ruleCheckUnif}
    \TrinaryInfC{\checkCmd{\ctx}{\func}{(A = B)}{\ctx['']}{\func}}
  \end{myRule}
}

\newcommand{\ruleCheckUnifFail}{\ruleCheckName{rule:check-unifFail}{{\neq}}}
\newcommand{\ruleCheckUnifFailM}[1]{
  \begin{myRule}{#1}
    % UNIF FAIL
    \AxiomC{\ensuremath{\inferCmdArr{\ctx}{A}{(\_,\bot)} \lor \inferCmdArr{\ctx}{B}{(\_,\bot)}}}
    \RightLabelM{\ruleCheckUnifFail}
    \UnaryInfC{\checkCmd{\ctx}{\func}{(A = B)}{\ctx}{\func}}
  \end{myRule}
}

\newcommand{\ruleCheckPiImpl}{\ruleCheckName{rule:check-piimpl}{\piimpl}}
\newcommand{\ruleCheckPiImplM}[1]{
  \begin{myRule}{#1}
    % PiImpl
    \AxiomC{ $\checkClause{(\ctx + \{x \mapsto \expI\})}{h}$ }
    \AxiomC{ \!\!\!\checkCmd[(\prog + h)]{\ctx + \{x \mapsto \expI\}}{\func}{t}{\ctx[']}{\func[']} } 
    \RightLabelM{\ruleCheckPiImpl}
    \BinaryInfC{\checkCmd{\ctx}{\func}{(\piImplCmd[\expI]{x}{h}{t})}{\ctx[']\bs \{x\}}{\func[']}}
  \end{myRule}
}

\newcommand{\predVar}{\texttt{v}}

% \newcommand{\ruleCheckCall}{\ruleCheckName{rule:check-callOK}{@}}
% \newcommand{\ruleCheckCallM}[1]{
%   \begin{myRule}{#1}
%     % CALL SUCC
%     \AxiomC{\ensuremath{\ctx\ \predVar = \dtype{\func[']}{[\func[_i]]}{[\func[_o]]}}}
%     \AxiomC{\inferCmdArr{\ctx}{i}{\func[_i']}{\top}}
%     \AxiomC{\ensuremath{\func[_i'] \mySub \func[_i]}}
%     \AxiomC{\assumeCmd{\ctx}{\func[_o]}{o}{\ctx[']}}
%     \RightLabelM{\ruleCheckCall}
%     \QuaternaryInfC{\checkCmd{\ctx}{\func}{(\predVar\ i\ o)}{\ctx[']}{\maxT\ \func\ \func[']}}
%   \end{myRule}
% }
\def\stackalignment{l}
\newcommand{\ruleCheckCall}{\ruleCheckName{rule:check-callOK}{@_\top}}
\newcommand{\ruleCheckCallM}[1]{
  \begin{myRule}{#1}
    % CALL SUCC
    % \AxiomC{
    %   \stackanchor{\ensuremath{\ctx\ \predVar = \dtype{\func[']}{[\func[_i]]}{[\func[_o]]}}}
    %   {\inferCmdArr{\ctx}{i}{\func[_i']}{\mathcal{R}}}}
    \AxiomC{
      \stackanchor{\ensuremath{%
          \ctx\ c = \dtype{\func[']}{\func[_i]}{\func[_o]} \qquad
          \map\ \inferCmdArr[1]{\ctx}{\vecL{t_i}}{\vecL{(\func[_i'],\top)}}}
      }{\ensuremath{%
          \vecL{\func[_i'] \mySub \func[_i]} \qquad\qquad\qquad\ \!
          \fold\ \assumeCmd{\ctx}{\vecL{(\func[_o],t_o)}}{\!\!\!}{\ctx[']}}}}

    % \AxiomC{
    %   \stackanchor
    %   {\ensuremath{\text{if } \mathcal{R}}}
    %   {\stackanchor
    %     {then $\func[''] = \maxT\ \func\ \func[']$}
    %     {else $\func[''] = \relI$}}}
    \RightLabelM{\ruleCheckCall}
    \UnaryInfC{\checkCmd{\ctx}{\func}{(c\ \vecL{t})}{\ctx[']}{\maxT\ \func\ \func[']}}
  \end{myRule}
}

\newcommand{\ruleCheckCallFail}{\ruleCheckName{rule:check-callKO}{@_\bot}}
\newcommand{\ruleCheckCallFailM}[1]{
  \begin{myRule}{#1}
    % CALL FAIL
    \AxiomC{\ensuremath{ \ctx\ c = \dtype{\_}{\func}{\_} }}
    \AxiomC{ \map\ \inferCmdArr[1]{\ctx}{\vecL{t_i}}{\vecL{(\func['],\bool)}}}
    \AxiomC{$ \exists i, \func[_i'] \not\mySub \func[_i]\ \lor\ \bool_i = \bot$}
    \RightLabelM{\ruleCheckCallFail}
    \TrinaryInfC{\checkCmd{\ctx}{\_}{(c\ \vecL{t})}{\ctx}{\relI}}
  \end{myRule}
}


% \newcommand{\ruleCheckEmptyM}[1]{
%   \begin{myRule}{#1}
%     % EMPTY
%     \AxiomC{}
%     \RightLabelM{\ruleCheckEmpty}
%     \UnaryInfC{\checkCmd{\ctx}{\func}{\EmptyList}{\ctx}{\func}}
%   \end{myRule}
% }

\newcommand{\ruleCheckEmpty}{\ruleCheckName{rule:check-stop}{\EmptyList}}
\newcommand{\ruleCheckListEmpty}[1]{
  % EMPTY
  \begin{myRule}{#1}
    \AxiomC{}
    \RightLabelM{\ruleCheckEmpty}
    \UnaryInfC{\checkLCmd{\ctx}{\func}{\EmptyList}{\ctx}{\func}}
  \end{myRule}
}

\newcommand{\ruleCheckCons}{\ruleCheckName{rule:check-cons}{::}}
\newcommand{\ruleCheckListCons}[1]{
  % CONS
  \begin{myRule}{#1}
    \AxiomC{\checkCmd{\ctx}{\func}{\EmptyList}{\ctx[']}{\func[']}}
    \AxiomC{\checkLCmd{\ctx[']}{\func[']}{\EmptyList}{\ctx['']}{\func['']}}
    \RightLabelM{\ruleCheckCons}
    \BinaryInfC{\checkLCmd{\ctx}{\func}{\ConsHd{h}\ConsTl{t}}{\ctx['']}{\func['']}}
  \end{myRule}
}

\newcommand{\checkTermFig}{
  \begin{figure}[b]
    \begin{framed}
      \centering

      \ruleCheckCutM{.45}

      % \ruleCheckPiM{.5}
      
      % \ruleCheckUnifM{1}
      % \ruleCheckUnifFailM{0.52}
      
      % \ruleCheckMatchM{.7}
      \ruleCheckCallM{1}
      \ruleCheckCallFailM{1}
      \ruleCheckPiImplM{1}

      %     \caption{\checkk\ relation}
      %     \label{fig:static-check-term}
      %   \end{subfigure}
      % }

      % \newcommand{\staticCheckFig}{
      %   \begin{subfigure}[b]{1\textwidth}
      %     \centering
      \ruleCheckClauseM{1}

      % \ruleCheckListEmpty{.38}
      % \ruleCheckListCons{1}

      \vspace{-1em}
      \caption{$\checkk : \prog \to \A \to (\ctx \times \F) \to (\ctx \times \F)$}
      \label{fig:static-check}
    \end{framed}
  \end{figure}
}