
%              inp           inp  out   out
% \inferCmdArr{optional-vecL}{trm}{det}{good-call}
\newcommand{\inferCmdArr}[4][]{\ensuremath{
    \ifstrequal{#1}{1}
    {(\infer\ #2)\ #3}
    {\infer\ #2\ #3} = #4
    % {\infer\ #2\ #3} \arr #4
  }}
\newcommand{\dapp}{\ensuremath{\texttt{\infer}_@}\xspace}

\newcommand{\ruleInfer}[2]{\customlabel{#1}{\ensuremath{I_{#2}}}}

\newcommand{\ruleInferCut}{\ruleInfer{rule:infer-cut}{!}}
\newcommand{\inferCut}[1]{
  \begin{myRule}{#1}
    \AxiomC{}
    \RightLabelM{\ruleInferCut}
    \UnaryInfC{\inferCmdArr{\ctx}{\cut}{(\detI, \top)}}
  \end{myRule}
}

\newcommand{\ruleInferPiImpl}{\ruleInfer{rule:infer-piimpl}{\piimpl}}
\newcommand{\inferPiImpl}[1]{
  \begin{myRule}{#1}
    \AxiomC{\checkClause{\ctx}{\CLAUSE} \quad \inferCmdArr{(\ctx + \{x \mapsto \func\})}{t}{\res}}
    \RightLabelM{\ruleInferPiImpl}
    \UnaryInfC{\inferCmdArr{\ctx}{(\piImplCmd[\func]{x}{\CLAUSE}{t})}{\res}}
  \end{myRule}
}

\newcommand{\ruleInferUnif}{\ruleInfer{rule:infer-unif}{=}}
\newcommand{\inferUnif}[1]{
  % UNIF
  \begin{myRule}{#1}
    \AxiomC{}
    \RightLabelM{\ruleInferUnif}
    \UnaryInfC{\inferCmdArr{\ctx}{(\_ = \_)}{(\detI,\top)}}
  \end{myRule}
}

\newcommand{\ruleInferApp}{\ruleInfer{rule:infer-app}{@}}
\newcommand{\inferApp}[1]{
  % APP
  \begin{myRule}{#1}
    % \AxiomC{\ensuremath{\ctx\ \predVar = \dtype{\func[']}{\func[_i]}{\_}}}
    % \AxiomC{\inferCmdArr[1]{\ctx}{t_i}{\func[_i']}{\_}}
    \AxiomC{\ensuremath{\ctx\ c = \dtype{\func}{\func[_i]}{\func[_o]}}}
    \AxiomC{\dappCmd{\ctx}{\func[_i]}{\func[_o]}{\vecL{t}}{\top}{(\func['_i],\func['_o],\bool)}}
    \RightLabelM{\ruleInferApp}
    \BinaryInfC{\inferCmdArr{\ctx}{(c\ \vecL{t})}{(\dtype{\func}{\func['_i]}{\func['_o]}, \bool)}}
  \end{myRule}
}

\newcommand{\ruleInferExp}{\ruleInfer{rule:inferK}{\DATA}}
\newcommand{\InferExp}[1]{
  \begin{myRule}{#1}
    \AxiomC{$\ctx\ f = \expI$}
    \RightLabelM{\ruleInferExp}
    \UnaryInfC{\inferCmdArr{\ctx}{(f\ \vecL{t})}{(\expI,\top)}}
  \end{myRule}
}
\newcommand{\ruleInferExpL}{\ruleInfer{rule:inferKL}{\DATA'}}
\newcommand{\InferExpL}[1]{
  \begin{myRule}{#1}
    \AxiomC{  }
    \RightLabelM{\ruleInferExpL}
    \UnaryInfC{\inferCmdArr{\ctx}{(\lambda \vecL{x : \_}.t : \expI)}{(\expI,\top)}}
  \end{myRule}
}

\newcommand{\ruleInferLam}{\ruleInfer{rule:infer-lam}{\lambda}}
\newcommand{\inferLam}[1]{
  \begin{myRule}{#1}
    \AxiomC{
    \ensuremath{\pred\ \#\ \ctx \quad\kIF\ \checkc
    {\ (\ctx + \{\pred\mapsto \dtype{\func}{\func[_i]}{\func[_o]}\})}
    {\ (\clauseCmd{\pred}{\vecL{x}\ \vecL{y}}{t})}
    \ \kTHEN\ b = \top\ \kELSE\ b = \bot
    % \ensuremath{\inferCmdArr{(\ctx + \{\vecL{x:\func[_i]}\})}{t}{(\func, \bool)} \qquad \checkInferLamCmd{\ctx}{\func}{t}}
    }}
    \RightLabelM{\ruleInferLam}
    \UnaryInfC{\inferCmdArr{\ctx}{(\lambda \vecL{x:\func[_i]}.\lambda \vecL{y:\func[_o]}.t : \func)}{(\dtype{\func}{\func[_i]}{\func[_o]},\bool)}}
  \end{myRule}
}

% \newcommand{\ruleInferAppRef}[2]{\customlabel{#1}{\ensuremath{I_{#2}}}}
\newcommand{\ruleInferAppRef}[2]{\ruleInfer{#1}{#2}}
% dappCmd[ctx][detInput][detOutput][args][goodCall][res]
\newcommand{\dappCmd}[6]{\ensuremath{\dapp\ #1\ #2\ #3\ #4\ #5 \arr #6}}
\newcommand{\inferAppEmptyRef}{\ruleInferAppRef{rule:inferAppEmpty}{\EmptyList}}
\newcommand{\inferAppEmpty}[1]{
  \begin{myRule}{#1}
    \AxiomC{}
    \RightLabelM{\inferAppEmptyRef}
    \UnaryInfC{\dappCmd{\ctx}{\func[_i]}{\func[_o]}{\EmptyList}{\bool}{(\func[_i],\func[_o], \bool)}}
  \end{myRule}
}

\newcommand{\inferAppEmptyDORef}{\ruleInferAppRef{rule:inferAppOutput}{o}}
\newcommand{\inferAppOutput}[1]{
  \begin{myRule}{#1}
    \AxiomC{\dappCmd{\ctx}{\EmptyList}{\func[_o]}{\vecL{t}}{\bool}{\res}}
    \RightLabelM{\inferAppEmptyDORef}
    \UnaryInfC{\dappCmd{\ctx}{\EmptyList}{(\_ :: \func[_o])}{(\_ :: \vecL{t})}{\bool}{\res}}
  \end{myRule}
}

% \newcommand{\inferAppEmptyDIRef}{\ruleInferAppRef{rule:inferAppInputKO}{\bot}}
% \newcommand{\inferAppInputKO}[1]{
%   \begin{myRule}{#1}
%     \AxiomC{\ensuremath{\bool = \bot \quad \dappCmd{\ctx}{\func[_i]}{\func[_o]}{\vecL{t}}{\bot}{\res}}}
%     \RightLabelM{\inferAppEmptyDIRef}
%     \UnaryInfC{\dappCmd{\ctx}{(\_ :: \func[_i])}{\func[_o]}{(t :: \vecL{t})}{\bool}{\res}}
%   \end{myRule}
% }

\newcommand{\inferAppEmptyDIOKRef}{\ruleInferAppRef{rule:inferAppInputOK}{i}}
\newcommand{\inferAppInputOK}[1]{
  \begin{myRule}{#1}
    \AxiomC{\ensuremath{\inferCmdArr{\ctx}{t}{(\func['],\bool')} \qquad \dappCmd{\ctx}{\func[_i]}{\func[_o]}{\vecL{t}}{(\bool \land \bool' \land \func' \mySub \func)}{\res}}}
    \RightLabelM{\inferAppEmptyDIOKRef}
    \UnaryInfC{\dappCmd{\ctx}{(\func :: \func[_i])}{\func[_o]}{(t :: \vecL{t})}{\bool}{\res}}
  \end{myRule}
}

% \newcommand{\inferFig}{
%   \begin{subfigure}[b]{1\textwidth}
%     \centering
%     \InferExp{0.27}
%     \inferCut{0.30}
%     % \inferUnif{0.31}

%     % \inferPiImpl{0.44}
%     \inferLam{.5}

%     \inferApp{1}

%     % \inferAppFail{1}
% %     \caption{\infer\ relation}
% %     \label{fig:det-inference}
% %   \end{subfigure}
% % }

% % \newcommand{\inferAppFig}{
% %   \begin{subfigure}[b]{1\textwidth}

%     \inferAppEmpty{.45}
%     \inferAppOutput{.45}
%     \inferAppInputKO{1}
%     \inferAppInputOK{1}

%     \caption{\infer}
%     \label{fig:det-inference}
%   \end{subfigure}
% }

\newcommand{\inferFig}{
  \begin{figure}[b]
    \begin{framed}

      \centering
      \InferExp{0.35}
      \InferExpL{0.35}
      % \inferPiImpl{0.60}
      \inferCut{0.4}
      \inferLam{1}
      
      \inferApp{1}
      \inferAppEmpty{.47}
      \inferAppOutput{.47}
      % \inferAppInputKO{1}
      \inferAppInputOK{1}
      \vspace{-1em}
      \caption{$\infer : \ctx \to \TERM \to \SIGN \times \B$}
      \label{fig:det-inference}
    \end{framed}
  \end{figure}
}