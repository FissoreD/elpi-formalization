\section{The meaning of a predicate signature}

It is one of our objectives that the determinacy checker accepts
predicates that are \textit{wrongly} called so that we can, incrementally,
make the predicate signatures more precise.


The \mySub\ relation subsumes signature equality and
extends the intuitive inclusion of mathematical functions
into relations to the recursive nature of predicate signatures, and rejects the
converse inclusion. 
In the spirit of subtyping the input arguments of predicate signature
are compared in a contravariant way. 

\begin{equation}
  f_1 \mySub f_2 =\ 
  \begin{cases}
   \ \bot                                                          & \text{if } f_1 = \dtype{\relI}{\_}{\_}\ \land\ f_2 = \dtype{\detI}{\_}{\_} \\
    % (\forall i, a'_i \mySub a_i) \land (\forall j, b_j \mySub b'_j)      & \text{else if } f_1 = \detI\ a\ b \land f_2 = \detI\ a'\ b' \\
    % (\forall i, a'_i \mySub c_i) \land (\forall j, b_j \mySub c_{|a|+j}) & \text{else if } f_1 = \detI\ a\ b \land f_2 = \relI\ c      \\
    % \forall i, a_i \mySub b_i                                            & \text{else if } f_1 = \relI\ a\ \land f_2 = \relI\ b        \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{else if } f_1 = [\detI\mid \relI]\ a\ b \land f_2 = [\detI\mid \relI]\ c\ d \\
   \ (\forall i, c_i \mySub a_i)\ \land\ (\forall j, b_j \mySub d_j) &
    \!\!\!
    \begin{array}{l} \text{if } f_1 = \dtype{\func}{a}{b}\ \land\ f_2 = \dtype{\func}{c}{d} \ \lor    \\
     \ \ \  f_1 = \dtype{\detI}{a}{b}\ \land\ f_2 = \dtype{\relI}{c}{d} 
    \end{array}    \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
   \ \top                                                          & \text{if } f_1 = \expI\ \land\ f_2 = \expI
  \end{cases}
  \label{eq:sub-def}
\end{equation}

\newcommand{\sem}[1]{\ensuremath{[\![#1]\!]}}
The intuition is that the meaning of a 
predicate signature is given by the following formula where
\isdet\ is an uninterpreted predicate (the definition we give in section~\ref{sec:thm}
does not matter).
\begin{definition}[Meaning of a signature ($\sem{\func}\pred$ for $\ctx\ \pred = \func$)]\label{def:sem}
$$
\begin{array}{rl}
\sem{\dtype{\func_1}{\func_2}{\func_3}}\ \pred{}\!\!& =\ \forall \vecL{t_i}\ \vecL{t_o}, \bigwedge \vecL{\sem{\func_2}\ t_i} \Rightarrow \sem{\func_1}\ (\pred\ t_i\ t_o) \land \bigwedge \vecL{\sem{\func_3}\ t_o}\\
% \sem{\dtype{\func_1}{\func_2}{\func_3}}\ \pred & = \forall t\ u, \overbrace{\sem{\func_2}\ t}^{\mathrm{pre-conditions}} \Rightarrow \overbrace{\sem{\func_1}\ (\pred\ t\ u) \land \sem{\func_3}\ u}{\mathrm{post-conditions}}\\
\sem{\detI}\ \pred{}\!\!& =\ \isdet\ \pred \\
\sem{\relI}\ \pred{}\!\!& =\ \top \\
\sem{\expI}\ \pred{}\!\!& =\ \top 
\end{array}
$$
\end{definition}
The first equation states tht if the preconditions of a signature are satisfied
then the call to a predicate of that signature is
functional and the post conditions on the outputs hold.
The relation \mySub\ is such that if $f_1 \mySub f_2$ then $\sem{f_1} \Rightarrow \sem{f_2}$,
hence the contravariance:
the post conditions of $f_1$ can be stronger than the ones of $f_2$ while
the pre conditions of $f_1$ must be wekaer than the ones of $f_2$.

\section{Signature checking}

The checking process performs a form of dataflow analysis:
It stores the predicate
signature of each variable in \ctx\ and uses it to verify whether the variable
satisfies the precondition of a predicate call or not.
Additionally, it may update the
variable's signature to match the postcondition of
the predicate call.

Updates use the dual operators \(\minT\) and \(\maxT\).  
In their mutual definition below, we encode them thourgh the function \( f \),
parameterized by the determinacy \( d \) (either \(\detI\) or \(\relI\)).
Specifically, \( f_\detI \) represents \(\minT\), while \( f_\relI \)
corresponds to \(\maxT\). We use \( \overline{d} \) to denote the negation of \(
d \), which inverts its determinacy value. The definitions of these functions
are as follows:  

%
\begin{equation}
  f\ s_1\ s_2 =\ 
  \begin{cases}
    %\ \dtype{\detI}{(\vecL{g\ a\ c})}{(\vecL{f\ b\ d})} & \text{if } s_k = \dtype{\relI}{a}{b}\ \land\ s_{3-k} = \dtype{\detI}{c}{d} \\
    \ \dtype{d}{(\map\ f_{\overline{d}}\ \vecL{ac})}{(\map\ f_d\ \vecL{bd})} & \text{if } s_k = \dtype{\relI}{\vec a}{\vec b}\ \land\ s_{3-k} = \dtype{\detI}{\vec c}{\vec d} \\
    %\ \dtype{D}{(\vecL{g\ a\ c})}{(\vecL{f\ b\ d})}     & \text{if } s_1 = \dtype{D}{a}{b}\ \land\ s_2 = \dtype{D}{c}{d}             \\
    \ \dtype{\func}{(\map\ f_{\overline{d}}\ \vecL{ac})}{(\map\ f_d\ \vecL{bd})}     & \text{if } s_1 = \dtype{\func}{\vec a}{\vec b}\ \land\ s_2 = \dtype{\func}{\vec c}{\vec d}             \\
    % \relI\ (\vecL{g}\ a\ c)\ (\vecL{f}\ b\ d) & \text{if } s_1 = \relI\ a\ b \land s_2 = \relI\ c\ d \\
    \ \expI                                                     & \text{if } s_1 = \expI\ \land\ s_2 = \expI
  \end{cases}
  \nonumber
  \label{eq:min}
\end{equation}
\vspace{0.3em}

We assume each clause has been type checked by an algorithm that
traverses terms including variables in \X\ that
represent predicates, e.g. the higher-order parameter of \elpiIn{map}.
Since we want to keep type checking separated from determinacy checking,
the former identifies \relI\ with \detI\ and in particular assigns
to these variables the signature obtained by weakening their
declared signature:
It is up to the determinacy analsysis to assume or prove stronger signatures.
The \maximize\ function is defined mutually with its
dual \minimize. Similarly to the \minT and \maxT, we encode them with the
function $f$ parametrized by a determinacy $d$:
%
% $$
%   \minT\ f_1\ f_2 = \begin{cases}
%     \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_1 \mySub f_2                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
%   \label{eq:maximize}
% \end{equation}
% \begin{equation}
%   \minimize\ f =
%   \begin{cases}
%     \dtype{\detI}{(\vecL{\maximize}\ a)}{(\vecL{\minimize}\ b)} & \text{if } f = \dtype{\_}{a}{b} \\
%     \expI                                                       & \text{if } f = \expI
%   \end{cases}
% $$
%
% The main usage of the \minT\ and \maxT\ comes with the fact that unification is
% possibile between variable with different determinacy annotation. For example,
% let \elpiIn{get-det} and \elpiIn{get-rel} be two relations returning
% respectively a function and a relation (both with zero arguments). In a query like \elpiIn{get-det X,
%   det-rel Y, X = Y} we have three goals to solve, the first allows to label
% \elpiIn{X} with the tag \detI, the second allows to label \elpiIn{Y} with
% the tag \relI. The third goal is interesting since we are unifying two\todo{not true if output are flex}
% predicates with different determinacy labels. Now, the only way that this unificaton
% succeeds at runtime is that \elpiIn{Y} is a function.
% Said in another way, a unification may change the labels of the two terms being
% unified. In the previous example, \detlab\ \elpiIn{X} $=$ \detlab\ \elpiIn{Y} $=$
% \minT\ $($\detlab\ \elpiIn{X}$)$ $($\detlab\ \elpiIn{Y}$)$.
%
% finally when a predcate is miscalled we need a way to deal with its post conditions
%
%
\begin{equation}
  f_d\ s =\ 
  \begin{cases}
    \ \dtype{d}{(\map\ f_{\overline{d}}\ a)}{(\map\ f_d\ b)} & \text{if } s = \dtype{\_}{a}{b} \\
    \ \expI                                                       & \text{if } s = \expI
  \end{cases}
  \label{eq:maximize}
\end{equation}
% \begin{equation}
%   \minimize\ f_1 =
%   \begin{cases}
%     \dtype{\detI}{(\vecL{\maximize}\ a)}{(\vecL{\minimize}\ b)} & \text{if } f = \dtype{\func}{a}{b} \\
%     \expI                                                       & \text{if } f = \expI
%   \end{cases}
%   \label{eq:minimize}
% \end{equation}
%
% The two fonctions respectively return the maximal and minimal dtype of a given
% dtype. This is used \dots
%
% $$---$$
%
% and therefore
% The base cases of \mySub\ are quite intuitive: a relation is not a function. The
% interesting case is the \coqIn{arr} constructor. Here, we are comparing two
% propositions and therefore some attention should be paid for its inputs and
% outputs: the inputs of the left memeber should be at least as restrictive as the
% right one and the outputs of the left memeber are at most as restrictive as the
% right one.
%
% As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
%   \texttt{once}$. 
%
% What may seem weird at first sight is that in the example above, we call
% \texttt{idF} with a relation in input position. This creates a mismatch
% between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
% However, we want our system to be as expressive as possible. This means that
% we allows the user the wrongly call a predicate. In that particular case the dtype of the
% outputs will not be guaranteed to have the expected determinacy: they will be labeled
% with the less restrictive determinacy for its type. To continue our example,
% the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
% tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.
%
% Thanks to the \mySub\ relation we can define a min (resp. max) relation between
% two determinacy relations.
%
%
% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}
%
% These two functions become particularly useful
% when trying to determine the determinacy of unification variables. Let's
% take the following example.
%
% \begin{elpicode}
%   pred give_rel i:int, o:pred.
%   func give_fun i:int, o:func.
%   give_rel _ (divisors 5 X).
%   give_rel _ (succ 1 X).
%   give_fun _ (succ 1 X).
% \end{elpicode}
%
% In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
% that take a dummy integer as input (we conventionally work with binary
% predicates) and return, respectively, a relation and a function.
%
% Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
% The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
% \elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
% should they have? Unification succeeds if the two terms are unifiable, meaning
% that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
% therefore share the same \detlab. Their label will be updated and set to the
% minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI.
%
% If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
% want to statically determine if it create choice points. The determinacy of each
% goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
% that is \relI.
%
% With this, we now have all the ingredients needed to propose the full static
% determinacy checker for the higher-order setting. This checker is implemented in
% \detCheck, which ensures that a deterministic predicate has at most one solution
% per call. Furthermore, it is extended to certify that each output of a clause
% has the expected determinacy, which is crucial since outputs can be used as new
% queries in the program.
%
\inferFig
%
\assumeFig
%
\paragraph{The static checker} We can now exibit the static checker.
The first rules we present allow to \infer\ (\cref{fig:det-inference}) or
\assume\ (\cref{fig:det-assume}) the signature of a predicate and finally to
\checkk\ (\cref{fig:static-check}) if a rule matches a declared signature.
%
% $$\infer : \ctx \to (\A + \T) \to \func \times \B$$
% $$\dapp : \ctx \to \vecL{\func} \to \vecL{\func} \to \vecL{tm} \to \B \to \func \times \func \times \B$$

% TODO: rule for lambda assumes lambdas are ordered according to
% the convetion of input first and that their mode is somehow given.
% We have an heuristic in the type checker for that\todo{Davide?}.

% TODO: rule for app handles partial application like
% the \elpiIn{commit likes V} in the intro and check if
% sigs are respected.

The \infer\ procedure 
%is responsible for inferring the signature of a term. It
returns a pair containing the signature of the given
atom and a boolean value indicating whether
it contains miscalled predicates.
%  Since predicate
% calls are part of the term syntax, they can also be miscalled.  

The rules for \cut\ (\ref{rule:infer-cut}) and functors (\ref{rule:inferK})
are straightforward. Rule \ref{rule:infer-piimpl} introduces a new mapping in
the context, associating the binder with its signature and performing a
recursive call to \infer. $\lambda$-abstractions are handled by
\ref{rule:infer-lam}. We distinguish between binders corresponding to inputs and
those corresponding to outputs. Binders in input positions are added to \ctx\
and mapped to their corresponding signature.  

The rule \ref{rule:infer-app}, combined with the \dapp\ procedure,
handles call when the head is a variable or a predicate
and  accounts for partial applications.  

For example given \elpiIn{func once (pred i:A, o:B), A -> B} as in
the introduction, the partial application \elpiIn{(once likes)}
has the inferred signature
\elpiIn{~\PYG{k+kd}{func}\PYG{+w}{ }\PYG{k+kt}{guest}\PYG{+w}{ }\PYG{k+kMode}{\PYGZhy{}\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{dish}~}.
%
% $t =\ $\elpiIn{map likes!}. Its inferred
% signature is obtained by calling \ref{rule:infer-app}. The signature of
% \elpiIn{map} expects a binary function as the first input argument. Thanks to
% \ref{rule:inferAppInputOK}, we can infer the signature of \elpiIn{likes!}, which
% falls into the category of partial application (in fact, this term is not
% applied at all). Ultimately, the signature of \elpiIn{likes!} is a subtype of
% the expected signature for the first argument of \elpiIn{map}. The result of the
% call to \infer\ on $t$ is the pair $(\dtype{\detI}{\expI}{\expI},\top)$: the
% Boolean value indicates that the predicate call is correct, and the first
% position of the pair expresses the signature of the partially applied term.  
% 
% $$\assume : \func \to (\A + \T) \to \ctx \to \ctx$$  

The \assume\ procedure strenghtens the signature
of variables occurring in the given term by
updates a context \ctx\ according to \func. The rule
governing this change is \ref{rule:assume-hd}, which states that whenever a
non-applied variable is encountered, its signature is set to the \minT\ between
its current signature in \ctx\ and \func.
The intuition is given by definition~ref{def:sem}: when the
preconditions are satisfied we know the post conditions hold. 
% The use of \minT\ is justified by the
% fact that \assume\ represents runtime unification.
% For unification to succeed,
% the variable's signature must be the strongest between the one in the context and
% the expected one.  \todo{enrico help}

The rules \ref{rule:assume-cut} and \ref{rule:assume-expr} are intuitive, as
they do not require any modifications to the context. In rules
\ref{rule:assume-lam} and \ref{rule:assume-piimpl}, we extend the context by
mapping the binder to its signature. % and making a recursive call to \assume.\todo{rule for lambda mh}
Finally, \ref{rule:assume-app} performs a fold over the input arguments of the
predicate being called, under the assumption that the determinacy of the
predicate is smaller than the received one.  
% 
% $$\checkk : \A \to (\ctx \times \F) \to (\ctx \times \F)$$  

\checkTermFig  

The \checkk\ procedure (in \cref{fig:static-check})
tries to prove, in the sense of~\ref{def:sem} the determinacy
of an atom by checkig if the pre conditions and deducing new
knowledge from the post conditions.

% combines both \infer\ and \assume
% to determine if an atom is fu

% . Its purpose is to
% check the execution of a query under a given context and determinacy. The result
% is a new context and an updated determinacy.  

% For example, as shown in \ref{rule:check-cut}, if the term to be executed is a
% \cut, then the context remains unchanged, and the determinacy becomes \detI. If
% a predicate $p$ is called (\ref{rule:check-callOK} and \ref{rule:check-callKO}),
% we first verify whether the call is correct -- i.e., whether the inferred
% signature of the inputs is at least as strong as the expected one. If the call
% is correct, the terms in the output position are assigned the signature of $p$'s
% outputs. If $p$ is miscalled, then the behavior of the call is
% non-deterministic, and we output \relI.  

% If the call is correct, the behavior of the call is determined by the maximum of
% the predicate's determinacy and the input determinacy. For example, if we are in
% a deterministic context and correctly call a relation, then the resulting
% behavior of the query is the maximum of the two, i.e., relational.  

% The ~ref{rule:check-clause} rule concerns the validation of
% an entire clause: It begins by assuming that the input terms
% have the determinacy specified in the signature and
% it analyzes all premises in order, accumulating in \ctx
% all post conditions \checkk\ was able to prove.
% Finally it checks that the determinacy of the body
% matches the declared one, as well as that all output
% signatures are consequences of the body.
% \todo{sucks}

%  Then, we analyze the premises
% of the clause, assuming its behavior is deterministic. Finally, we infer the
% type of the output terms, ensuring that all have their boolean value set to
% $\top$ and that their signature is \mySub compared to the expected determinacy.
% Additionally, we verify that the determinacy of the body (\func['] in the rule)
% is \mySub relative to the expected determinacy (\func\ in the rule).

% xxx

% Rule \ref{rule:check-piimpl} behaves similarly to \ref{rule:assume-piimpl}. It
% also makes some check on the hypothesis $H$. But we delay it to the next
% section.


% If the term is a unification the determinacy \func\ is transmitted from the
% input to the output. What may change is the context, since, during unification
% some variables may be assigned. In \ref{rule:check-unif} we are in the case
% where it is possible to successfully deduce the dtype of the left and the right
% terms of the equality operator. At runitime, unification succeeds if the two
% terms are unifiable. This means that in the end the two terms will share the
% same determinacy. The determinacy the will have is the minimum between the
% determinacy of the two terms. Imagine that we are unifying a function with a
% relation, then the more restrictive condition for both terms should be taken
% into account. Therefore, the \assume\ procedure is called on both terms so that
% their determinacy is set to the minimum. If on the contrary, it is not possible
% to \infer\ a valid dtype for at least one of the two terms (rule
% \ref{rule:check-unifFail}), we cannot deduce much more on the variables in the
% two terms, therefore, we do nothing on the context \ctx, which is returned as it
% was in input.

% The \checkk\ rule for application (see \ref{rule:check-callOK}) starts by
% deducing the type of the input term. If its dtype \func[_i'] can be derived
% (i.e. the booleans is $\top$) and if \func[_i'] is less or equal than the
% expected one in the signature, then the output can be assumed to be the one
% inscribed the signature. If these two conditions are not validated, then the
% rule context is not modified. Concerning determinacy, if the call is valid, then
% the determinacy is the \maxT\ between the one received in entry and the
% determinacy of the head of the application. If, otherwise, the call is wrong,
% then the output determinacy is set to relational.

% $$\checkk : \A \times (\ctx \times \F) \to (\ctx \times \F)$$

% \textbf{TODO: make an example}

% \subsection{Determinacy checking for clauses}

% \staticCheckFig
% \todo{fai con fold}

% We provide an example of this checker in the following database.

% \begin{elpicode}
%   give-fun X (succ X Y).
%   give-fun X (~\texttt{pred}~ X Y).
%   good :- give-fun 3 Res, !, Res.
% \end{elpicode}

% The signatures of the predicates in the snippet above are the following:
% %
% \begin{align*}
%   \texttt{succ}     & : \dtype{\detI}{[\expI]}{[\expI]} & \texttt{pred} & : \dtype{\detI}{[\expI]}{[\expI]} \\
%   \texttt{give-fun} & : \dtype{\relI}{[\expI]}{[\detI]} & \texttt{good} & : \detI
% \end{align*}

% The static checker for determinacy starts by analysing the first rule for
% \texttt{give-fun}. The input is an expression, the body is empty, so in the end
% we only have to check that the output has the output and the body have the right
% determinacy. Now, the determinacy of the body is $\detI \mySub \relI$, the
% determinacy (deduced) for the ouput term is $\detI \mySub \detI$. Therefore the
% rule respect the contract of the signature: the rule is valid. A very similar
% reasonment can be do on the second rule for \texttt{give-fun}. It is now more
% interesting to analyze the clause for \texttt{good}. We have no input, thereofre
% we keep analyze the body. The context on which \checkL\ is launched is $\ctx =
%   \{\text{\elpiIn{Res}}\mapsto \relI\}$ since in the wrost case the determinacy of
% a term with type \texttt{prop} is \relI. The iteration on the terms in the body
% starts by analysing ``\elpiIn{give-fun 3 Res}'' which makes the determinacy of
% the term relational and sets updates the context to
% $\{\text{\elpiIn{Res}}\mapsto \detI\}$, since it is a correct call and its
% output is \assume d to have the functionality of the output in the dype of
% \elpiIn{give-fun}. The \cut\ operator, makes \func\ to become \detI: intuitively
% the \cut discards all choice points, that's way \ref{rule:check-cut} puts the
% determinacy to \detI. Finally we execute a term which, by
% \ref{rule:check-callOK} is deterministic. We conclude the execution of \checkL\
% with $\func = \detI$ and $\ctx = \{\text{\elpiIn{Res}}\mapsto \detI\}$. This is
% exactly what the signature of \texttt{good} expects and therefore the rule
% passes the check.

% $$-----$$

% For instance, we would like that the call \elpiIn{idF divisors X} is valid for
% determinacy, but, since the input has not the expected determinacy, then the
% output will not be a deterministic predicate. Indeed, we propose the following
% ordering relation between deterministic and relational predicates.

% TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

% Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
% invalidato

\newcommand{\pgc}{\texttt{pgCheck}}
\newcommand{\pgcC}{\texttt{pgCheckC}}
\newcommand{\pgcP}{\texttt{pgCheckP}}

% \subsection{Mode checking: propositional-ground mode}
% \label{sec:mc}

% \begin{leftbar}{red}

% The last but not least important point to treat is the mode checker. Similarly
% to the determinacy checker in the literature, the determinacy checker extended
% with higher-order propositional variable need a guarantee on the terms that are
% manipulated during the resolution of a goal. If we take back the predicate
% \elpiIn{idF}, defined at the beginning of \cref{sec:vars} and the predicate
% \elpiIn{give-fun}, defined and the end of the previous paragraph, we can create
% a list of premises contradicting the hypothesis the static checker performs on
% terms.

% The list of goal we may be interested in is \elpiIn{idF X X, X = give-fun 3 Y}.
% This goal naturally succeeds at runtime, but what breaks the checker is the
% hypothesis made on the variable \elpiIn{X}. If we perform a \checkk\ on the
% first atom we realize that 

% As we have sketched in \cref{sec:basic-elpi}, we don't want to perform 

% \begin{definition}[Proposiotions ground check (\pgc)] 
%   ground check: \pgc.
% \end{definition}

% \begin{definition}[Clause prop ground check (\pgcC)]
%   Given a clause, we use the same algorithm as the mode ground checker from
%   the literature, but, instead of using the ground condition on terms, we
%   use the definition of input ground check (\pgc)
% \end{definition}

% \begin{definition}[Program ground check (\pgcP)] 
%   Given a program \prog,
%   $$\forall p\ c, c \in \prog p \to \pgcC\ c$$
% \end{definition}
% \end{leftbar}


% \subsection{The final theorem}

% The final theorem we want to prove is the following.

% \begin{theorem}[Determinacy checking property]
%   Given a context \ctx, a program \prog and a deterministic predicate \pred
%   % \begin{align*}
%   %   &\pgcP\ \prog \to \detCheck\ \prog\ \to \\ 
%   %     &\quad \forall i\ o, \pgc\ i\ \to \isdet\ \prog\ \pred\ i\ o \\
%   %       &\qquad\land \pgc\ o \land \infer\ o = \get{o}p
%   % \end{align*}
%   \begin{align*}
%     \hyperref[def:det-check-ho]{\detCheckHO}\ \prog\ \to
%     (\forall p\ c, c \in \prog\ p \to \hyperref[fig:static-check]{\checkc}\ \ctx\ c) \to \forall \vec{t}, \hyperref[def:is-det]{\isdet}\ \prog\ (\pred\ \vec{t}) %\land \infer\ \vec{t}_o = \get{o}p
%   \end{align*}
%   \vspace{-20pt}
%   \label{th:det3}
% \end{theorem}

% % $$\isdet := \isDetCmd{i}$$

% \begin{proof}
%   We reason on the derivations in \cref{fig:basic-interp} extended with
%   \cref{fig:interp-match,fig:interp-piimpl}. The interesting case is the rule
%   \ref{rule:call} since we have an application in our call the \run.
%   By
% \end{proof}

% \subsection{Mix data with ty}

% \begin{align}
%   data & ::= \texttt{c}\ ty^\ast \mid data \to data \mid \predVar \label{eq:data11}
% \end{align}

% \subsection{Determinacy polymorphism}

% Il problema è ad esmepio la funzione identità

% \begin{elpicode}
%   pred id i:A, o:A.
% \end{elpicode}

% Se id viene chiamato con una deterministic-predicate, allora l'output sarà
% anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
% è passata tra due oggetti che hanno lo stesso tipo.

% Per esempio:

% \begin{elpicode}
%   pred wrong_id i:A, o:A.
%   wrong_id fun rel.
% \end{elpicode}

% Per l'identià si potrebbe definire versioni specializzate:

% \begin{elpicode}
%   pred id1 i:(func A -> A) (func A -> A).
%   id1 X X.
% \end{elpicode}

% Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
% polimorphismo di determinacy.
% Qualcosa tipo:

% \begin{elpicode}
%   pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
% \end{elpicode}

% Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
% la stessa funzionalità.

% \paragraph{\textbf{Digression: inference v.s. checking}}

% Several works \cite{king2005, king2006, 2011king}
% study the inference of determinacy in \prolog system with \cut.
% They explain that determinacy inference subsume determinacy checking.
% We think that an inference algorithm does not fit
% well with our language.

% % The first motivation is that since an \elpi
% % %is an interpreted dialect of \lamprolog,
% % program can change dynamically due to the \impl operator.
% % This means that rules can be added \textit{à la volée} making impossible to infer
% % determinacy as the user expects.
% % It's
% % up to the user to choose what should be the behavior of a predicate wrt
% % determinacy. The checker is meant to assist the user by rejecting, a predicate,
% % that does not respect the declared determinacy.

% As explained in some of the previously cited papers, determinacy (and so
% functionality) checking is an undecidable problem. The checking property is
% sound: if a predicate passes the analysis then it is for sure deterministic.
% However, it is not complete: there could exists false negatives. We are
% convinced, that completeness, is not a big deal, since, as also claimed in ...
% every deterministic predicate not passing the determinacy check,
% can be rewritten in a equivalent way
% so that it is no more classified as non-deterministic.

