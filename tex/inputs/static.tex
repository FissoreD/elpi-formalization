\section{Signature checking}

It is one of our objectives that the determinacy checker accepts
predicates that are \textit{wrongly} called so that we can, incrementally and bottom up,
make the predicate signatures of an existing code base more precise.


The \mySub\ relation subsumes signature equality and
extends the intuitive inclusion of mathematical functions
into relations to the recursive nature of predicate signatures, and rejects the
converse inclusion. 
In the spirit of subtyping the input arguments of predicate signature
are compared in a contravariant way. 
%
\begin{equation}
  f_1 \mySub f_2 =\ 
  \begin{cases}
   \ \bot                                                          & \text{if } f_1 = \dtype{\relI}{\_}{\_}\ \land\ f_2 = \dtype{\detI}{\_}{\_} \\
    % (\forall i, a'_i \mySub a_i) \land (\forall j, b_j \mySub b'_j)      & \text{else if } f_1 = \detI\ a\ b \land f_2 = \detI\ a'\ b' \\
    % (\forall i, a'_i \mySub c_i) \land (\forall j, b_j \mySub c_{|a|+j}) & \text{else if } f_1 = \detI\ a\ b \land f_2 = \relI\ c      \\
    % \forall i, a_i \mySub b_i                                            & \text{else if } f_1 = \relI\ a\ \land f_2 = \relI\ b        \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{else if } f_1 = [\detI\mid \relI]\ a\ b \land f_2 = [\detI\mid \relI]\ c\ d \\
   \ (\forall i, c_i \mySub a_i)\ \land\ (\forall j, b_j \mySub d_j) &
    \!\!\!
    \begin{array}{l} \text{if } f_1 = \dtype{\func}{a}{b}\ \land\ f_2 = \dtype{\func}{c}{d} \ \lor    \\
     \ \ \  f_1 = \dtype{\detI}{a}{b}\ \land\ f_2 = \dtype{\relI}{c}{d} 
    \end{array}    \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
   \ \top                                                          & \text{if } f_1 = \expI\ \land\ f_2 = \expI
  \end{cases}
  \label{eq:sub-def}
\end{equation}

The checking process performs a form of dataflow analysis:
It stores the predicate
signature of each variable in \ctx\ and uses it to verify whether the variable
satisfies the precondition of a predicate call or not.
Additionally, it may update the
variable's signature to match the postcondition of
the predicate call.

Updates use the dual operators \(\minT\) and \(\maxT\).  
In their mutual definition below, we encode them thourgh the function \( f \),
parameterized by the determinacy \( d \) (either \(\detI\) or \(\relI\)).
Specifically, \( f_\detI \) represents \(\minT\), while \( f_\relI \)
corresponds to \(\maxT\). We use \( \overline{d} \) to denote the negation of \(
d \), which inverts its determinacy value. The definitions of these functions
are as follows:  
%
%
\begin{equation}
  f_d\ s_1\ s_2 =\ 
  \begin{cases}
    %\ \dtype{\detI}{(\vecL{g\ a\ c})}{(\vecL{f\ b\ d})} & \text{if } s_k = \dtype{\relI}{a}{b}\ \land\ s_{3-k} = \dtype{\detI}{c}{d} \\
    \ \dtype{d}{(\map\ f_{\overline{d}}\ \vecL{ac})}{(\map\ f_d\ \vecL{bd})} & \text{if } s_k = \dtype{\relI}{\vec a}{\vec b}\ \land\ s_{3-k} = \dtype{\detI}{\vec c}{\vec d} \\
    %\ \dtype{D}{(\vecL{g\ a\ c})}{(\vecL{f\ b\ d})}     & \text{if } s_1 = \dtype{D}{a}{b}\ \land\ s_2 = \dtype{D}{c}{d}             \\
    \ \dtype{\func}{(\map\ f_{\overline{d}}\ \vecL{ac})}{(\map\ f_d\ \vecL{bd})}     & \text{if } s_1 = \dtype{\func}{\vec a}{\vec b}\ \land\ s_2 = \dtype{\func}{\vec c}{\vec d}             \\
    % \relI\ (\vecL{g}\ a\ c)\ (\vecL{f}\ b\ d) & \text{if } s_1 = \relI\ a\ b \land s_2 = \relI\ c\ d \\
    \ \expI                                                     & \text{if } s_1 = \expI\ \land\ s_2 = \expI
  \end{cases}
  \nonumber
  \label{eq:min}
\end{equation}
\vspace{0.1em}

We assume each clause has been type-checked by an algorithm that
traverses terms including variables in \X\ that
represent predicates, e.g. the higher-order parameter of \elpiIn{map}.
Since we want to keep type checking separated from determinacy checking,\todo{not sure}
the former identifies \relI\ with \detI\ and in particular assigns
to these variables the signature obtained by weakening their
declared signature:
It is up to the determinacy analsysis to assume or prove stronger signatures.
The \maximize\ function is defined mutually with its
dual \minimize. Similarly to the \minT and \maxT, we encode them with the
function $f$ parametrized by a determinacy $d$:
%
% $$
%   \minT\ f_1\ f_2 = \begin{cases}
%     \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_1 \mySub f_2                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
%   \label{eq:maximize}
% \end{equation}
% \begin{equation}
%   \minimize\ f =
%   \begin{cases}
%     \dtype{\detI}{(\vecL{\maximize}\ a)}{(\vecL{\minimize}\ b)} & \text{if } f = \dtype{\_}{a}{b} \\
%     \expI                                                       & \text{if } f = \expI
%   \end{cases}
% $$
%
% The main usage of the \minT\ and \maxT\ comes with the fact that unification is
% possibile between variable with different determinacy annotation. For example,
% let \elpiIn{get-det} and \elpiIn{get-rel} be two relations returning
% respectively a function and a relation (both with zero arguments). In a query like \elpiIn{get-det X,
%   det-rel Y, X = Y} we have three goals to solve, the first allows to label
% \elpiIn{X} with the tag \detI, the second allows to label \elpiIn{Y} with
% the tag \relI. The third goal is interesting since we are unifying two\todo{not true if output are flex}
% predicates with different determinacy labels. Now, the only way that this unificaton
% succeeds at runtime is that \elpiIn{Y} is a function.
% Said in another way, a unification may change the labels of the two terms being
% unified. In the previous example, \detlab\ \elpiIn{X} $=$ \detlab\ \elpiIn{Y} $=$
% \minT\ $($\detlab\ \elpiIn{X}$)$ $($\detlab\ \elpiIn{Y}$)$.
%
% finally when a predcate is miscalled we need a way to deal with its post conditions
%
%
\begin{equation}
  f_d\ s =\ 
  \begin{cases}
    \ \dtype{d}{(\map\ f_{\overline{d}}\ a)}{(\map\ f_d\ b)} & \text{if } s = \dtype{\_}{a}{b} \\
    \ \expI                                                       & \text{if } s = \expI
  \end{cases}
  \label{eq:maximize}
\end{equation}
% \begin{equation}
%   \minimize\ f_1 =
%   \begin{cases}
%     \dtype{\detI}{(\vecL{\maximize}\ a)}{(\vecL{\minimize}\ b)} & \text{if } f = \dtype{\func}{a}{b} \\
%     \expI                                                       & \text{if } f = \expI
%   \end{cases}
%   \label{eq:minimize}
% \end{equation}
%
% The two fonctions respectively return the maximal and minimal dtype of a given
% dtype. This is used \dots
%
% $$---$$
%
% and therefore
% The base cases of \mySub\ are quite intuitive: a relation is not a function. The
% interesting case is the \coqIn{arr} constructor. Here, we are comparing two
% propositions and therefore some attention should be paid for its inputs and
% outputs: the inputs of the left memeber should be at least as restrictive as the
% right one and the outputs of the left memeber are at most as restrictive as the
% right one.
%
% As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
%   \texttt{once}$. 
%
% What may seem weird at first sight is that in the example above, we call
% \texttt{idF} with a relation in input position. This creates a mismatch
% between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
% However, we want our system to be as expressive as possible. This means that
% we allows the user the wrongly call a predicate. In that particular case the dtype of the
% outputs will not be guaranteed to have the expected determinacy: they will be labeled
% with the less restrictive determinacy for its type. To continue our example,
% the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
% tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.
%
% Thanks to the \mySub\ relation we can define a min (resp. max) relation between
% two determinacy relations.
%
%
% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}
%
% These two functions become particularly useful
% when trying to determine the determinacy of unification variables. Let's
% take the following example.
%
% \begin{elpicode}
%   pred give_rel i:int, o:pred.
%   func give_fun i:int, o:func.
%   give_rel _ (divisors 5 X).
%   give_rel _ (succ 1 X).
%   give_fun _ (succ 1 X).
% \end{elpicode}
%
% In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
% that take a dummy integer as input (we conventionally work with binary
% predicates) and return, respectively, a relation and a function.
%
% Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
% The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
% \elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
% should they have? Unification succeeds if the two terms are unifiable, meaning
% that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
% therefore share the same \detlab. Their label will be updated and set to the
% minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI.
%
% If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
% want to statically determine if it create choice points. The determinacy of each
% goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
% that is \relI.
%
% With this, we now have all the ingredients needed to propose the full static
% determinacy checker for the higher-order setting. This checker is implemented in
% \detCheck, which ensures that a deterministic predicate has at most one solution
% per call. Furthermore, it is extended to certify that each output of a clause
% has the expected determinacy, which is crucial since outputs can be used as new
% queries in the program.
%
\inferFig
%
\assumeFig
%
\paragraph{The static checker} We can now exibit the static checker.
The first rules we present allow to \infer\ (\cref{fig:det-inference}) or
\assume\ (\cref{fig:det-assume}) the signature of a term and finally to
\checkk\ (\cref{fig:static-check}) if it matches (via \mySub) the expected signature.
%
% $$\infer : \ctx \to (\A + \T) \to \func \times \B$$
% $$\dapp : \ctx \to \vecL{\func} \to \vecL{\func} \to \vecL{tm} \to \B \to \func \times \func \times \B$$

% TODO: rule for lambda assumes lambdas are ordered according to
% the convetion of input first and that their mode is somehow given.
% We have an heuristic in the type checker for that\todo{Davide?}.

% TODO: rule for app handles partial application like
% the \elpiIn{commit likes V} in the intro and check if
% sigs are respected.

The \infer\ procedure 
%is responsible for inferring the signature of a term. It
returns a pair containing the signature of the given
a term and a boolean value indicating whether
it contains miscalled predicates.
%  Since predicate
% calls are part of the term syntax, they can also be miscalled.  

The rules for \cut\ (\ref{rule:infer-cut}) and functors (\ref{rule:inferK} and \ref{rule:inferKL}) are
straightforward. %Rule \ref{rule:infer-piimpl} introduces a new mapping in the
% context, associating the binder with its signature and performing a recursive
% call to \infer. 
$\lambda$-abstractions are handled by \ref{rule:infer-lam}. This rules
transforms the $lambda$-term in a clause for a fresh clause which is checked
thanks to \checkc (\ref{rule:check-clause}). This checking phase is needed to
ensure that the term under the spine of lambda is functional if it should be and
that the outputs becomes terms with the expected signature. 
% As an example,
% consider the query \elpiIn{X = (x\y\ commit likes y), map X Y Z}. Since
% \elpiIn{X} is passed in the input of \elpiIn{map}, we need to be sure that its
% signature reflects expected determinacy, that is 
% \elpiIn{~\PYG{k+kd}{func}\PYG{+w}{ }\PYG{k+kt}{A}\PYG{+w}{ }\PYG{k+kMode}{\PYGZhy{}\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{B}~}. 
% To have
% this guarantee, we check a rule with fresh predicate name \elpiIn{fresh_name x y
% :- commit likes y} with \elpiIn{func fresh_name A -> B}.

This strict verification is necessary because anonymous functions can appear as
the head of atoms and its behavior should match the determinacy specified in the
signature. For example: \elpiIn{X = (x:func\y:func\ (commit x y):func), X like F, F paul Z}.

The rule \ref{rule:infer-app}, combined with the \dapp\ procedure,
handles calls when the head is a variable or a predicate
and accounts both for full and partial applications. \dapp\ aims essentially
to verify that the inferred signature of the inputs of a term respect the
expected signature. If it is not the case, it returns $\bot$.

For example given \elpiIn{func once (pred i:A, o:B), A -> B} as in
the introduction, the partial application \elpiIn{(once likes)}
has the inferred signature
\elpiIn{~\PYG{k+kd}{func}\PYG{+w}{ }\PYG{k+kt}{guest}\PYG{+w}{ }\PYG{k+kMode}{\PYGZhy{}\PYGZgt{}}\PYG{+w}{ }\PYG{k+kt}{dish}~}.
%
% $t =\ $\elpiIn{map likes!}. Its inferred
% signature is obtained by calling \ref{rule:infer-app}. The signature of
% \elpiIn{map} expects a binary function as the first input argument. Thanks to
% \ref{rule:inferAppInputOK}, we can infer the signature of \elpiIn{likes!}, which
% falls into the category of partial application (in fact, this term is not
% applied at all). Ultimately, the signature of \elpiIn{likes!} is a subtype of
% the expected signature for the first argument of \elpiIn{map}. The result of the
% call to \infer\ on $t$ is the pair $(\dtype{\detI}{\expI}{\expI},\top)$: the
% Boolean value indicates that the predicate call is correct, and the first
% position of the pair expresses the signature of the partially applied term.  
% 
% $$\assume : \func \to (\A + \T) \to \ctx \to \ctx$$  

The \assume\ procedure is meant to strenghten the signature\todo{role of input}
of variables occurring in a given term. This strengthening is made
by exploring a term $t$ together with an assumed determinacy $\func$.
If a variable is ever encountered in $t$ and the assumed determinacy
is $\func$, then its mapping in \ctx is set to the minimum between
its current signature in \ctx\ and \func.

% The intuition is given by definition~ref{def:sem}: when the
% preconditions are satisfied we know the post conditions hold. 
The use of \minT\ is justified by the fact that \assume\ represents runtime
unification. For unification to succeed, the variable's signature must be the
strongest between the one in the context and the expected one. For example,
if \elpiIn{X = Y, X = commit likes F} with $\ctx\ Y = \relI$. 

The rules \ref{rule:assume-cut}, \ref{rule:assume-expr} and \ref{rule:assume-exprl} are intuitive, as
they do not require any modifications to the context, for the two last cases
there is no need to make assumption on expressions, since expressions
play no role in the checker (only propositional terms do). In rules
\ref{rule:assume-lam}, we extend the context by
mapping the binder to its signature and making a recursive call to \assume
Finally, \ref{rule:assume-app} performs a fold over the input arguments of the
predicate being called, under the assumption that the determinacy of the
predicate is smaller than the received one.  
% 
% $$\checkk : \A \to (\ctx \times \F) \to (\ctx \times \F)$$  

\checkTermFig  


The \checkk\ procedure (in \cref{fig:static-check}) attempts to prove, in the
sense of~\cref{def:sem}, the determinacy of an atom by verifying the
preconditions—i.e., whether the input argument can be inferred to have a
determinacy \mySub consistent with the expected signature. If the preconditions
are satisfied, the procedure assumes new knowledge for the postconditions,
meaning they are expected to maintain the prescribed determinacy. \checkk also
is charged to update the determinacy of the atom wrt a given determinacy
$\func$. In a way, it tries to track what is the behavior (relational or
deterministic) after the exectution of the program. Note that in the case of
\ref{rule:check-cut}, we set the determinacy to \detI. In the case the \piimpl
operator, we add the new clause in the program and check that it is in
mutual-exclusion (\mutExclAll, see \cref{def:mut-excl} below) wrt the other
clause in the current program. 

\begin{definition}[Mutual exclusion \mutExclAll]
  Given a program \prog and a clause $r = \clauseCmd{p}{\vecL{t}}{\vec{bs}}$,
  $\mutExclAll\ \prog\ r$ holds iff there is a \cut in the body of $r$ or forall
  clauses $r' = \clauseCmd{p}{\vecL{t'}}{\vec{bs'}}$ declared after $r$ in
  \prog, there exists an input position $d$ discriminating them, i.e. 
  $\forall \subst, \unifyCmd{t_d}{t_d'}{\subst}{\bot}$
  \label{def:mut-excl}
\end{definition}

\ref{rule:check-callOK} and \ref{rule:check-callKO} deals
with term applications, and if the terms has valid inputs, then the output are
assumed to have the expected signature, otherwise, nothing can be deduced on the
output and the execution of the atom becomes relational.

The \checkc\ procedure validates a clause by ensuring that its input respects
the signature of the implemented predicate. It then verifies the list of
premises, ensuring that the context is updated correctly according to the flow
of variables in input and output positions while maintaining the functionality
of the body. The clause is validated if it its output are inferred to have a 
determinacy \mySub then the one in the signature. The same test is done
with the determinacy of the body with the expected.

\subsection{Inference and Assumptions only on terms in input position}

We want to point out why in the \infer and \assume routine, we only deal with
input arguments. In both cases, applications reason with the input terms.
The inference is launched on atoms in negative position, i.e. atoms that
are called in the program. In order to respect the semantics of pre-conditions,
we need to be sure the ...

Potrebbe avere senso:

\begin{elpicode}
  func p -> (func).
  p (commit id Y).
\end{elpicode}

Consider the query: \elpiIn{p (commit X Y)}.
We make no assumption on Y, since it is an output of commit, but `X' is 
considered function. Note that otherwise the checker would have rejected the
clause.

% combines both \infer\ and \assume
% to determine if an atom is fu

% . Its purpose is to
% check the execution of a query under a given context and determinacy. The result
% is a new context and an updated determinacy.  

% For example, as shown in \ref{rule:check-cut}, if the term to be executed is a
% \cut, then the context remains unchanged, and the determinacy becomes \detI. If
% a predicate $p$ is called (\ref{rule:check-callOK} and \ref{rule:check-callKO}),
% we first verify whether the call is correct -- i.e., whether the inferred
% signature of the inputs is at least as strong as the expected one. If the call
% is correct, the terms in the output position are assigned the signature of $p$'s
% outputs. If $p$ is miscalled, then the behavior of the call is
% non-deterministic, and we output \relI.  

% If the call is correct, the behavior of the call is determined by the maximum of
% the predicate's determinacy and the input determinacy. For example, if we are in
% a deterministic context and correctly call a relation, then the resulting
% behavior of the query is the maximum of the two, i.e., relational.  

% The ~ref{rule:check-clause} rule concerns the validation of
% an entire clause: It begins by assuming that the input terms
% have the determinacy specified in the signature and
% it analyzes all premises in order, accumulating in \ctx
% all post conditions \checkk\ was able to prove.
% Finally it checks that the determinacy of the body
% matches the declared one, as well as that all output
% signatures are consequences of the body.
% \todo{sucks}

%  Then, we analyze the premises
% of the clause, assuming its behavior is deterministic. Finally, we infer the
% type of the output terms, ensuring that all have their boolean value set to
% $\top$ and that their signature is \mySub compared to the expected determinacy.
% Additionally, we verify that the determinacy of the body (\func['] in the rule)
% is \mySub relative to the expected determinacy (\func\ in the rule).

% xxx

% Rule \ref{rule:check-piimpl} behaves similarly to \ref{rule:assume-piimpl}. It
% also makes some check on the hypothesis $H$. But we delay it to the next
% section.


% If the term is a unification the determinacy \func\ is transmitted from the
% input to the output. What may change is the context, since, during unification
% some variables may be assigned. In \ref{rule:check-unif} we are in the case
% where it is possible to successfully deduce the dtype of the left and the right
% terms of the equality operator. At runitime, unification succeeds if the two
% terms are unifiable. This means that in the end the two terms will share the
% same determinacy. The determinacy the will have is the minimum between the
% determinacy of the two terms. Imagine that we are unifying a function with a
% relation, then the more restrictive condition for both terms should be taken
% into account. Therefore, the \assume\ procedure is called on both terms so that
% their determinacy is set to the minimum. If on the contrary, it is not possible
% to \infer\ a valid dtype for at least one of the two terms (rule
% \ref{rule:check-unifFail}), we cannot deduce much more on the variables in the
% two terms, therefore, we do nothing on the context \ctx, which is returned as it
% was in input.

% The \checkk\ rule for application (see \ref{rule:check-callOK}) starts by
% deducing the type of the input term. If its dtype \func[_i'] can be derived
% (i.e. the booleans is $\top$) and if \func[_i'] is less or equal than the
% expected one in the signature, then the output can be assumed to be the one
% inscribed the signature. If these two conditions are not validated, then the
% rule context is not modified. Concerning determinacy, if the call is valid, then
% the determinacy is the \maxT\ between the one received in entry and the
% determinacy of the head of the application. If, otherwise, the call is wrong,
% then the output determinacy is set to relational.

% $$\checkk : \A \times (\ctx \times \F) \to (\ctx \times \F)$$

% \textbf{TODO: make an example}

% \subsection{Determinacy checking for clauses}

% \staticCheckFig
% \todo{fai con fold}

% We provide an example of this checker in the following database.

% \begin{elpicode}
%   give-fun X (succ X Y).
%   give-fun X (~\texttt{pred}~ X Y).
%   good :- give-fun 3 Res, !, Res.
% \end{elpicode}

% The signatures of the predicates in the snippet above are the following:
% %
% \begin{align*}
%   \texttt{succ}     & : \dtype{\detI}{[\expI]}{[\expI]} & \texttt{pred} & : \dtype{\detI}{[\expI]}{[\expI]} \\
%   \texttt{give-fun} & : \dtype{\relI}{[\expI]}{[\detI]} & \texttt{good} & : \detI
% \end{align*}

% The static checker for determinacy starts by analysing the first rule for
% \texttt{give-fun}. The input is an expression, the body is empty, so in the end
% we only have to check that the output has the output and the body have the right
% determinacy. Now, the determinacy of the body is $\detI \mySub \relI$, the
% determinacy (deduced) for the ouput term is $\detI \mySub \detI$. Therefore the
% rule respect the contract of the signature: the rule is valid. A very similar
% reasonment can be do on the second rule for \texttt{give-fun}. It is now more
% interesting to analyze the clause for \texttt{good}. We have no input, thereofre
% we keep analyze the body. The context on which \checkL\ is launched is $\ctx =
%   \{\text{\elpiIn{Res}}\mapsto \relI\}$ since in the wrost case the determinacy of
% a term with type \texttt{prop} is \relI. The iteration on the terms in the body
% starts by analysing ``\elpiIn{give-fun 3 Res}'' which makes the determinacy of
% the term relational and sets updates the context to
% $\{\text{\elpiIn{Res}}\mapsto \detI\}$, since it is a correct call and its
% output is \assume d to have the functionality of the output in the dype of
% \elpiIn{give-fun}. The \cut\ operator, makes \func\ to become \detI: intuitively
% the \cut discards all choice points, that's way \ref{rule:check-cut} puts the
% determinacy to \detI. Finally we execute a term which, by
% \ref{rule:check-callOK} is deterministic. We conclude the execution of \checkL\
% with $\func = \detI$ and $\ctx = \{\text{\elpiIn{Res}}\mapsto \detI\}$. This is
% exactly what the signature of \texttt{good} expects and therefore the rule
% passes the check.

% $$-----$$

% For instance, we would like that the call \elpiIn{idF divisors X} is valid for
% determinacy, but, since the input has not the expected determinacy, then the
% output will not be a deterministic predicate. Indeed, we propose the following
% ordering relation between deterministic and relational predicates.

% TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

% Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
% invalidato

\newcommand{\pgc}{\texttt{pgCheck}}
\newcommand{\pgcC}{\texttt{pgCheckC}}
\newcommand{\pgcP}{\texttt{pgCheckP}}

% \subsection{Mode checking: propositional-ground mode}
% \label{sec:mc}

% \begin{leftbar}{red}

% The last but not least important point to treat is the mode checker. Similarly
% to the determinacy checker in the literature, the determinacy checker extended
% with higher-order propositional variable need a guarantee on the terms that are
% manipulated during the resolution of a goal. If we take back the predicate
% \elpiIn{idF}, defined at the beginning of \cref{sec:vars} and the predicate
% \elpiIn{give-fun}, defined and the end of the previous paragraph, we can create
% a list of premises contradicting the hypothesis the static checker performs on
% terms.

% The list of goal we may be interested in is \elpiIn{idF X X, X = give-fun 3 Y}.
% This goal naturally succeeds at runtime, but what breaks the checker is the
% hypothesis made on the variable \elpiIn{X}. If we perform a \checkk\ on the
% first atom we realize that 

% As we have sketched in \cref{sec:basic-elpi}, we don't want to perform 

% \begin{definition}[Proposiotions ground check (\pgc)] 
%   ground check: \pgc.
% \end{definition}

% \begin{definition}[Clause prop ground check (\pgcC)]
%   Given a clause, we use the same algorithm as the mode ground checker from
%   the literature, but, instead of using the ground condition on terms, we
%   use the definition of input ground check (\pgc)
% \end{definition}

% \begin{definition}[Program ground check (\pgcP)] 
%   Given a program \prog,
%   $$\forall p\ c, c \in \prog p \to \pgcC\ c$$
% \end{definition}
% \end{leftbar}


% \subsection{The final theorem}

% The final theorem we want to prove is the following.

% \begin{theorem}[Determinacy checking property]
%   Given a context \ctx, a program \prog and a deterministic predicate \pred
%   % \begin{align*}
%   %   &\pgcP\ \prog \to \detCheck\ \prog\ \to \\ 
%   %     &\quad \forall i\ o, \pgc\ i\ \to \isdet\ \prog\ \pred\ i\ o \\
%   %       &\qquad\land \pgc\ o \land \infer\ o = \get{o}p
%   % \end{align*}
%   \begin{align*}
%     \hyperref[def:det-check-ho]{\detCheckHO}\ \prog\ \to
%     (\forall p\ c, c \in \prog\ p \to \hyperref[fig:static-check]{\checkc}\ \ctx\ c) \to \forall \vec{t}, \hyperref[def:is-det]{\isdet}\ \prog\ (\pred\ \vec{t}) %\land \infer\ \vec{t}_o = \get{o}p
%   \end{align*}
%   \vspace{-20pt}
%   \label{th:det3}
% \end{theorem}

% % $$\isdet := \isDetCmd{i}$$

% \begin{proof}
%   We reason on the derivations in \cref{fig:basic-interp} extended with
%   \cref{fig:interp-match,fig:interp-piimpl}. The interesting case is the rule
%   \ref{rule:call} since we have an application in our call the \run.
%   By
% \end{proof}

% \subsection{Mix data with ty}

% \begin{align}
%   data & ::= \texttt{c}\ ty^\ast \mid data \to data \mid \predVar \label{eq:data11}
% \end{align}

% \subsection{Determinacy polymorphism}

% Il problema è ad esmepio la funzione identità

% \begin{elpicode}
%   pred id i:A, o:A.
% \end{elpicode}

% Se id viene chiamato con una deterministic-predicate, allora l'output sarà
% anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
% è passata tra due oggetti che hanno lo stesso tipo.

% Per esempio:

% \begin{elpicode}
%   pred wrong_id i:A, o:A.
%   wrong_id fun rel.
% \end{elpicode}

% Per l'identià si potrebbe definire versioni specializzate:

% \begin{elpicode}
%   pred id1 i:(func A -> A) (func A -> A).
%   id1 X X.
% \end{elpicode}

% Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
% polimorphismo di determinacy.
% Qualcosa tipo:

% \begin{elpicode}
%   pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
% \end{elpicode}

% Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
% la stessa funzionalità.

% \paragraph{\textbf{Digression: inference v.s. checking}}

% Several works \cite{king2005, king2006, 2011king}
% study the inference of determinacy in \prolog system with \cut.
% They explain that determinacy inference subsume determinacy checking.
% We think that an inference algorithm does not fit
% well with our language.

% % The first motivation is that since an \elpi
% % %is an interpreted dialect of \lamprolog,
% % program can change dynamically due to the \impl operator.
% % This means that rules can be added \textit{à la volée} making impossible to infer
% % determinacy as the user expects.
% % It's
% % up to the user to choose what should be the behavior of a predicate wrt
% % determinacy. The checker is meant to assist the user by rejecting, a predicate,
% % that does not respect the declared determinacy.

% As explained in some of the previously cited papers, determinacy (and so
% functionality) checking is an undecidable problem. The checking property is
% sound: if a predicate passes the analysis then it is for sure deterministic.
% However, it is not complete: there could exists false negatives. We are
% convinced, that completeness, is not a big deal, since, as also claimed in ...
% every deterministic predicate not passing the determinacy check,
% can be rewritten in a equivalent way
% so that it is no more classified as non-deterministic.

