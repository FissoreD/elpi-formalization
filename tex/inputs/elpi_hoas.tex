\section{Prolog with higher-order variables in datatype}
\label{sec:hoas}

An improvement of the current version of the interpreter comes with the fact
that the \elpi accepts hareditary-harrop formulas and higher-order pattern
unification (\cite{1991miller-pf}), noted \pf. This extension allows to
dynamically modify the program by inserting fresh variables and clauses.
Moreover, in order to express using the higher-order abstract syntax (HOAS,
\cite{1988pfenning}) we also add $\lambda$-abstractions to the language.
% 
% In order to pass to the full \elpi language, we need to change the way terms and clauses are 
% represented. We give, therefore, their implementation below.
% 
% \begin{coqcode}
%   Inductive tpos := 
%     | a (i:base)            
%     | impl (c:tneg) (b:tpos)   
%     | pi   (n:string) (b: tpos)
%     | conj (l:list tpos)       
%     | cut                      
%     | unif  (x:any) (y:any)    
%     | match (x:any) (y:any)    
%   with tneg :=
%     | hb  (h: base) (b: list tpos)
%     | piN (x: string) (b : tneg)  
%   with base :=
%     | c (c : pn) (l:list any)
%     | v (v : vn) (l:list any)
%   with any := 
%     | p (i:tpos) 
%     | n (i:tneg) 
%     | b (i:base) 
%     | s (i:string).
% \end{coqcode}
% 
% NOTA: mi sembra sia più facile avere predicati di arità qualsiasi
% 
% \begin{coqcode}
%   | PiImpl (x:vn) (c:clause) (b:tm)
% \end{coqcode}
%
\begin{align}
  data &::= ... \mid data \to data\\
  tm &::= ... \mid \piImplCmd[type]{\predVar}{clause}{tm} \mid \lambda \predVar: type.tm
\end{align}

The term \piImplCmd[ty]{x}{H}{B} introduces $x$ as a local fresh variable with
type $ty$ inside \implCmd{H}{B}. Then the clause $H$ is added in the scope of
$B$ with highest priority. Note that this constructor can be split in two, one
talking about the $\pi$, the other talking about the $\impl$ operator, we prefer
however to have a sole constructor. It is always possible, in fact, to quantify
dummy variables and hypothesis, reproducing exactly the behaviors of the single
operators. Finally, the $\lambda x: ty.t$ construct allows to abstract the
variable $x$ with type $ty$ inside $t$. We also have extended the non-terminal
$data$ so that the type of $\lambda$-expressions can be represented.

\subsection{Interpreter for prolog with higher-order variables in datatype}


To account for the new constructor in the language, we extend our interpreter.
The updated rule is shown in \cref{fig:interp-piimpl}.  

\begin{figure}
  \rulePiImplM{.85}
  
  % \rulePiM{.85}

  % \ruleLamM{.85}
  \caption{Dynamic semantics: rule for higher-order prolog}
  \label{fig:interp-piimpl}
\end{figure}

We can remark that the terms accepted by the interpreter are still terms in the
canonical form, i.e. no lambda abstraction can appear in the head of a
application. Moreover, we intentionally keep out from the interpreter
application with head being variables. This essentially means that variables are
still not executable piece of code.  Variables will play an important role in
\cref{sec:vars}.


We modify the signature of a \goal, which now takes a context \ctx instead of
just a program \prog. This context, denoted as \ctx, consists of a pair: a
program \prog and a set of local variables \env. Consequently, all occurrences
of \prog in \cref{fig:basic-interp} should now be read as \ctx.  

When the function $\mathcal{F}$ searches for the implementation of a predicate,
it should extract the first component of \ctx\ to obtain the expected output.

The notation $H + \prog$ is the insertion of the clause $H$ 
in the program \prog so that $H$ has
the highest priority in \prog. The notation
$x \uplus \env$\todo{penso si possa togliere}
is the insertion of the local variable $x$ inside the set of local binders \env
provided that $x \notin \env$.

% The rule \ruleImpl handles the atom \implCmd{H}{B}, and its derivation rule
% attempts to solve \( B \) under a program extended with the clause \( H \). The
% rule \rulePi introduces the name of the fresh variable into the program.  

The rule \ref{rule:piimpl} in \cref{fig:interp-piimpl} is interpreted by running the
goal under the \pi\ and the \impl\ charging both the local variable and clause
inside its scope.

The \unify and \match procedures now consider \env\ to perform \pf\
unification. \env is required to know if a term is in the pattern fragment.

% Finally the \ruleLam makes a $\beta$-reduction step and keep solving the goal.

\subsection{Determinacy checker for prolog with higher-order variables in datatype}

The insertion of the new rule makes the determinacy checker to change
accordingly. In particular, the rule $H$ charged by \impl\ in
\cref{fig:interp-piimpl} may break \cref{th:mut-excl}. This is because the rule
being added may overlap with other existing rules. This means that the execution of $B$ may
produce several results which is not the desired behavior if the $B$ should be
deterministic.

In order to address this problem, we need to ensure that the dynamic insertion
of the new clause $H$ in the program is such that if $H$ successfully applies on a goal
then all the other clause fails. To ensure this propery to following condition
should be granted.

\begin{definition}[Local clauses: mutually-exclusion + det. premises (\locExcl)]
  Given a clause $c$ and a predicate \pred, for any subterm $s$ of $c$, then
  $$s = \piImplCmd{x}{(\clauseCmd{\pred}{i\ o}{t_1, \dots, t_n})}{D} \to \exists
  i, t_i = \cut \land (\forall k, k > i \to \detAtom\ a_i)$$
  \vspace{-2em}
\end{definition}

% NOTA:
% \begin{definition}[Mutually-exclusive local clauses (\locExcl)]
%   Given a clause $c$, for any subterm in $c$ with the shape
%   $\piImplCmd{x}{(\clauseCmd{\pred}{i\ o}{B})}{D}$ then $x = i$ or a \cut is in
%   $B$. 
% \end{definition}
% È sbagliato per la mutual exclusion: controesempio
% programma `f Z 3`
% goal: pi x\ f x 1 :- body_with_no_bang => f x R
% Per backtracking potrei istanziare R a 1 o 3

Thanks to this we can define the mutual-exlusion definition in the higher-order
setting.

\begin{definition}[Mutual-exclusion in HOAS (\mutExclHO)]
  Given a program \prog, forall deterministic predicate \pred, mutual exclusion is defined as
  follows:
  $$\mutExcl\ \prog \land (\forall \pred[']\
  c, c\in \prog\ \pred['] \to \locExcl\ c\ \pred)$$
  \vspace{-2em}
  \label{def:det-check-ho}
\end{definition}


\begin{theorem}[Determinacy checking in HOAS]
  Given a program \prog and a predicate \pred
  \begin{align*}
    &\detCheckHO\ \prog\ \pred \to \forall i\ o,\runCmd{[\goalCmd{\prog}{\callCmd{p}{i\ o}}{\EmptyList}]}{\EmptyList}{\EmptySubst}{a}{\subst} \to a = \EmptyList    
  \end{align*}
  \vspace{-2em}
  \label{th:det2}
\end{theorem}

\begin{proof}
  The proof is similar to \cref{th:det1}. We only need to prove that the
  property holds in a program where some rules for  \pred\ may be loaded locally
  during the exectution of a subgoal. By definition of \ref{rule:piimpl}, any new
  added local clause $c$ for \pred has the highest priority, therefore, to
  ensure that \pred remains deterministic we need to consider two cases: 1) $c$
  successfully applies on the current goal and 2) $c$ does not successfully
  apply on the goal. The latter case is easy to prove since it is the induction
  hypothesis. On the other hand, if $c$ successfully applies then, by the
  hypothesis, we know that a \cut\ is in the body of $c$, this means that all
  choice points are cut away, moreover, since, by the same hypothesis, all terms
  after this cut are deterministic, it means that at most on solution is
  returned for the call to \pred.
\end{proof}


% check that
% the body of each local clauses (even those appearing inside the body of
% \lam-abstraction) has a \cut\ in its body. Therefore, the goal
% $(\lamCmd{x}{\implCmd{x}{t_1}}) t_2$, where the local clause is loaded inside
% the body of the \lam-abstraction is rejected: the static checker does not
% perform any reduction in the code, nor it knows the shape of $t_2$. On the other
% hand, the \mutExclHeads\ procedure will accept the term
% $(\lamCmd{x}{\implCmd{(\clauseCmd{f}{x\ 1}{!})}{t_1}}) t_2$.

% This condition is sufficient to make \cref{th:mut-excl} to work again: since the
% checker ensures that all clauses have a cut in their body, and since by
% hypothesis, all the clauses of the program satisfy \cref{def:mut-excl}, then the
% lemma is valid.
% Attenzione, guardare che la regola abbia alemno una variabile local in posizione
% di input non è sufficiente: esempio `pi x\ f x 1 => f x 2 => ...

% To address the second problem, we need to ensure that if a predicate is
% deterministic and has a $\beta$-reduction ``$(\lamCmd{x}{B})T$'' after the last
% \cut, then the reduced term is still a call to a deterministic predicate. This
% check can be performed by looking to the shape of $B$. We know that, by
% construction, $B$ may contains a tower of \pi and hypothetical clauses lodaded
% with \impl. At the bottom of this tower we will have either a \cut, which does
% not impact \cref{def:det-prem}, or a call. This call may use $B$ has the head of
% the predicate, e.g. take $(\ruleLam{x}{x 1 2}{t_1})$. In the system of
% derivation rules, due to the lack of an interpretation for variables, we can
% safely suppose that $T$ ($t_1$ in the example) is a rigid term. Therefore,
% by looking to its determinacy-annotation, we know if the $\beta$-reduced term is
% deterministic or not. On the other hand, 