\section{Syntax}
\label{sec:basic}

We assume a set \PRED of predicate names, %\todo{pradicate with piimpl as arg?}
a set \DATA of functors (term constructors), and a set \VAR of term variables
($X,Y,\ldots$ for unification variables and $x,y,\ldots$ for bound variables).
The non-terminal \CALL groups callable symbols ($c,d,\ldots$): either predicate names
or variables.

In the syntax of atoms \ATOM we single out the \cut operator since it has a
dedicated treatment in the operational semantics.
The non-terminal $\TERM$, for terms, include predicate calls, functor applications and $\lambda$-abstraction.
For simplicity we glue together the
\elpiIn{pi} and \elpiIn{=>} in the same grammar production and we
rule out predicates inside data (like lists of predicates).
Moreover, as this paper does not really focus on type checking
(the interested reader can refer to~\cite{1992nadathur}) 
we collapse all non-predicate types to a single node \texttt{exp} in
the non-terminal $\TYPE$. Finally
we impose the body of $\lambda$-abstractions to be explicitly typed
with a base type (if the body is a predicate, then it must be fully applied).

The programmer provides a context \ctx{} that assigns a
signature $\SIGN$ to each predicate name or variable. By convention predicates take
all input arguments first and then the output ones:
We separate them with $\funsep$ and we omit the symbols when there are no arguments
(i.e. $\SIGN$ degenerates to a determinacy marker \F).
The marker \detI{} stands for deterministic (or functional) while
\relI{} for non-deterministic. By convention
\func, \func['], $\func[_1] \ldots$ range over signatures \SIGN{} or determinacy markers \F.
Looking back at the examples in \cref{sec:examples}
we have that
$\ctx~\texttt{likes} = \dtype{\relI}{\expI}{\expI}$,
that
$\ctx~\texttt{likes!} = \dtype{\detI}{\expI}{\expI}$,
and also $\ctx\ \texttt{true} = \relI$ (no arguments, no $\funsep$ symbol).


%for regular data or \V{} for 
% and polymorphic data.
% We note $\Ainst \in \A$.
% The usual =/2 operator is
% encoded as a regular predicate \texttt{eq} with a single clause
% \elpiIn{(eq X X :- .)} and signature\todo{dire che poly Ã¨ solo su exp}
% $\ctx\ \texttt{eq} = \dtype{\detI}{}{\expI\ \expI}$: a deterministic predicate\todo{should add var to static check}
% with two outputs of the same type.
We write \(\vecL{t}\) to denote \(t_1 \ldots t_n\) i.e. a (possibly
empty) list of \(t\)s.
Similarly, we write \(\vecL{tu}\) to denote the
element-wise pairing (zipping) of \(\vecL{t}\) and \(\vecL{u}\) into a list of
pairs. The zipping process continues up to the length of the shorter list.
% \todo{check for dead cod here if we hide the proofs}

Given a call $\pred \vecL{t}$ %to a n-ary predicate 
where
$\ctx\ \pred = \dtype{\func}{{i}_1 \ldots {i}_k}{{o}_{k+1} \ldots {o}_n}$ we
write $\vecL{t_i}$ for the input arguments ${t}_1 \ldots {t}_k$;
$\vecL{t_o}$ for the output ones ${t}_{k+1} \ldots {t}_n$ and
we define $\mathrm{arity}\ p = n$.
We say that $|t_1 \ldots t_n| = n$.
We write
$t[y/x]$ for the usual, capture avoiding, operation of replacing the variable $x$
with $y$ inside $t$.
We say that $\vars\ t$ is the set
of free variables occurring in $t$ (the binders are \elpiIn{pi} and $\lambda$).
When $\vars\ t = \EmptyList$ we say that
$t$ is \ground.

We call \emph{toplevel clauses} the ones that are in the initial program.
%or equivalently that are asserted by the atoms in the query. 
We call
\emph{hypothetical clauses} the ones that are asserted by atoms in the premises
of a clause.

\newcommand{\syntaxFig}{
  \begin{subfigure}[b]{1\textwidth}
    \centering
  $$
  \begin{array}{rlr}
    \PRED & ::= p, q, \ldots & \mathrm{predicate}\\
    \DATA & ::= f, g \ldots & \mathrm{data\ constructor}\\
    \VAR & ::= \mathrm{X}, \mathrm{Y} \ldots x, y, \ldots & \mathrm{variable}\\
    \CALLHD & ::= \PRED \mid  \VAR & \mathrm{callable}\\
    \ATOM& ::= \cut \mid \CALLHD\ \vecL{\TERM} \mid \piImplCmd[\expI]{\VAR}{\CLAUSE}{\ATOM} & \mathrm{atom} \\
    \TERM & ::= \DATA\ \vecL{\TERM} \mid \CALLHD\ \vecL{\TERM} \mid \lambda \VAR\!\!: \TYPE \bs\ \TERM\!\!: \BASE & \mathrm{term}\\
    \CLAUSE & ::= \clauseCmd{\PRED}{\vecL{\TERM}}{\vecL{\ATOM}} & \mathrm{clause} \\
    \F & ::= \detI \mid \relI & \mathrm{determinacy marker} \\
    % \V & ::= \mathrm{A}, \mathrm{B}, \ldots & \mathrm{type\ variable} \\
    \SIGN & ::= \F\ \vecL{\TYPE} \funsep \vecL{\TYPE} & \mathrm{determinacy\ signature} \\
    \BASE & ::= \expI \mid \F & \mathrm{base\ type} \\
    \TYPE   & ::= \BASE \mid \SIGN & \mathrm{type} 
  \end{array}
  $$
\end{subfigure}
}

\begin{figure}[b]
  \begin{framed}
  \vspace{-.5em}
  \syntaxFig
\end{framed}
  \vspace{-1em}
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}
% \todo{serve \V per eq, ma poi exp?}
% \marginpar{pred-> is allowed}

% When two substitutions have disjoint domains we write $\sigma_1 \cup \sigma_2$
% as the (disjoint) union of two substitutions.

%\todo{consumer?}

% As this paper does not really focus on type checking (the interested reader can
% refer to~\cite{1992nadathur}) we collapse all non-predicate types to
% a single node \texttt{exp} %for regular data or \V{} for 
% and polymorphic data.
% %\todo{what about \V?}
% %  At the same time we enrich the $o$ type
% % of propositions with a marker in \D and  
% We also rule out predicates inside data,
% such as list of predicates, for space constraints.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Operational semantics}

We use $\EmptyList$ for the empty list and $x :: xs$ for prepending an element $x$
to a list $xs$; $\atsign$ for list concatenation;
$[e\ \kIF\ p|x \in \vec{x}]$ for list comprehension (we omit the filter when $p$ is true).
We use the list processing combinators \fold and \map defined by the following equations:
$$
\begin{array}{lll}
\fold\ \_\ \_\ \bot = \bot & \fold\ f\ (x :: xs)\ a = \fold\ f\ xs\ (f\ x\ a) & \fold\ \_\ \EmptyList\ a = a \\
\map\ \_\ \EmptyList = \EmptyList & \map\ f\ (x :: xs) = f\ x :: \map\ f\ xs
\end{array}
$$

\noindent

We denote with $\_\times\_$, $\_+\_$, $\vecL{\phantom{i}\_~}$ and $\_\to\_$ the product, disjoint union, list and
function space of types, respectively, and with $\B = \{ \top, \bot\}$ the booleans.
We omit the conversion between the (isomorphic) types $A \times B \to C$
and $A \to B \to C$, e.g. we may write $\map\ f\ \vecL{tu}$ instead of $\map\ (\lambda x.f\ (\text{fst}\ x)\ (\text{snd}\ x))\ \vecL{tu}$.

A substitution $\subst$ is a mapping from unification variables
\VAR to terms \TERM{} (we call this function space $\Sigma$). 
We write $\subst t$ the application of a substitution \subst to a term $t$,
and we remark that $t$ is \ground{} iff $\forall \subst, \subst t = t$.
We write $\dom\ \subst$ for the set of variables occurring
in the domain or in the codomain of \subst, i.e.
$\dom\ \subst = \{ X\ |\ \subst X \mathrm{\ is\ defined\ } \lor X \in \vars\ (\subst Y) \mathrm{\ for\ some\ Y} \}$.
The empty substitution $\EmptySubst$ is so that $\dom\ \EmptySubst = \EmptyList$.

We assume a function $\unify$ of type $\TERM \times \TERM \times \Sigma \to \Sigma + \bot$
such that if $\unifyCmd{t_1}{t_2}{\subst}{\subst[']} \not= \bot$ 
then \subst['] is the most general extension of \subst 
such that $\subst['] t_1 = \subst['] t_2$ %\todo{extension=unifier?}
as in~\cite{1991miller-pf}.
We assume a function $\match$ of type $\TERM \times \TERM \times \Sigma \to \Sigma + \bot$
such that if $\matchCmd{t}{p}{\subst}{\subst[']} \not= \bot$
then \subst[']  is the most general extension of  $\subst$
such that $\subst t = \subst['] p$ and $\subst[']t = \subst t$,
i.e. \match{} does not assign variables in $t$ but only in $p$ that acts as the pattern.

A program $\prog = (\mathbb{N}, \mathcal{I})$ holds a set of names $\mathbb{N}$ and a
mapping $\mathcal{I}$ from predicate names to an \emph{ordered list} of clauses
(where the head has higher priority).
We write $x \# \prog$ to find a name fresh in $\mathbb{N}$.
We write $\prog~\pred$ for the clauses of predicate \pred in $\mathcal{I}$
and we write $(x,h) + \prog$ to add
the name $x$ to $\mathbb{N}$ and prepend the extra clause $h$  to $\mathcal{I}$
(hence $h$ has the highest priority in the new program).

\newcommand{\runFig}{
  % \begin{subfigure}[b]{1\textwidth}
    \centering

  \ruleBangM{.4}
  \ruleCallMFH{0.44}
  \vspace{0.3em}%

  \ruleCallM{1}
%
  $$
  \!\! \mathcal{F}(\prog, \pred\, \vecL{t}, \vecL{g}, \subst, a) =
  \bigg[
    %\bigg(
    \subst['],
    %\Big(
    %\underbrace{
      \big(\big[(\prog, g, a) \mid g \in\! \vecL{b}\big] \atsign\ \vecL{g}\big)
    %}_{\mathrm{premises}} \atsign ~ \vecL{g}
    \ \kIF\ \mathcal{H}(\vecL{tu}, \subst) = \subst['] \not= \bot
    %\Big)
    %\bigg)
    ~\bigg\rvert~
    (\clauseCmd{\pred}{\vecL{u}}{\vecL{b}}) \in \prog\ \pred
    \bigg]
  $$
  $$
  \mathcal{H}(\vecL{tu}, \subst) = \fold\ \unify\ \vecL{tu_o}\ (\fold\ \match\ \vecL{tu_i}\ \subst)
  $$
  
  \ruleStopM{.37}
  \ruleCallMF{0.58}


  \rulePiImplM{1}
  \ruleCallBeta{1}

% \end{subfigure}
}

A goal $\g \subseteq \prog \times \ATOM\times \vecL{\alt}$
is a triple made of a program, an atom and a list of
so called \emph{cut-to} alternatives.
An alternative $a \in \alt \subseteq \Sigma \times \vecL{\g}$ is a
pair made of a substitution and a list of goals.

\begin{figure}[t!]
  \begin{framed}
    \runFig
  \end{framed}
    \vspace{-1em}
    \caption{$\run{} : \alt \times \vecL{\alt} \to (\vecL{\alt} \times \Sigma) + \bot$}
    \label{fig:basic-interp}
\end{figure}


The operational, big step, semantics of Elpi is given by the function
$\run{}$  in \cref{fig:basic-interp}.
We write \runCmd{\vecL{g}}{a}{\subst}{a'}{\subst'}
when a goal list $\vecL{g}$ under a substitution \subst and alternatives $a$
terminates with a substitution $\subst'$ and a remaining list of
(still unexplored) alternatives $a'$. We write  \runCmdF{\vecL{g}}{a}{\subst}
when the execution halts: fails to solve one of the given goals and runs out of
alternatives. 
An initial query looks like \runQuery{[\goalCmd{\prog}{\pred\ \vecL{t}}{\EmptyList}]}{\EmptyList}

% In this section the program never changes during execution hence storing it
% in the goal seems useless, but the program will change dynamically
% in section~\ref{sec:hoas} where the implication operator \elpiIn{=>} is
% introduced.


  % $$
  % \mathcal{F}(\prog, \pred\ \vec{t}, \vecL{g}, \subst, a) :=
  % \bigg[
  %   %\bigg(
  %   \subst,
  %   %\Big(
  %   \underbrace{\big[(\prog, t = u, ~a) \mid (t,u) \in \vecL{t,u}\big]}_{\mathrm{head\ unification}} \atsign
  %   \underbrace{\big[(\prog, g, a) \mid g \in \vecL{g}\big]}_{\mathrm{premises}} \atsign ~ \vecL{g}
  %   %\Big)
  %   %\bigg)
  %   ~\bigg\rvert~
  %   (\clauseCmd{\pred}{\vec{u}}{\vecL{g}}) \in \prog\ \pred
  %   \bigg]
  % $$


  % \ruleUnifM{.6}
  % \ruleFailM{.55}
  % \ruleAbortM{.4}
  
  %\vspace{0.3em}%

% The rules for \run{} are given in~\cref{fig:basic-interp}.
The first rule to look at is the one for cut (\ref{rule:cut}):
% Remark that the cut-to alternatives stored in each goal are a suffix
% of the (global) alternatives to that goal: 
If the atom in the goal
is a cut then the global alternatives are shortened to the cut-to ones.

The cut rule goes hand in hand with~\ref{rule:call} that stores
the current alternatives $al$ in all the subgoals via
the function $\mathcal{F}$. This function is in charge of creating the
%\todo{dire che F le restituisce in ordine}
new alternatives $\alts['] :: al'$;
the former is directly evaluated while
the rest prepended to the existing list of alternatives.
$\mathcal{H}$ filters applicable clauses by unifying their heads with
the goal. If no clause applies, then rule ~\ref{rule:callbacktrack} moves
to the next alternative (backtracks to the most recent choice point) if
any, otherwise rule ~\ref{rule:callabort} terminates with failure.
A peculiarity of Elpi is that input arguments are \emph{matched} against
the corresponding terms in the head of the rule, while outputs are unified.

The stop rule~\ref{rule:stop} terminates the goal with success as there are no more goals to be
solved and returns the current susbtitution and the yet to be explored
alternatives.

Rule~\ref{rule:piimpl} postulates a fresh symbol $y$ and replaces the bound $x$
for $y$ everywhere, then it loads the new clause $h$ into the program.
%so that it has the highest priority.

The last rule~\ref{rule:beta} deals with the fact that an atom can be
a variable. If that variable is assgined in $\subst$ to a term
that happens to be a predicate, then it proceeds.
% We write $=_{\beta\eta}$
% since the equational theory of $\lambda$Prolog (hence Elpi) requires
% that but plays no role in this paper (the reference
% for the equational theory of $\lambda$Prolog is~\cite{1991miller-pf}).

The operational semantics we present is essentially a big-step version of the
one given in~\cite{1990Vink}, extended to accommodate the higher-order
constructs of $\lambda$Prolog and the input-matching behavior specific to Elpi.
It is also worth mentioning \cite{qi2009}, where the author proposes a semantics
for an implementation of a higher-order \textit{pure} $\lambda$Prolog, which,
therefore, has no equivalent for the cut operator and lacks the notion of clause
prioritiy. 
Our semantics describes an SLD search strategy with a \textit{hard-cut} operator
in the sense of~\cite{2003Andrews}: it not only prunes later clauses of the same
predicate but also eliminates alternatives for subgoals that appear
earlier in the clause premise. 
We opted for an operational semantics rather than a denotational one (as
in~\cite{2011king}) to maintain a concrete representation of the current choice
points, that is essential for the notion of function we
use in \cref{sec:thm}.

