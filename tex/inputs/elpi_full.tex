\section{HOAS}
\label{sec:hoas}

The full potential of \elpi comes with the fact that the language accepts
hareditary-harrop formulas and higher-order pattern unification
(\cite{1991miller-pf}), noted \pf. This extension allows to dynamically modify
the program by inserting fresh variables and clauses.

% In order to pass to the full \elpi language, we need to change the way terms and clauses are 
% represented. We give, therefore, their implementation below.

% \begin{coqcode}
%   Inductive tpos := 
%     | a (i:base)            
%     | impl (c:tneg) (b:tpos)   
%     | pi   (n:string) (b: tpos)
%     | conj (l:list tpos)       
%     | cut                      
%     | unif  (x:any) (y:any)    
%     | match (x:any) (y:any)    
%   with tneg :=
%     | hb  (h: base) (b: list tpos)
%     | piN (x: string) (b : tneg)  
%   with base :=
%     | c (c : pn) (l:list any)
%     | v (v : vn) (l:list any)
%   with any := 
%     | p (i:tpos) 
%     | n (i:tneg) 
%     | b (i:base) 
%     | s (i:string).
% \end{coqcode}

% NOTA: mi sembra sia più facile avere predicati di arità qualsiasi
In order to represent these new constructs of the language,
we add a new constructor to \coqIn{tm}:
\begin{coqcode}
  | PiImpl (x:vn) (c:clause) (b:tm)
\end{coqcode}

We note this constructor as follows: \piImplCmd{x}{H}{B}. It introduces $x$ as a
local fresh variable inside \implCmd{H}{B} and adds in the scope of $B$
the hypothesis $H$.

DIRE CHE NON PERDIAMO IN ESPRESSIVITA, possiamo quantificare un pi che non
è usato in its body, oppure possiamo caricare una regola dummy che non è
usata in its body

\subsection{Interpreter for HOAS}


To account for the new constructor in the language, we extend our interpreter.
The updated rule is shown in \cref{fig:full-interp}.  

We modify the signature of a \goal, which now takes a context \ctx instead of
just a program \prog. This context, denoted as \ctx, consists of a pair: a
program \prog and a set of local variables \env. Consequently, all occurrences
of \prog in \cref{fig:basic-interp} should now be read as \ctx.  

When the function $\mathcal{F}$ searches for the implementation of a predicate,
it should extract the first component of \ctx\ to obtain the expected output.

\begin{figure}
  \rulePiImplM{.85}
  
  % \rulePiM{.85}

  % \ruleLamM{.85}
  \caption{Higher-order derivation rules}
  \label{fig:full-interp}
\end{figure}

The notation $H + \prog$ is the insertion of the clause $H$ 
in the program \prog so that $H$ has
the highest priority in \prog. The notation
$x \uplus \env$
is the insertion of the local variable $x$ inside the set of local binders \env
provided that $x \notin \env$.

% The rule \ruleImpl handles the atom \implCmd{H}{B}, and its derivation rule
% attempts to solve \( B \) under a program extended with the clause \( H \). The
% rule \rulePi introduces the name of the fresh variable into the program.  

The rule \rulePiImpl in \cref{fig:full-interp} is interpreted by running the
goal under the \pi and the \impl charging both the local variable and clause
inside its scope.

The \unify and \match procedures now consider \env\ to perform \pf\
unification. \env is required to know if a term is in the pattern fragment.

% Finally the \ruleLam makes a $\beta$-reduction step and keep solving the goal.

\subsection{Determinacy checker with HOAS}

The insertion of the new rule makes the determinacy checker to change
accordingly. In particular, the rule $H$ charged by \impl\ in
\cref{fig:full-interp} may break \cref{def:mut-excl}. This is because the rule
being added may overlap with other existing rules. This means that the execution of $B$ may
produce several results which is not the desired behavior if the $B$ should be
deterministic.

In order to address this problem, we need to ensure that the dynamic insertion
of the new clause $H$ in the program is such that if $H$ successfully applies on a goal
then all the other clause fails. To ensure this propery to following condition
should be granted.

\begin{definition}[Local clauses: mutually-exclusion + det. premises (\locExcl)]
  Given a clause $c$ and a predicate \pred, for any subterm $s$ of $c$, then
  $$s = \piImplCmd{x}{(\clauseCmd{\pred}{i\ o}{t_1, \dots, t_n})}{D} \to \exists
  i, t_i = \cut \land (\forall k, k > i \to \detAtom\ a_i)$$
  \vspace{-2em}
\end{definition}

% NOTA:
% \begin{definition}[Mutually-exclusive local clauses (\locExcl)]
%   Given a clause $c$, for any subterm in $c$ with the shape
%   $\piImplCmd{x}{(\clauseCmd{\pred}{i\ o}{B})}{D}$ then $x = i$ or a \cut is in
%   $B$. 
% \end{definition}
% È sbagliato per la mutual exclusion: controesempio
% programma `f Z 3`
% goal: pi x\ f x 1 :- body_with_no_bang => f x R
% Per backtracking potrei istanziare R a 1 o 3

Thanks to this we can define the mutual-exlusion definition in the higher-order
setting.

\begin{definition}[Mutual-exclusion in HOAS (\mutExclHO)]
  Given a program \prog and a predicate \pred, mutual exclusion is defined as
  $$\mutExcl\footnote{see \cref{def:mut-excl}}\ \prog\ \pred \land (\forall \pred[']\
  c, c\in \prog\ \pred['] \to \locExcl\ c\ \pred)$$
  \vspace{-2em}
  \label{def:mut-exclHO}
\end{definition}


\begin{theorem}[Determinacy checking in HOAS]
  Given a program \prog and a predicate \pred
  \begin{align*}
    &\detCheckHO\ \prog\ \pred \to \forall i\ o,\runCmd{[\goalCmd{\prog}{\callCmd{p}{i}{o}}{\EmptyList}]}{\EmptyList}{\EmptySubst}{a}{\subst} \to a = \EmptyList    
  \end{align*}
  \vspace{-2em}
  \label{th:det2}
\end{theorem}

\begin{proof}
  The proof is similar to \cref{th:det1}. We only need to prove that the
  property holds in a program where some rules for  \pred\ may be loaded locally
  during the exectution of a subgoal. By definition of \rulePiImpl, any new
  added local clause $c$ for \pred has the highest priority, therefore, to
  ensure that \pred remains deterministic we need to consider two cases: 1) $c$
  successfully applies on the current goal and 2) $c$ does not successfully
  apply on the goal. The latter case is easy to prove since it is the induction
  hypothesis. On the other hand, if $c$ successfully applies then, by the
  hypothesis, we know that a \cut\ is in the body of $c$, this means that all
  choice points are cut away, moreover, since, by the same hypothesis, all terms
  after this cut are deterministic, it means that at most on solution is
  returned for the call to \pred.
\end{proof}


% check that
% the body of each local clauses (even those appearing inside the body of
% \lam-abstraction) has a \cut\ in its body. Therefore, the goal
% $(\lamCmd{x}{\implCmd{x}{t_1}}) t_2$, where the local clause is loaded inside
% the body of the \lam-abstraction is rejected: the static checker does not
% perform any reduction in the code, nor it knows the shape of $t_2$. On the other
% hand, the \mutExclHeads\ procedure will accept the term
% $(\lamCmd{x}{\implCmd{(\clauseCmd{f}{x\ 1}{!})}{t_1}}) t_2$.

% This condition is sufficient to make \cref{th:mut-excl} to work again: since the
% checker ensures that all clauses have a cut in their body, and since by
% hypothesis, all the clauses of the program satisfy \cref{def:mut-excl}, then the
% lemma is valid.
% Attenzione, guardare che la regola abbia alemno una variabile local in posizione
% di input non è sufficiente: esempio `pi x\ f x 1 => f x 2 => ...

% To address the second problem, we need to ensure that if a predicate is
% deterministic and has a $\beta$-reduction ``$(\lamCmd{x}{B})T$'' after the last
% \cut, then the reduced term is still a call to a deterministic predicate. This
% check can be performed by looking to the shape of $B$. We know that, by
% construction, $B$ may contains a tower of \pi and hypothetical clauses lodaded
% with \impl. At the bottom of this tower we will have either a \cut, which does
% not impact \cref{def:det-prem}, or a call. This call may use $B$ has the head of
% the predicate, e.g. take $(\ruleLam{x}{x 1 2}{t_1})$. In the system of
% derivation rules, due to the lack of an interpretation for variables, we can
% safely suppose that $T$ ($t_1$ in the example) is a rigid term. Therefore,
% by looking to its determinacy-annotation, we know if the $\beta$-reduced term is
% deterministic or not. On the other hand, 

\section{Variable comes into the game}
\label{sec:vars}

TODO: add the rule for variable interpretation in the run system

Since the parameters of predicates can be passed both as input and output to
predicate calls, we need to extend the syntax of signatures so that the user can instruct the
\elpi's compiler\todo{compiler vs interpreter in \elpi} about if an input (resp.
an output) should be considered as a deterministic proposition.

% \begin{elpicode}
%   pred divisor i:int, o:int.
%   pred help i:int, i:int, o:int.

%   divisor N R :- help N 1 R.
%   help N X X :- 0 is N mod X.
%   help N X R :- X < N, X' is X + 1, help N X' R. 

%   [(pi N R\ divisor N R :- help N 1 R),
%   (pi N X\ help N X X :- 0 is N mod X),
%   (pi N X R X'\ help N X R :- X < N, X' is X + 1, help N X' R)] => divisor 10 R. 
% \end{elpicode}

From now on let \elpiIn{divisor} be the predicate from \elpiIn{int} to
\elpiIn{int} taking an integer and returning its divisors, one by one in
increasing order.

Let \elpiIn{once} be a predicate with only one clause ``\elpiIn{once P (P, !)}''.
From this implementation, we see that the \elpiIn{once} predicate has
the following property: it takes a proposition and returns its deterministic
version, i.e. the output is the call to \elpiIn{P} where all of its choice
points have been cut away (note the presence of the \cut\ in the second argument). To be more concrete, the query
\elpiIn{once (divisor 5 X) P, P} will instantiate \elpiIn{X} only once
to \elpiIn{1} (note that the query \elpiIn{divisor 5 X}
has two solutions for \elpiIn{X}, namely \elpiIn{1} and \elpiIn{5}). Another
information about \elpiIn{once} is that it is a deterministic predicate, that
is, not only its output is a function but \elpiIn{once} itself is a function.

To provide the compiler all of these pieces of information about the predicate
\elpiIn{once}, the user should add a signature to the predicate.  
\Elpi's signatures are as follows:
GRAMMAR

TODO: dire che func sta per funzionale e rel sta per relazionale

So the signature of \elpiIn{once} will be: ``\elpiIn{func once i:pred, o:func}''
where \elpiIn{once} is a function, it takes a
relation and returns a function.

% Since predicate parameters can now be passed to other predicate calls, and since
% these calls may affect the determinacy of a predicate, we need to specialize
% our determinacy checker.
\begin{elpicode}
  func apply5 i:(func int -> int), o:int.
  apply5 F R :- F 5 R.
\end{elpicode}

Consider now, the \elpiIn{apply5} predicate depicted above. It is a function
that takes a function from \elpiIn{int} to \elpiIn{int} and returns the result of
applying that function to \elpiIn{5}. What happens if we
execute the query \elpiIn{apply
divisors X}? We see that its output is not deterministic: the assignment for
\elpiIn{X} is not deterministically determined -- there are, in fact, two
possible assignments: one where \elpiIn{X} is assigned to \elpiIn{1} and another
where it is assigned \elpiIn{5}.

RIUTILIZZARE CODICE!!

SEPARARE IL CHIAMARE GIUSTO UN PREDICATO (per riusare codice)

Another problem is showed by the followig code:
\begin{elpicode}
  func idF i:func, o:func.
  idF X X.
\end{elpicode}
  % func p i:(func int -> int), o:(pred i:int, o:int).
  % p X X :- X = divisors.

In the snippet, we define the identity function over functions.

With \elpi's dynamic mode system, the call ``\elpiIn{idF Y Y, Y = divisor 5
X, Y}'' succeeds because we can pass flexible terms in input positions. The problem
here is that, based on the signature of \elpiIn{idF}, its output is a function.
This allows us to assume that the variable \elpiIn{Y} is a function. However,
after the unification between \elpiIn{Y} and \elpiIn{divisor 5 X}, we lose that
property: calling \elpiIn{Y} produces several results for \elpiIn{X}.

DIRE CHE DIAMO L'ALGORITMO DI DETERMINACY CHECKING, PRIMA ATTRAVERSO ESEMPI E POI
RIASSIUMIAMO TUTTO

To address this issue, we could statically annotate terms with their determinacy
status in a way similar to the static mode checking for ground terms. Then,
when a unification is performed between two terms, a compilation error
could be raise if their determinacy tag mismatch.
In the example above, \elpiIn{Y = divisor} would be rejected since \elpiIn{Y}
would be annotated as a function and \elpiIn{divsor} is a relation.

% \newcommand{\detT}[1]{\text{\mlIn{~\PYG{n+nc}{#1}~}}}


The labels we need are defined with the following inductive:

\begin{coqcode}
  Inductive ~\detlab~ := Exp | Rel | Det | arr (i:detlab) (o:detlab).
\end{coqcode}

A term is either an expression (an non executable peice of code), a relational
or a deterministic predicate or finally an arrow (just like the arrow used for
the types of functions) between two \detlab. For the last constructor we
will use the notation $d_1 \myTo d_2$ where $d_1$ and $d_2$ are instances of\todo{i:detlab list if multiple args}
\detlab, moreover we consider $d_1$ to be an input and $d_2$ to be an output.
We are again considering binary relations. This can always be generalized to
functions (or relations) of any arity by slightly changing the signature of
the \coqIn{arr} constructor.

The problem of this first algorithm of determinacy check is that it does not
take into account a natural relation that exists between functions and
relations, i.e. a function is a relation such that all of the member in its
domain points to a unique value in its codomain. This means that a fuction can
be always passed in place of a relation. We define below the inclusion relation
between two \detlab.

\begin{coqcode}
  Fixpoint a ~\mySub~ b := match a, b with
  | Rel, Func -> false
  | Func, Rel | Rel, Rel | Func, Func | Exp, Exp -> true
  | a ~\myTo~ b, a' ~\myTo~ b' -> a' ~\mySub~ a && b ~\mySub~ b'
  end.
\end{coqcode}

The \mySub\ relation is intentionally non-complete since we suppose that before
performing any determinacy checking the program has been type-checked. This
means that it is never possible to have unification between, for example,
expressions and relations, this would lead to a fatal type-error.

The base cases of \mySub\ are quite intuitive: a relation is not a function. The
interesting case is the \coqIn{arr} constructor. Here, we are comparing two
propositions and therefore some attention should be paid for its inputs and
outputs: the inputs of the left memeber should be at least as restrictive as the
right one and the outputs of the left memeber are at most as restrictive as the
right one.

As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
\texttt{once}$. The determinacy of $t_1$ is $\detT{Func} \myTo \detT{Func}$ and
the determinacy of $t_2$ is $\detT{Rel} \myTo \detT{Func}$. We intuitively
remark that $\forall p_1\ p_2\ p_3, \texttt{once}\ p_1\ p_2 \to \texttt{idF}\
p_1\ p_3 \to p_2 \mySub p_3$. This is because the two predicates can be called
with a relation and the output of \texttt{idF} is still a relation whereas the
output of \texttt{once} is still a function, i.e. the determinacy type of
\texttt{once} is more constraining. Said in other words, $\detT{Rel} \myTo
\detT{Func} \mySub \detT{Func} \myTo \detT{Func}$.

What may seem weird at first sight is that in the example above, we call
\texttt{idF} with a relation in input position. This creates a mismatch
between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
However, we want our system to be as expressive as possible. This means that
we allows the user the wrongly call a predicate. In that particular case the dtype of the
outputs will not be guaranteed to have the expected determinacy: they will be labeled 
with the less restrictive determinacy for its type. To continue our example,
the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.

Thanks to the \mySub\ relation we can define a min (resp. max) relation between
two determinacy relations.

$$
\minT\ f_1\ f_2 = \begin{cases}
  \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
  f_1 & \text{else if } f_1 \mySub f_2\\
  f_2 & \text{otherwise}
\end{cases}
$$
$$
\maxT\ f_1\ f_2 = \begin{cases}
  \minT\ a'\ a \myTo \maxT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
  f_1 & \text{else if } f_2 \mySub f_1\\
  f_2 & \text{otherwise}
\end{cases}
$$

% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}

These two functions become particularly useful
when trying to determine the determinacy of unification variables. Let's
take the following example.

\begin{elpicode}
  pred give_rel i:int, o:pred.
  func give_fun i:int, o:func.
  give_rel _ (divisors 5 X).
  give_rel _ (succ 1 X).
  give_fun _ (succ 1 X).
\end{elpicode}

In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
that take a dummy integer as input (we conventionally work with binary
predicates) and return, respectively, a relation and a function. 

Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
\elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
should they have? Unification succeeds if the two terms are unifiable, meaning
that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
therefore share the same \detlab. Their label will be updated and set to the
minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI. 

If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
want to statically determine if it create choice points. The determinacy of each
goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
that is \relI.

With this, we now have all the ingredients needed to propose the full static
determinacy checker for the higher-order setting. This checker is implemented in
\detCheck, which ensures that a deterministic predicate has at most one solution
per call. Furthermore, it is extended to certify that each output of a clause
has the expected determinacy, which is crucial since outputs can be used as new
queries in the program.

TODO: redifine \cref{def:det-prem}: we can have variables has props.


\begin{figure}
  \centering
  
  \ruleCheckClauseM{1}

  
  \ruleCheckCutM{.45}
  \ruleCheckEmptyM{.35}
  
  \ruleCheckPiM{.7}
  \ruleCheckImplM{.7}

  \ruleCheckUnifM{.7}

  % \ruleCheckMatchM{.7}
  \ruleCheckCallM{1}
  \ruleCheckCallFailM{1}
  
  \caption{Static check rules}
  \label{fig:static-check}
\end{figure}

$$-----$$

For instance, we would like that the call \elpiIn{idF divisors X} is valid for
determinacy, but, since the input has not the expected determinacy, then the
output will not be a deterministic predicate. Indeed, we propose the following
ordering relation between deterministic and relational predicates.

TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
invalidato

\subsection{Mode checking: input-ground mode}
\label{sec:mc}
Dire come funziona il mode checking e spiegare che è una condizione sufficiente
per avere la determinacy.

\subsection{Mutual exclusion for local clauses}
Polarity check: inner clauses when using the impl construct

Da spostare prima della sezione \cref{sec:mc}

\subsection{Determinacy polymorphism}

Il problema è ad esmepio la funzione identità

\begin{elpicode}
  pred id i:A, o:A.
\end{elpicode}

Se id viene chiamato con una deterministic-predicate, allora l'output sarà
anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
è passata tra due oggetti che hanno lo stesso tipo.

Per esempio:

\begin{elpicode}
  pred wrong_id i:A, o:A.
  wrong_id fun rel.
\end{elpicode}

Per l'identià si potrebbe definire versioni specializzate:

\begin{elpicode}
  pred id1 i:(func A -> A) (func A -> A).
  id1 X X.
\end{elpicode}

Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
polimorphismo di determinacy.
Qualcosa tipo:

\begin{elpicode}
  pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
\end{elpicode}

Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
la stessa funzionalità.