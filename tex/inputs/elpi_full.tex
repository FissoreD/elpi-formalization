\section{Full elpi}
\label{sec:full-elpi}

The full potential of \elpi comes with the fact that the language accepts
hareditary-harrop formulas and higher-order pattern unification
(\cite{1991miller-pf}), noted \pf. This extension allows program to be dynamically modified
by the insertion of local clauses, moreover, local universally quantified
terms can be quantified within a clause.

% In order to pass to the full \elpi language, we need to change the way terms and clauses are 
% represented. We give, therefore, their implementation below.

% \begin{coqcode}
%   Inductive tpos := 
%     | a (i:base)            
%     | impl (c:tneg) (b:tpos)   
%     | pi   (n:string) (b: tpos)
%     | conj (l:list tpos)       
%     | cut                      
%     | unif  (x:any) (y:any)    
%     | match (x:any) (y:any)    
%   with tneg :=
%     | hb  (h: base) (b: list tpos)
%     | piN (x: string) (b : tneg)  
%   with base :=
%     | c (c : pn) (l:list any)
%     | v (v : vn) (l:list any)
%   with any := 
%     | p (i:tpos) 
%     | n (i:tneg) 
%     | b (i:base) 
%     | s (i:string).
% \end{coqcode}

% NOTA: mi sembra sia più facile avere predicati di arità qualsiasi
In order to represent these two new constructs of the language,\todo{pred of arity N}
we add two new constructors to the inductive \coqIn{atom}: \todo{aggiungere lam-abstr?}
\begin{coqcode}
  | Impl (c:clause) (a:atom)
  | Pi (x:vn) (a:atom)
\end{coqcode}

\todo{a call can have a variable has functor}

The former constructor is noted with the syntax \implCmd{c}{a} and introduces
the clause \texttt{c}\todo{$c$ is mutual-excl check} locally in the scope of an atom \texttt{a}, by convention
this new inserted clause has the highest priority wrt the clauses existing in
the scope of \coqIn{a}. The \coqIn{pi} constructor is noted \piCmd{x}{a}
introduces the fresh variable nominal variable \coqIn{x} in \coqIn{a}.

A further modification to our language is the \coqIn{tm} type. Now, a term
consists not only of primitive data but also of atoms. %and clauses. 
Unlike
functional languages, logic programs do not mix commands and expressions; an
expression is not executable code, whereas a command, called a proposition, is.

TODO: dore che typechecking assicura che non ci siano di questi errori

In basic \elpi, predicates had expressions as parameters. In this new setting,
with the extension of \coqIn{tm}, a predicate can receive (or return) a command
as an argument -- a command that can be executed as a new piece of code.\todo{mettere esempio?}

% Moreover, from now on we consider that applied predicates are terms, therefore a
% predicate can be passed as argument of another predicate call. The type of a
% fully applied predicate is the type of propositions and is noted \elpiIn{prop}.
% This means that a clause can have the shape ``\elpiIn{apply X Y :- X Y}'': the\todo{The arity of X is 1, it is not a binary predicate}
% output of the predicate \elpiIn{apply} is deduced by calling \elpiIn{X} to
% \elpiIn{Y}. Moreover, \elpiIn{X} is a higher-order variable of type \elpiIn{A ->
% prop}.



\subsection{Interpreter}

To keep into account these two new constructs of the language,
we extend the interpreter. The new rules are depicted in \cref{fig:full-interp}

\begin{figure}
  \ruleImplM{.85}
  
  \rulePiM{.85}
  \caption{Higher-order derivation rules}
  \label{fig:full-interp}
\end{figure}

The notation $\clause + \prog$ stands for the insertion of the clause \clause in the program \prog so that \clause has
the highest priority in \prog. The rule \ruleImpl deals with the atom
\implCmd{H}{B} and its derivation rule tries to solve \elpiIn{B} under a
program \prog which has been expanded with the $H$ clause. The rule \rulePi
inserts the name of the fresh variable in the program. The \texttt{local}
predicate is a special unary predicate having as output the new inserted
universally quantified. The \unify and \match procedures use \texttt{local} to
make the \pf\ unification since this unification on higher-order variables works
on variables applied to a distinct list of local variables.

\subsection{Determinacy in higher-order context}

Since the parameters of predicates can be passed both as input and output to
predicate calls, we need to extend the syntax of signatures so that the user can instruct the
\elpi's compiler\todo{compiler vs interpreter in \elpi} about if an input (resp.
an output) should be considered as a deterministic proposition.

% \begin{elpicode}
%   pred divisor i:int, o:int.
%   pred help i:int, i:int, o:int.

%   divisor N R :- help N 1 R.
%   help N X X :- 0 is N mod X.
%   help N X R :- X < N, X' is X + 1, help N X' R. 

%   [(pi N R\ divisor N R :- help N 1 R),
%   (pi N X\ help N X X :- 0 is N mod X),
%   (pi N X R X'\ help N X R :- X < N, X' is X + 1, help N X' R)] => divisor 10 R. 
% \end{elpicode}

From now on let \elpiIn{divisor} be the predicate from \elpiIn{int} to
\elpiIn{int} taking an integer and returning its divisors, one by one in
increasing order.

Let \elpiIn{once} be a predicate with only one clause ``\elpiIn{once P (P, !)}''.
From this implementation, we see that the \elpiIn{once} predicate has
the following property: it takes a proposition and returns its deterministic
version, i.e. the output is the call to \elpiIn{P} where all of its choice
points have been cut away (note the presence of the \cut\ in the second argument). To be more concrete, the query
\elpiIn{once (divisor 5 X) P, P} will instantiate \elpiIn{X} only once
to \elpiIn{1} (note that the query \elpiIn{divisor 5 X}
has two solutions for \elpiIn{X}, namely \elpiIn{1} and \elpiIn{5}). Another
information about \elpiIn{once} is that it is a deterministic predicate, that
is, not only its output is a function but \elpiIn{once} itself is a function.

To provide the compiler all of these pieces of information about the predicate
\elpiIn{once}, the user should add a signature to the predicate.  
\Elpi's signatures are as follows:
GRAMMAR

TODO: dire che func sta per funzionale e rel sta per relazionale

So the signature of \elpiIn{once} will be: ``\elpiIn{func once i:pred, o:func}''
where \elpiIn{once} is a function, it takes a
relation and returns a function.

% Since predicate parameters can now be passed to other predicate calls, and since
% these calls may affect the determinacy of a predicate, we need to specialize
% our determinacy checker.
\begin{elpicode}
  func apply5 i:(func int -> int), o:int.
  apply5 F R :- F 5 R.
\end{elpicode}

Consider now, the \elpiIn{apply5} predicate depicted above. It is a function
that takes a function from \elpiIn{int} to \elpiIn{int} and returns the result of
applying that function to \elpiIn{5}. What happens if we
execute the query \elpiIn{apply
divisors X}? We see that its output is not deterministic: the assignment for
\elpiIn{X} is not deterministically determined -- there are, in fact, two
possible assignments: one where \elpiIn{X} is assigned to \elpiIn{1} and another
where it is assigned \elpiIn{5}.

RIUTILIZZARE CODICE!!

SEPARARE IL CHIAMARE GIUSTO UN PREDICATO (per riusare codice)

Another problem is showed by the followig code:
\begin{elpicode}
  func idF i:func, o:func.
  idF X X.
\end{elpicode}
  % func p i:(func int -> int), o:(pred i:int, o:int).
  % p X X :- X = divisors.

In the snippet, we define the identity function over functions.

With \elpi's dynamic mode system, the call ``\elpiIn{idF Y Y, Y = divisor 5
X, Y}'' succeeds because we can pass flexible terms in input positions. The problem
here is that, based on the signature of \elpiIn{idF}, its output is a function.
This allows us to assume that the variable \elpiIn{Y} is a function. However,
after the unification between \elpiIn{Y} and \elpiIn{divisor 5 X}, we lose that
property: calling \elpiIn{Y} produces several results for \elpiIn{X}.

DIRE CHE DIAMO L'ALGORITMO DI DETERMINACY CHECKING, PRIMA ATTRAVERSO ESEMPI E POI
RIASSIUMIAMO TUTTO

To address this issue, we could statically annotate terms with their determinacy
status in a way similar to the static mode checking for ground terms. Then,
when a unification is performed between two terms, a compilation error
could be raise if their determinacy tag mismatch.
In the example above, \elpiIn{Y = divisor} would be rejected since \elpiIn{Y}
would be annotated as a function and \elpiIn{divsor} is a relation.

% \newcommand{\detT}[1]{\text{\mlIn{~\PYG{n+nc}{#1}~}}}


The labels we need are defined with the following inductive:

\begin{coqcode}
  Inductive ~\detlab~ := Exp | Rel | Det | arr (i:detlab) (o:detlab).
\end{coqcode}

A term is either an expression (an non executable peice of code), a relational
or a deterministic predicate or finally an arrow (just like the arrow used for
the types of functions) between two \detlab. For the last constructor we
will use the notation $d_1 \myTo d_2$ where $d_1$ and $d_2$ are instances of\todo{i:detlab list if multiple args}
\detlab, moreover we consider $d_1$ to be an input and $d_2$ to be an output.
We are again considering binary relations. This can always be generalized to
functions (or relations) of any arity by slightly changing the signature of
the \coqIn{arr} constructor.

The problem of this first algorithm of determinacy check is that it does not
take into account a natural relation that exists between functions and
relations, i.e. a function is a relation such that all of the member in its
domain points to a unique value in its codomain. This means that a fuction can
be always passed in place of a relation. We define below the inclusion relation
between two \detlab.

\begin{coqcode}
  Fixpoint a ~\mySub~ b := match a, b with
  | Rel, Func -> false
  | Func, Rel | Rel, Rel | Func, Func | Exp, Exp -> true
  | a ~\myTo~ b, a' ~\myTo~ b' -> a' ~\mySub~ a && b ~\mySub~ b'
  end.
\end{coqcode}

The \mySub\ relation is intentionally non-complete since we suppose that before
performing any determinacy checking the program has been type-checked. This
means that it is never possible to have unification between, for example,
expressions and relations, this would lead to a fatal type-error.

The base cases of \mySub\ are quite intuitive: a relation is not a function. The
interesting case is the \coqIn{arr} constructor. Here, we are comparing two
propositions and therefore some attention should be paid for its inputs and
outputs: the inputs of the left memeber should be at least as restrictive as the
right one and the outputs of the left memeber are at most as restrictive as the
right one.

As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
\texttt{once}$. The determinacy of $t_1$ is $\detT{Func} \myTo \detT{Func}$ and
the determinacy of $t_2$ is $\detT{Rel} \myTo \detT{Func}$. We intuitively
remark that $\forall p_1\ p_2\ p_3, \texttt{once}\ p_1\ p_2 \to \texttt{idF}\
p_1\ p_3 \to p_2 \mySub p_3$. This is because the two predicates can be called
with a relation and the output of \texttt{idF} is still a relation whereas the
output of \texttt{once} is still a function, i.e. the determinacy type of
\texttt{once} is more constraining. Said in other words, $\detT{Rel} \myTo
\detT{Func} \mySub \detT{Func} \myTo \detT{Func}$.

What may seem weird at first sight is that in the example above, we call
\texttt{idF} with a relation in input position. This creates a mismatch
between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
However, we want our system to be as expressive as possible. This means that
we allows the user the wrongly call a predicate. In that particular case the dtype of the
outputs will not be guaranteed to have the expected determinacy: they will be labeled 
with the less restrictive determinacy for its type. To continue our example,
the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.

Thanks to the \mySub\ relation we can define a min (resp. max) relation between
two determinacy relations.

\begin{coqcode}
  Fixpoint min a b = match a, b with
    | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
    | a, b -> if a ~\mySub~ b then a else b
  end with max a b = match a, b with
    | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
    | a, b -> if a ~\mySub~ b then b else a
  end.
\end{coqcode}

These two functions become particularly useful
when trying to determine the determinacy of unification variables. Let's
take the following example.

\begin{elpicode}
  pred give_rel i:int, o:pred.
  func give_fun i:int, o:func.
  give_rel _ (divisors 5 X).
  give_rel _ (succ 1 X).
  give_fun _ (succ 1 X).
\end{elpicode}

In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
that take a dummy integer as input (we conventionally work with binary
predicates) and return, respectively, a relation and a function. 

Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
\elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
should they have? Unification succeeds if the two terms are unifiable, meaning
that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
therefore share the same \detlab. Their label will be updated and set to the
minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI. 

If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
want to statically determine if it create choice points. The determinacy of each
goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
that is \relI.

With this, we now have all the ingredients needed to propose the full static
determinacy checker for the higher-order setting. This checker is implemented in
\detCheck, which ensures that a deterministic predicate has at most one solution
per call. Furthermore, it is extended to certify that each output of a clause
has the expected determinacy, which is crucial since outputs can be used as new
queries in the program.

TODO: redifine \cref{def:det-prem}: we can have variables has props.


\begin{figure}
  \centering
  
  \ruleCheckClauseM{1}

  
  \ruleCheckCutM{.45}
  \ruleCheckEmptyM{.35}
  
  \ruleCheckPiM{.7}
  \ruleCheckImplM{.7}

  \ruleCheckUnifM{.7}

  % \ruleCheckMatchM{.7}
  \ruleCheckCallM{1}
  \ruleCheckCallFailM{1}
  
  \caption{Static check rules}
  \label{fig:static-check}
\end{figure}

$$-----$$

For instance, we would like that the call \elpiIn{idF divisors X} is valid for
determinacy, but, since the input has not the expected determinacy, then the
output will not be a deterministic predicate. Indeed, we propose the following
ordering relation between deterministic and relational predicates.

TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
invalidato

\subsection{Mode checking: input-ground mode}
\label{sec:mc}
Dire come funziona il mode checking e spiegare che è una condizione sufficiente
per avere la determinacy.

\subsection{Mutual exclusion for local clauses}
Polarity check: inner clauses when using the impl construct

Da spostare prima della sezione \cref{sec:mc}

\subsection{Determinacy polymorphism}

Il problema è ad esmepio la funzione identità

\begin{elpicode}
  pred id i:A, o:A.
\end{elpicode}

Se id viene chiamato con una deterministic-predicate, allora l'output sarà
anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
è passata tra due oggetti che hanno lo stesso tipo.

Per esempio:

\begin{elpicode}
  pred wrong_id i:A, o:A.
  wrong_id fun rel.
\end{elpicode}

Per l'identià si potrebbe definire versioni specializzate:

\begin{elpicode}
  pred id1 i:(func A -> A) (func A -> A).
  id1 X X.
\end{elpicode}

Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
polimorphismo di determinacy.
Qualcosa tipo:

\begin{elpicode}
  pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
\end{elpicode}

Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
la stessa funzionalità.