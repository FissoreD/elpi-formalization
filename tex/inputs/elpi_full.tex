\section{Prolog with higher-order variables in prop}
\label{sec:vars}

In order to fully capture the potential of a \lamprolog language like \elpi, we
need to delve deeper into the concept of variables. Until now, we have
intentionally avoided discussing them in detail. They were implicitly taken into
account in the \ref{rule:unif} and \ref{rule:match} rules, however, a query like
\elpiIn{p = X, X 1 3} was not accepted by the run procedure. The only
application we authorized was caputered by the \call\ constructor and was an
application of a predicate name to two terms. Here we want that this same
application works when a variable name applied to terms.

\begin{coqcode}
  | Call (hd : vn | tn) (t1:tm) (t2:tm)
\end{coqcode}

The notation $(h\ t_1\ t_2)$ is used to represent the \call\ constructor.

\begin{figure}
  \ruleCallBM{1}

  %   \vspace{-2em}
  % $$
  % \mathcal{F}'(\prog, h, i, o, \subst, \alt) := 
  %   [(\subst, (
  %       \Cons{(\prog, i = i', \alt)}
  %         \Cons{(\prog, o = o', \alt)}
  %           {[(\prog, g, \alt) \mid g \in bs]})) \mid \clauseCmd{(\subst h)}{i'\ o'}{bs} \in \prog\ (\subst h)]
  % $$
  %   \vspace{-2em}

  \caption{Dynamic semantics: update of \ref{rule:call}}
  \label{fig:new-call}
\end{figure}

To account for this change, rule \ref{rule:call} is modified to accommodate the
new application, as shown in \cref{fig:new-call}. The main difference from
\ref{rule:call} is that in \ref{rule:call1}, before invoking the function
$\mathcal{F}$, we first look up the value of $h$ in \subst. If $h$ is a
variable, this dereferencing operation may return a \lam-term, which, when
applied to $t_1$ and $t_2$, is $\beta$-reduced (thanks to the hereditary
substitution principle) to a canonical value in the form of a predicate name
applied to two terms.

This change significantly impacts our static determinacy checker: variables can
now be passed as predicate arguments and may have a propositional type, meaning
they can be called within clause bodies. However, additional properties can be
enforced by the checker. For instance, users may want to ensure that a
predicate's output is verified as a deterministic proposition.

We provide some examples to illustrate this point:

\begin{itemize}
  \item In a program with a predicate \elpiIn{once}, defined as \elpiIn{once P
          :- P, !}, we observe that \elpiIn{once} behaves deterministically
        regardless of the determinacy of its argument.
  \item In a program with a predicate \elpiIn{make-det}, defined as
        \elpiIn{make-det P (once P)}, we see that for any input proposition
        \elpiIn{P}, the output is deterministic.
  \item In a program with a predicate \elpiIn{do}, defined as
        \elpiIn{do P :- P}, we see that if \elpiIn{do} is called with a
        deterministic predicate, then \elpiIn{do} is deterministic.
  \item Finally, in a program with a predicate \elpiIn{idF}, defined as
        \elpiIn{idF A A}, we note that when \elpiIn{idF} is called with a
        deterministic input, its output remains deterministic.
\end{itemize}

To provide this information to the compiler we give the user the possibility to
provide expressive type signatures for constants. The grammar is
as follows:
%
\begin{align}
  ty   & ::= data \mid pred                                    \label{eq:ty}        \\
  data & ::= \texttt{c}\ data^\ast \mid data \to data \mid \predVar \label{eq:data} \\
  % pred & ::= \relI\ ty^\ast \mid \detI\ ty^\ast \funsep ty^\ast \label{eq:pred}
  pred & ::= [\detI \mid \relI]\ ty^\ast \funsep ty^\ast \label{eq:pred}
\end{align}

A type ($ty$) is a disjunction of the two sorts: on one sides we have the type
for expressions ($data$) and the type of executable piece of code ($pred$). The
nonterminal $data$ is for expressions, it is either the application of a type
constant to a list of data, a function ($\to$) or a variable. The nonterminal
$pred$ is the type of predicates. A predicate is relational (\relI) or
functional (\detI) and is followed by two lists of determinacy types separated by the
\funsep\ operator. On the left we have the type of the inputs and on the right
the type of the outputs. In the following a predicate with $0$ argument
will be note as \detI\ (resp. \relI) instead of $\detI\ []\ []$ (resp. $\relI\ []\ []$).

\textbf{TODO: dire che adesso il pi ha il type sul binder}\\
\textbf{TODO: typechecker: types to dtypes}

Thanks to this, we can define the signature of the predicates above:
%
% \begin{equation}  
\begin{align*}
  \texttt{once}     & : \dtype{\detI}{[\relI]}{[]}      & \texttt{do}  & : \dtype{\detI}{[\detI]}{[]}      \\
  \texttt{make-det} & : \dtype{\detI}{[\relI]}{[\detI]} & \texttt{idF} & : \dtype{\detI}{[\detI]}{[\detI]}
\end{align*}
% \label{eq:ty}
% \end{equation}

In the code abode we use brackets to delimit lists. The idea is that, thanks to
type signatures, the checker of elpi code ensure the a predicate is a function
when it should be and returns outputs with the right determinacy.

Thanks to this certification, for example, let \elpiIn{f} be a binary,
relational predicate, then the query ``\elpiIn{make-det (f 1 X) F, do F}'' is
deterministic. This is because \elpiIn{make-det} is deterministic, \elpiIn{F} is
deterministic and \elpiIn{do} behaves deterministically when it receives
functions as input.

The checker should also accepts predicates that are \textit{wrongly} called. For
example, \elpiIn{do (f 1 X)} should be accepted as a call, however, since the
argument of \elpiIn{do} has not the expected determinacy, we loose the guarantee
that the call behaves deterministically. Similarly, the query \elpiIn{idF (f 1 X)
  R} is \textit{wrongly} called and therefore we have no guarantee that \elpiIn{R} is
deterministic and that the whole call behaves deterministically. The choice to
accepts wrong calls allows to have \textit{code reusability}.

On the other hand, the signature of \elpiIn{make-det} should reject
\elpiIn{make-det A (once A) :- A}. Since we cannot guarantee that the whole rule
is a function: \elpiIn{A} could be a relation and calling it in the body may
create choice points.

To address all of these issues we implement a static checker labelling variables
with their determinacy. Labels are instances of $ty$ in \cref{eq:ty}, to
simplify our presentation, $data$s in \cref{eq:data} are represented with the
\expI\ tag.


% A term is either an expression (an non executable peice of code), a relational
% or a deterministic predicate or finally an arrow (just like the arrow used for
% the types of functions) between two \detlab. For the last constructor we
% will use the notation $d_1 \myTo d_2$ where $d_1$ and $d_2$ are instances of\todo{i:detlab list if multiple args}
% \detlab, moreover we consider $d_1$ to be an input and $d_2$ to be an output.
% We are again considering binary relations. This can always be generalized to
% functions (or relations) of any arity by slightly changing the signature of
% the \coqIn{arr} constructor.

% The problem of this first algorithm of determinacy check is that it does not
% take into account 
A natural property that exists between functions and relations is that a
function is a particular relation such that all of the members in its domain
points to at most a unique value in its codomain. This means that a fuction can
be always passed in place of a relation. We define below the partial ordering
relation between two determinacies.
\begin{equation}
  f_1 \mySub f_2 =
  \begin{cases}
    \bot                                                         & \text{if } f_1 = \relI\ \_\ \land f_2 = \detI\ \_    \\
    % (\forall i, a'_i \mySub a_i) \land (\forall j, b_j \mySub b'_j)      & \text{else if } f_1 = \detI\ a\ b \land f_2 = \detI\ a'\ b' \\
    % (\forall i, a'_i \mySub c_i) \land (\forall j, b_j \mySub c_{|a|+j}) & \text{else if } f_1 = \detI\ a\ b \land f_2 = \relI\ c      \\
    % \forall i, a_i \mySub b_i                                            & \text{else if } f_1 = \relI\ a\ \land f_2 = \relI\ b        \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{else if } f_1 = [\detI\mid \relI]\ a\ b \land f_2 = [\detI\mid \relI]\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \detI\ a\ b \land f_2 = \detI\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \detI\ a\ b \land f_2 = \relI\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    \top                                                          & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:sub-def}
\end{equation}
% \begin{coqcode}
%   Fixpoint a ~\mySub~ b := match a, b with
%   | Rel, Func -> false
%   | Func, Rel | Rel, Rel | Func, Func | Exp, Exp -> true
%   | a ~\myTo~ b, a' ~\myTo~ b' -> a' ~\mySub~ a && b ~\mySub~ b'
%   end.
% \end{coqcode}

\textbf{TODO: dire legame con subtyping}.\\
The \mySub\ relation is intentionally non-complete since we suppose that before
performing any determinacy checking the program has been type-checked. This
means that it is never possible to have unification between, for example,
datatypes and predicates, this would lead to a fatal type-error. Moreover, when
comparing predicates $p_1$ and $p_2$, we assume that ther input lists have same
lengths and that their output lists have same lengths: predicates with different
lists of input and output are not comparable.

The idea of \mySub\ is that a relation, by definition, is not a function, the
other combinations of functions and relations works if some conditions holds on
their inputs and outputs. In particular if we have $t_1 \mySub t_2$ then the
outputs of $t_1$ should be \mySub\ than the outputs $t_2$.
\textbf{TODO: fare un esempio.}

The converse property should hold for the inputs of two terms, that is, if
we have $t_1 \mySub t_2$ then the outputs of $t_2$ should be \mySub\ than the
outputs $t_1$. For example, let's consider the signatures of \elpiIn{make-det}
and \elpiIn{idF}. We intuitively remark that $\forall p_1\ p_2\ p_3,
  \texttt{make-det}\ p_1\ p_2 \to \texttt{idF}\ p_1\ p_3 \to p_2 \mySub p_3$.
Therefore, we can safely claim that $\detI\ [\relI] \funsep [\detI] \mySub
  \detI\ [\detI] \funsep [\detI]$. In a way, a predicate going from relations to
functions is less expressive than a predicate from functions to functions,
especially because the latter predicate can recieve relations as inputs.

\begin{lemma}[\mySub\ is a partial order]
  Ha sesnso farlo?
\end{lemma}

Two further relations can be defined to find the least common minimun (resp.
maximum) between two determinacies.
%
\begin{equation}
  \minT\ f_1 f_2 =
  \begin{cases}
    \detI\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d) & \text{if } f_k = \relI\ a\ b \land f_{2-k} = \detI\ c\ d \\
    D\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d)     & \text{if } f_1 = D\ a\ b \land f_2 = D\ c\ d             \\
    % \relI\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    \expI                                                                 & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:min}
\end{equation}
\begin{equation}
  \maxT\ f_1 f_2 =
  \begin{cases}
    \detI\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d) & \text{if } f_k = \relI\ a\ b \land f_{2-k} = \detI\ c\ d \\
    D\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d)     & \text{if } f_1 = D\ a\ b \land f_2 = D\ c\ d             \\
    % \relI\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    \expI                                                                 & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:max}
\end{equation}

% $$
%   \minT\ f_1\ f_2 = \begin{cases}
%     \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_1 \mySub f_2                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
% $$
% $$
%   \maxT\ f_1\ f_2 = \begin{cases}
%     \minT\ a'\ a \myTo \maxT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_2 \mySub f_1                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
% $$

The main usage of the \minT\ and \maxT\ comes with the fact that unification is
possibile between variable with different determinacy annotation. For example,
let \elpiIn{get-det} and \elpiIn{get-rel} be two relations returning
respectively a function and a relation (both with zero arguments). In a query like \elpiIn{get-det X,
  det-rel Y, X = Y} we have three goals to solve, the first allows to label
\elpiIn{X} with the tag \detI, the second allows to label \elpiIn{Y} with
the tag \relI. The third goal is interesting since we are unifying two\todo{not true if output are flex}
predicates with different determinacy labels. Now, the only way that this unificaton
succeeds at runtime is that \elpiIn{Y} is a function.
Said in another way, a unification may change the labels of the two terms being
unified. In the previous example, \detlab\ \elpiIn{X} $=$ \detlab\ \elpiIn{Y} $=$
\minT\ $($\detlab\ \elpiIn{X}$)$ $($\detlab\ \elpiIn{Y}$)$.



% $$---$$

% and therefore
% The base cases of \mySub\ are quite intuitive: a relation is not a function. The
% interesting case is the \coqIn{arr} constructor. Here, we are comparing two
% propositions and therefore some attention should be paid for its inputs and
% outputs: the inputs of the left memeber should be at least as restrictive as the
% right one and the outputs of the left memeber are at most as restrictive as the
% right one.

% As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
%   \texttt{once}$. 

% What may seem weird at first sight is that in the example above, we call
% \texttt{idF} with a relation in input position. This creates a mismatch
% between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
% However, we want our system to be as expressive as possible. This means that
% we allows the user the wrongly call a predicate. In that particular case the dtype of the
% outputs will not be guaranteed to have the expected determinacy: they will be labeled
% with the less restrictive determinacy for its type. To continue our example,
% the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
% tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.

% Thanks to the \mySub\ relation we can define a min (resp. max) relation between
% two determinacy relations.


% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}

% These two functions become particularly useful
% when trying to determine the determinacy of unification variables. Let's
% take the following example.

% \begin{elpicode}
%   pred give_rel i:int, o:pred.
%   func give_fun i:int, o:func.
%   give_rel _ (divisors 5 X).
%   give_rel _ (succ 1 X).
%   give_fun _ (succ 1 X).
% \end{elpicode}

% In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
% that take a dummy integer as input (we conventionally work with binary
% predicates) and return, respectively, a relation and a function.

% Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
% The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
% \elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
% should they have? Unification succeeds if the two terms are unifiable, meaning
% that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
% therefore share the same \detlab. Their label will be updated and set to the
% minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI.

% If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
% want to statically determine if it create choice points. The determinacy of each
% goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
% that is \relI.

% With this, we now have all the ingredients needed to propose the full static
% determinacy checker for the higher-order setting. This checker is implemented in
% \detCheck, which ensures that a deterministic predicate has at most one solution
% per call. Furthermore, it is extended to certify that each output of a clause
% has the expected determinacy, which is crucial since outputs can be used as new
% queries in the program.

\subsection{Determinacy checker for terms and subtyping}

\begin{figure}
  \fbox{\inferFig}
  \fbox{\assumeFig}
  \fbox{\checkTermFig}
  \caption{Determinacy checking for terms}
  \label{fig:full-det-check-terms}
\end{figure}

% \textbf{TODO: dire che si parla di termini che devono essere valutati, cioè di oggetti con tipo prop}

From the \mySub, \minT\ and \maxT\ relations, we can deduce a system of rules
allowing to \infer\ (\cref{fig:det-inference}) the dtype of a term, to \assume\
\cref{fig:det-assume}
the dtype of a term, that is, update a given mapping such that the wanted
quantified variable has a given determinacy, to \checkk\
(\cref{fig:static-check}) a propositional term. 

% This check relation is not
% far from a subtyping checker where the subtyping relation is \mySub. The checker
% is made by the three systems of rules shown in \cref{fig:full-det-check-terms}.
We let \ctx\ to be a context which is a mapping from variable names to their
dtype. Each variable \predVar\ appearing in a term $t$ has a
dtype in \ctx\ since either \predVar\ is the name of a predicate and its dtype
can be retrieved from its signature, or \predVar\ is a quantified variable and
its dtype is derived from the type inferred by the type checker. In the latter
case, the typechecker infers the wrost determinacy from the type, i.e. if
\predVar\ should be a predicate from int to int, then \predVar\ is considered as
relational, i.e. the typechecker has no way to statically guarantee it behaves
as a function. Moreover, even though, in the end \predVar\ happens to be a
function, by definition we know that a function can always be used in place of a
relation.

The \infer\ procedure takes a context \ctx and a term $t$ and returns the dtype of
$t$ and a boolean. The bollean tells if the term is well dtyped, the only interesting
case for it is \ref{rule:infer-app}.

In particular, rule \ref{rule:infer-hd} handles variables or predicate names by
retrieving their determinacy from the context.  
Rules \ref{rule:infer-cut} and \ref{rule:infer-unif} are straightforward: both
the \cut\ operation and unification are considered deterministic predicates.  
Rule \ref{rule:infer-piimpl} handles the \coqIn{PiImpl} constructor by extending
\ctx\ with a mapping from the local variable $x$ to its dtype.  
Finally, rule \ref{rule:infer-app} addresses term applications. It returns if
the application stands for a call to a deterministic or relational predicate.
Together with this piece of information we have the boolean which tests if the
deduced type of the input has a determinacy less or equal to the expected one.

The boolean is particularly useful since it allows to detect wrong calls to
predicates.

\textbf{EXAMPLE: for \infer}

The \assume\ procedure aims to update a context so that a term $t$ has an
expected determinacy \func. Rule \ref{rule:assume-hd} deals with quantified
variables \predVar. It updates its dtype in \ctx\ is updated to \func. In
\ref{rule:assume-hdP}, we consider terms that are predicate names. Their
determinacy should be less or equal than the one received in entry. Rules
\ref{rule:assume-cut} and \ref{rule:assume-unif} does not change the context,
both the \cut and the $=$ operators are deterministic terms and $\forall d,
\detI \mySub d$. Rule \ref{rule:assume-piimpl} goes under the implication with a
recursive call charging in the context the local binder $x$. This same binder is
removed from the result in the output. Finally the rule for term application
\ref{rule:assume-app} tries to assume that the application has a determinacy
\func. This is possible only if the determinacy of the head term is less or
equal than the given one. If it is the case, \assume is called recursibely on
the inputs, giving the new the output.

\textbf{EXAMPLE: for \assume}

The \checkk\ procedure combines both \infer\ and \assume. The goal is to check
that if we execute a terms, given a context \ctx and a entry determinacy \func\,
the execution produces a new context \ctx['] updating simulatneously the
determinacy of the term. 

For example see \ref{rule:check-cut}, if the term we have to execute is a \cut,
then we know that no matter what is the entry determinacy, we know that in the
and we have a deterministic behavior (\detI). The context is never touched.

Rule \ref{rule:check-piimpl} behaves similarly to \ref{rule:assume-piimpl}. It
also makes some check on the hypothesis $H$. But we delay it to the next
section.

If the term is a unification the determinacy \func\ is transmitted from the
input to the output. What may change is the context, since, during unification
some variables may be assigned. In \ref{rule:check-unif} we are in the case
where it is possible to successfully deduce the dtype of the left and the right
terms of the equality operator. At runitime, unification succeeds if the two
terms are unifiable. This means that in the end the two terms will share the
same determinacy. The determinacy the will have is the minimum between the
determinacy of the two terms. Imagine that we are unifying a function with a
relation, then the more restrictive condition for both terms should be taken
into account. Therefore, the \assume\ procedure is called on both terms so that
their determinacy is set to the minimum. If on the contrary, it is not possible
to \infer\ a valid dtype for at least one of the two terms (rule
\ref{rule:check-unifFail}), we cannot deduce much more on the variables in the
two terms, therefore, we do nothing on the context \ctx, which is returned as it
was in input.

The \checkk\ rule for application (see \ref{rule:check-callOK}) starts by
deducing the type of the input term. If its dtype \func[_i'] can be derived
(i.e. the booleans is $\top$) and if \func[_i'] is less or equal than the
expected one in the signature, then the output can be assumed to be the one
inscribed the signature. If these two conditions are not validated, then the
rule context is not modified. Concerning determinacy, if the call is valid, then
the determinacy is the \maxT\ between the one received in entry and the
determinacy of the head of the application. If, otherwise, the call is wrong,
then the output determinacy is set to relational.

\textbf{TODO: make an example}

\subsection{Determinacy checking for clauses}

\staticCheckFig


Know that we know how terms can be deduced, inferred, or checker for
determinacy, we can illustrate how a clause be checked so that it respects the
signature of the predicate being implemented. In \cref{fig:static-check} we
present our last derivation system. In a clase, we consider inputs as terms that
are assumed to respect the determinacy of the signature. Therefore in
\ref{rule:check-clause}, we start by making this assumption. From the new
obtained context we call the \checkL\ rule which is essentially an iterator over
the list of terms in the body of the clause. At each iteration \checkL\ calls
\checkk\ until reaching the end of the list. \checkL\ is called with a
determinacy which, in the beginning, is set to \detI. While reading the premises
of the clause, if one of them is relation, thanks to \checkk\ the determinacy
will be set to \relI. The result of the call to \checkL\ is used to verify that
the dtype of the ouput is less or equal to the expected value: this is what our
static checker aims to ensure. Finally the checker ensures that the whole
determinacy of the clause, i.e. the determinacy of the premises match the
expectation in the signature.

We provide an example of this checker in the following database.

\begin{elpicode}
give-fun X (succ X Y).
give-fun X (pred X Y).
good :- give-fun 3 Res, !, Res.
\end{elpicode}

The signatures of the predicates in the snippet above are the following:
%
\begin{align*}
  \texttt{succ} &: \dtype{\detI}{\expI}{\expI} & \texttt{pred} &: \dtype{\detI}{\expI}{\expI} \\
  \texttt{give-fun} &: \dtype{\relI}{[\expI]}{[\detI]} & \texttt{good} &: \detI
\end{align*}

The static checker for determinacy starts by analysing the first rule for
\texttt{give-fun}. The input is an expression, the body is empty, so in the end
we only have to check that the output has the output and the body have the right
determinacy. Now, the determinacy of the body is $\detI \mySub \relI$, the
determinacy (deduced) for the ouput term is $\detI \mySub \detI$. Therefore the
rule respect the contract of the signature: the rule is valid. A very similar
reasonment can be do on the second rule for \texttt{give-fun}. It is now more
interesting to analyze the clause for \texttt{good}. We have no input, thereofre
we keep analyze the body. The context on which \checkL\ is launched is $\ctx =
\{\text{\elpiIn{Res}}\mapsto \relI\}$ since in the wrost case the determinacy of
a term with type \texttt{prop} is \relI. The iteration on the terms in the body
starts by analysing ``\elpiIn{give-fun 3 Res}'' which makes the determinacy of
the term relational and sets updates the context to
$\{\text{\elpiIn{Res}}\mapsto \detI\}$, since it is a correct call and its
output is \assume d to have the functionality of the output in the dype of
\elpiIn{give-fun}. The \cut\ operator, makes \func\ to become \detI: intuitively
the \cut discards all choice points, that's way \ref{rule:check-cut} puts the
determinacy to \detI. Finally we execute a term which, by
\ref{rule:check-callOK} is deterministic. We conclude the execution of \checkL\
with $\func = \detI$ and $\ctx = \{\text{\elpiIn{Res}}\mapsto \detI\}$. This is
exactly what the signature of \texttt{good} expects and therefore the rule
passes the check.

% $$-----$$

% For instance, we would like that the call \elpiIn{idF divisors X} is valid for
% determinacy, but, since the input has not the expected determinacy, then the
% output will not be a deterministic predicate. Indeed, we propose the following
% ordering relation between deterministic and relational predicates.

% TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

% Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
% invalidato

\subsection{Mode checking: input-ground mode}
\label{sec:mc}

The last but not least important point to treat in the 

\subsection{Mix data with ty}

\begin{align}
  data & ::= \texttt{c}\ ty^\ast \mid data \to data \mid \predVar \label{eq:data1}
\end{align}

\subsection{Determinacy polymorphism}

Il problema è ad esmepio la funzione identità

\begin{elpicode}
  pred id i:A, o:A.
\end{elpicode}

Se id viene chiamato con una deterministic-predicate, allora l'output sarà
anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
è passata tra due oggetti che hanno lo stesso tipo.

Per esempio:

\begin{elpicode}
  pred wrong_id i:A, o:A.
  wrong_id fun rel.
\end{elpicode}

Per l'identià si potrebbe definire versioni specializzate:

\begin{elpicode}
  pred id1 i:(func A -> A) (func A -> A).
  id1 X X.
\end{elpicode}

Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
polimorphismo di determinacy.
Qualcosa tipo:

\begin{elpicode}
  pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
\end{elpicode}

Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
la stessa funzionalità.