\section{Prolog with higher-order variables in prop}
\label{sec:vars}

In order to fully capture the potential of a \lamprolog language like \elpi, we
need to delve deeper into the concept of variables. Until now, we have
intentionally avoided discussing them in detail. They were implicitly taken into
account in the \ref{rule:unif} and \ref{rule:match} rules, however, a query like
\elpiIn{p = X, X 1 3} was not accepted by the run procedure. The only
application we authorized was caputered by the \call\ constructor and was an
application of a predicate name to two terms. Here we want that this same
application works when a variable name applied to terms.

\begin{coqcode}
  | Call (hd : vn | tn) (t1:tm) (t2:tm)
\end{coqcode}

The notation $(h\ t_1\ t_2)$ is used to represent the \call\ constructor.

\begin{figure}
  \ruleCallBM{1}

  %   \vspace{-2em}
  % $$
  % \mathcal{F}'(\prog, h, i, o, \subst, \alt) := 
  %   [(\subst, (
  %       \Cons{(\prog, i = i', \alt)}
  %         \Cons{(\prog, o = o', \alt)}
  %           {[(\prog, g, \alt) \mid g \in bs]})) \mid \clauseCmd{(\subst h)}{i'\ o'}{bs} \in \prog\ (\subst h)]
  % $$
  %   \vspace{-2em}

  \caption{Dynamic semantics: update of \ref{rule:call}}
  \label{fig:new-call}
\end{figure}

To account for this change, rule \ref{rule:call} is modified to accommodate the
new application, as shown in \cref{fig:new-call}. The main difference from
\ref{rule:call} is that in \ref{rule:call1}, before invoking the function
$\mathcal{F}$, we first look up the value of $h$ in \subst. If $h$ is a
variable, this dereferencing operation may return a \lam-term, which, when
applied to $t_1$ and $t_2$, is $\beta$-reduced (thanks to the hereditary
substitution principle) to a canonical value in the form of a predicate name
applied to two terms.

This change significantly impacts our static determinacy checker: variables can
now be passed as predicate arguments and may have a propositional type, meaning
they can be called within clause bodies. However, additional properties can be
enforced by the checker. For instance, users may want to ensure that a
predicate's output is verified as a deterministic proposition.

We provide some examples to illustrate this point:

\begin{itemize}
  \item In a program with a predicate \elpiIn{once}, defined as \elpiIn{once P
          :- P, !}, we observe that \elpiIn{once} behaves deterministically
        regardless of the determinacy of its argument.
  \item In a program with a predicate \elpiIn{make-det}, defined as
        \elpiIn{make-det P (once P)}, we see that for any input proposition
        \elpiIn{P}, the output is deterministic.
  \item In a program with a predicate \elpiIn{do}, defined as
        \elpiIn{do P :- P}, we see that if \elpiIn{do} is called with a
        deterministic predicate, then \elpiIn{do} is deterministic.
  \item Finally, in a program with a predicate \elpiIn{idF}, defined as
        \elpiIn{idF A A}, we note that when \elpiIn{idF} is called with a
        deterministic input, its output remains deterministic.
\end{itemize}

To provide this information to the compiler we give the user the possibility to
provide expressive type signatures for constants. The grammar is
as follows:
%
\begin{align}
  ty   & ::= data \mid pred                                    \label{eq:ty}          \\
  data & ::= \texttt{c}\ data^\ast \mid data \to data \mid \texttt{v} \label{eq:data} \\
  % pred & ::= \relI\ ty^\ast \mid \detI\ ty^\ast \funsep ty^\ast \label{eq:pred}
  pred & ::= [\detI \mid \relI]\ ty^\ast \funsep ty^\ast \label{eq:pred}
\end{align}

A type ($ty$) is a disjunction of the two sorts: on one sides we have the type
for expressions ($data$) and the type of executable piece of code ($pred$). The
nonterminal $data$ is for expressions, it is either the application of a type
constant to a list of data, a function ($\to$) or a variable. The nonterminal
$pred$ is the type of predicates. A predicate is relational (\relI) or
functional (\detI). A relation is followed by the types of the arguments of the
predicate being defined. A function has two list of types separated by the
\funsep\ operator. On the left we have the type of the inputs and on the right
the type of the outputs.

Thanks to this, we can define the signature of the predicates above:
%
% \begin{equation}  
\begin{align*}
  \texttt{once}     & : \detI\ [\relI] \funsep []      & \texttt{do}  & : \detI\ [\detI] \funsep []      \\
  \texttt{make-det} & : \detI\ [\relI] \funsep [\detI] & \texttt{idF} & : \detI\ [\detI] \funsep [\detI]
\end{align*}
% \label{eq:ty}
% \end{equation}

In the code abode we use brackets to delimit lists. The idea is that, thanks to
type signatures, the checker of elpi code ensure the a predicate is a function
when it should be and returns outputs with the right determinacy.

Thanks to this certification, for example, let \elpiIn{f} be a binary,
relational predicate, then the query ``\elpiIn{make-det (f 1 X) F, do F}'' is
deterministic. This is because \elpiIn{make-det} is deterministic, \elpiIn{F} is
deterministic and \elpiIn{do} behaves deterministically when it receives
functions as input.

The checker should also accepts predicates that are \textit{wrongly} called. For
example, \elpiIn{do (f 1 X)} should be accepted as a call, however, since the
argument of \elpiIn{do} has not the expected determinacy, we loose the guarantee
that the call behaves deterministically. Similarly, the query \elpiIn{idF (f 1 X)
  R} is \textit{wrongly} called and therefore we have no guarantee that \elpiIn{R} is
deterministic and that the whole call behaves deterministically. The choice to
accepts wrong calls allows to have \textit{code reusability}.

On the other hand, the signature of \elpiIn{make-det} should reject
\elpiIn{make-det A (once A) :- A}. Since we cannot guarantee that the whole rule
is a function: \elpiIn{A} could be a relation and calling it in the body may
create choice points.

To address all of these issues we implement a static checker labelling variables
with their determinacy. Labels are instances of $ty$ in \cref{eq:ty}, to
simplify our presentation, $data$s in \cref{eq:data} are represented with the
\expI\ tag.


% A term is either an expression (an non executable peice of code), a relational
% or a deterministic predicate or finally an arrow (just like the arrow used for
% the types of functions) between two \detlab. For the last constructor we
% will use the notation $d_1 \myTo d_2$ where $d_1$ and $d_2$ are instances of\todo{i:detlab list if multiple args}
% \detlab, moreover we consider $d_1$ to be an input and $d_2$ to be an output.
% We are again considering binary relations. This can always be generalized to
% functions (or relations) of any arity by slightly changing the signature of
% the \coqIn{arr} constructor.

% The problem of this first algorithm of determinacy check is that it does not
% take into account 
A natural property that exists between functions and relations is that a
function is a particular relation such that all of the members in its domain
points to at most a unique value in its codomain. This means that a fuction can
be always passed in place of a relation. We define below the partial ordering
relation between two determinacies.
\begin{equation}
  f_1 \mySub f_2 =
  \begin{cases}
    false                                                         & \text{if } f_1 = \relI\ \_\ \land f_2 = \detI\ \_         \\
    % (\forall i, a'_i \mySub a_i) \land (\forall j, b_j \mySub b'_j)      & \text{else if } f_1 = \detI\ a\ b \land f_2 = \detI\ a'\ b' \\
    % (\forall i, a'_i \mySub c_i) \land (\forall j, b_j \mySub c_{|a|+j}) & \text{else if } f_1 = \detI\ a\ b \land f_2 = \relI\ c      \\
    % \forall i, a_i \mySub b_i                                            & \text{else if } f_1 = \relI\ a\ \land f_2 = \relI\ b        \\
    % (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{else if } f_1 = [\detI\mid \relI]\ a\ b \land f_2 = [\detI\mid \relI]\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \detI\ a\ b \land f_2 = \detI\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \detI\ a\ b \land f_2 = \relI\ c\ d \\
    (\forall i, c_i \mySub a_i) \land (\forall j, b_j \mySub d_j) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    true                                                          & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:sub-def}
\end{equation}
% \begin{coqcode}
%   Fixpoint a ~\mySub~ b := match a, b with
%   | Rel, Func -> false
%   | Func, Rel | Rel, Rel | Func, Func | Exp, Exp -> true
%   | a ~\myTo~ b, a' ~\myTo~ b' -> a' ~\mySub~ a && b ~\mySub~ b'
%   end.
% \end{coqcode}

The \mySub\ relation is intentionally non-complete since we suppose that before
performing any determinacy checking the program has been type-checked. This
means that it is never possible to have unification between, for example,
datatypes and predicates, this would lead to a fatal type-error. Moreover, when
comparing predicates $p_1$ and $p_2$, we assume that ther input lists have same
lengths and that their output lists have same lengths: predicates with different
lists of input and output are not comparable.

The idea of \mySub\ is that a relation, by definition, is not a function, the
other combinations of functions and relations works if some conditions holds on
their inputs and outputs. In particular if we have $t_1 \mySub t_2$ then the
outputs of $t_1$ should be \mySub\ than the outputs $t_2$.
TODO: fare un esempio.

The converse property should hold for the inputs of two terms, that is, if we if
we have $t_1 \mySub t_2$ then the outputs of $t_2$ should be \mySub\ than the
outputs $t_1$. For example, let's consider the signatures of \elpiIn{make-det}
and \elpiIn{idF}. We intuitively remark that $\forall p_1\ p_2\ p_3,
\texttt{make-det}\ p_1\ p_2 \to \texttt{idF}\ p_1\ p_3 \to p_2 \mySub p_3$.
Therefore, we can safely claim that $\detI\ [\relI] \funsep [\detI] \mySub
\detI\ [\detI] \funsep [\detI]$. In a way, a predicate going from relations to
functions is less expressive than a predicate from functions to functions,
especially because the latter predicate can recieve relations as inputs.

\begin{lemma}[\mySub\ is a partial order]
  Ha sesnso farlo?
\end{lemma}

Two further relations can be defined to find the least common minimun (resp.
maximum) between two determinacies.

\begin{equation}
  \minT\ f_1 f_2 =
  \begin{cases}
    \detI\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d) & \text{if } f_k = \relI\ a\ b \land f_{2-k} = \detI\ c\ d \\
    \detI\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d) & \text{if } f_1 = \detI\ a\ b \land f_2 = \detI\ c\ d \\
    \relI\ (\overrightarrow{\maxT}\ a\ c)\ (\overrightarrow{\minT}\ b\ d) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    \expI                                                          & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:min}
\end{equation}
\begin{equation}
  \maxT\ f_1 f_2 =
  \begin{cases}
    \detI\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d) & \text{if } f_k = \relI\ a\ b \land f_{2-k} = \detI\ c\ d \\
    \detI\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d) & \text{if } f_1 = \detI\ a\ b \land f_2 = \detI\ c\ d \\
    \relI\ (\overrightarrow{\minT}\ a\ c)\ (\overrightarrow{\maxT}\ b\ d) & \text{if } f_1 = \relI\ a\ b \land f_2 = \relI\ c\ d \\
    \expI                                                          & \text{if } f_1 = \expI \land f_2 = \expI
  \end{cases}
  \label{eq:max}
\end{equation}

% $$
%   \minT\ f_1\ f_2 = \begin{cases}
%     \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_1 \mySub f_2                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
% $$
% $$
%   \maxT\ f_1\ f_2 = \begin{cases}
%     \minT\ a'\ a \myTo \maxT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
%     f_1                             & \text{else if } f_2 \mySub f_1                     \\
%     f_2                             & \text{otherwise}
%   \end{cases}
% $$

The main usage of the \minT\ and \maxT\ comes with the fact that unification is
possibile between variable with different determinacy annotation. For example,
let \elpiIn{get-det} and \elpiIn{get-rel} be two relations returning
respectively a function and a relation. In a query like \elpiIn{get-det X,
det-rel Y, X = Y} we have three goals to solve, the first allows to label
\elpiIn{X} with the tag \detI, the second allows to label \elpiIn{Y} with 
the tag \relI. The third label is interesting since we are unifying two\todo{not true if output are flex}
predicate with different determinacy labels. Now, if we want unification to
succeed, we need that ,\elpiIn{Y} is a particular relation, that is a function.
Said in another way, a unification may change the labels of the two terms being
unified. In the previous example, \detlab\ \elpiIn{X} $=$ \detlab\ \elpiIn{Y} $=$
\minT\ $($\detlab\ \elpiIn{X}$)$ $($\detlab\ \elpiIn{Y}$)$.



% $$---$$

% and therefore
% The base cases of \mySub\ are quite intuitive: a relation is not a function. The
% interesting case is the \coqIn{arr} constructor. Here, we are comparing two
% propositions and therefore some attention should be paid for its inputs and
% outputs: the inputs of the left memeber should be at least as restrictive as the
% right one and the outputs of the left memeber are at most as restrictive as the
% right one.

% As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
%   \texttt{once}$. 

% What may seem weird at first sight is that in the example above, we call
% \texttt{idF} with a relation in input position. This creates a mismatch
% between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
% However, we want our system to be as expressive as possible. This means that
% we allows the user the wrongly call a predicate. In that particular case the dtype of the
% outputs will not be guaranteed to have the expected determinacy: they will be labeled
% with the less restrictive determinacy for its type. To continue our example,
% the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
% tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.

% Thanks to the \mySub\ relation we can define a min (resp. max) relation between
% two determinacy relations.


% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}

% These two functions become particularly useful
% when trying to determine the determinacy of unification variables. Let's
% take the following example.

% \begin{elpicode}
%   pred give_rel i:int, o:pred.
%   func give_fun i:int, o:func.
%   give_rel _ (divisors 5 X).
%   give_rel _ (succ 1 X).
%   give_fun _ (succ 1 X).
% \end{elpicode}

% In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
% that take a dummy integer as input (we conventionally work with binary
% predicates) and return, respectively, a relation and a function.

% Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
% The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
% \elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
% should they have? Unification succeeds if the two terms are unifiable, meaning
% that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
% therefore share the same \detlab. Their label will be updated and set to the
% minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI.

% If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
% want to statically determine if it create choice points. The determinacy of each
% goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
% that is \relI.

% With this, we now have all the ingredients needed to propose the full static
% determinacy checker for the higher-order setting. This checker is implemented in
% \detCheck, which ensures that a deterministic predicate has at most one solution
% per call. Furthermore, it is extended to certify that each output of a clause
% has the expected determinacy, which is crucial since outputs can be used as new
% queries in the program.

\begin{figure}
  \centering

  \ruleCheckClauseM{1}


  \ruleCheckCutM{.45}
  \ruleCheckEmptyM{.35}

  \ruleCheckPiM{.7}
  \ruleCheckImplM{.7}

  \ruleCheckUnifM{.7}

  % \ruleCheckMatchM{.7}
  \ruleCheckCallM{1}
  \ruleCheckCallFailM{1}

  \caption{Static check rules}
  \label{fig:static-check}
\end{figure}

% $$-----$$

% For instance, we would like that the call \elpiIn{idF divisors X} is valid for
% determinacy, but, since the input has not the expected determinacy, then the
% output will not be a deterministic predicate. Indeed, we propose the following
% ordering relation between deterministic and relational predicates.

% TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

% Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
% invalidato

\subsection{Mode checking: input-ground mode}
\label{sec:mc}
Dire come funziona il mode checking e spiegare che è una condizione sufficiente
per avere la determinacy.

\subsection{Mutual exclusion for local clauses}
Polarity check: inner clauses when using the impl construct

Da spostare prima della sezione \cref{sec:mc}

\subsection{Mix data with ty}

\begin{align}
  data & ::= \texttt{c}\ ty^\ast \mid data \to data \mid \texttt{v} \label{eq:data1}
\end{align}

\subsection{Determinacy polymorphism}

Il problema è ad esmepio la funzione identità

\begin{elpicode}
  pred id i:A, o:A.
\end{elpicode}

Se id viene chiamato con una deterministic-predicate, allora l'output sarà
anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
è passata tra due oggetti che hanno lo stesso tipo.

Per esempio:

\begin{elpicode}
  pred wrong_id i:A, o:A.
  wrong_id fun rel.
\end{elpicode}

Per l'identià si potrebbe definire versioni specializzate:

\begin{elpicode}
  pred id1 i:(func A -> A) (func A -> A).
  id1 X X.
\end{elpicode}

Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
polimorphismo di determinacy.
Qualcosa tipo:

\begin{elpicode}
  pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
\end{elpicode}

Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
la stessa funzionalità.