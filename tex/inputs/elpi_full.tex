\section{Prolog with higher-order variables in prop}
\label{sec:vars}

In order to fully capture the potential of a \lamprolog language like \elpi, we
need to delve deeper into the concept of variables. Until now, we have
intentionally avoided discussing them in detail. They were implicitly taken into
account in the \ref{rule:unif} and \ref{rule:match} rules, however, a query like
\elpiIn{p = X, X 1 3} was not accepted by the run procedure. The only
application we authorized was caputered by the \call\ constructor and was an
application of a predicate name to two terms. Here we want that this same
application works when a variable name applied to terms.

\begin{coqcode}
  | Call (hd : vn | tn) (t1:tm) (t2:tm)
\end{coqcode}

The notation $(h\ t_1\ t_2)$ is used to represent the \call\ constructor.

\begin{figure}
  \ruleCallBM{1}

  %   \vspace{-2em}
  % $$
  % \mathcal{F}'(\prog, h, i, o, \subst, \alt) := 
  %   [(\subst, (
  %       \Cons{(\prog, i = i', \alt)}
  %         \Cons{(\prog, o = o', \alt)}
  %           {[(\prog, g, \alt) \mid g \in bs]})) \mid \clauseCmd{(\subst h)}{i'\ o'}{bs} \in \prog\ (\subst h)]
  % $$
  %   \vspace{-2em}

  \caption{Dynamic semantics: update of \ref{rule:call}}
  \label{fig:new-call}
\end{figure}

To account for this change, rule \ref{rule:call} is modified to accommodate the
new application, as shown in \cref{fig:new-call}. The main difference from
\ref{rule:call} is that in \ref{rule:call1}, before invoking the function
$\mathcal{F}$, we first look up the value of $h$ in \subst. If $h$ is a
variable, this dereferencing operation may return a \lam-term, which, when
applied to $t_1$ and $t_2$, is $\beta$-reduced (thanks to the hereditary
substitution principle) to a canonical value in the form of a predicate name
applied to two terms.

This change significantly impacts our static determinacy checker: variables can
now be passed as predicate arguments and may have a propositional type, meaning
they can be called within clause bodies. However, additional properties can be
enforced by the checker. For instance, users may want to ensure that a
predicate's output is verified as a deterministic proposition.

We provide some examples to illustrate this point:

\begin{itemize}
  \item In a program with a predicate \elpiIn{once}, defined as \elpiIn{once P
        :- P, !}, we observe that \elpiIn{once} behaves deterministically
        regardless of the determinacy of its argument.
  \item In a program with a predicate \elpiIn{give-once}, defined as
        \elpiIn{give-once P (once P)}, we see that for any input proposition
        \elpiIn{P}, the output is deterministic.
  \item Finally, in a program with a predicate \elpiIn{idF}, defined as
        \elpiIn{idF A A}, we note that when \elpiIn{idF} is called with a
        deterministic input, its output remains deterministic.
\end{itemize}

To provide this information to the compiler we give the user the possibility to
provide expressive type signatures for constants. The grammar is
as follows: 
%
\begin{align*}
  ty & ::= data \mid pred\\
  data & ::= \texttt{c}\ data^\ast \mid data \to data \mid \texttt{v}\\
  pred & ::= \relI\ ty^\ast \mid \detI\ ty^\ast \funsep ty^\ast
\end{align*}

A type ($ty$) is a disjunction of the two sorts: on one sides we have the type
for expressions ($data$) and the type of executable piece of code ($pred$).
The nonterminal $data$ represents the 

The entry point is $sg$ which declares a predicate name \texttt{pn} which can be
either a relational (\relI) or a deterministic (\detI) predicate. A predicate is
followed by a list (also empty) of arguments ($ag$) that are marked as input
(\texttt{i:}) or output (\texttt{o:}) and are followed by the type ($ty$) of the
argument. The type is either a base type (\texttt{bt}) which is a sort or an
anonymnous predicate (\texttt{ap}). An anonymnous is defined as the nonterminal
symbol $sg$ without the name predicate \texttt{pn}.

Thanks to this, we can define the signature of the three predicate 
\elpiIn{once}, \elpiIn{give-once}, and \elpiIn{idF} can be phrased as follows:

% \begin{elpicode}
%   pred divisor i:int, o:int.
%   pred help i:int, i:int, o:int.

%   divisor N R :- help N 1 R.
%   help N X X :- 0 is N mod X.
%   help N X R :- X < N, X' is X + 1, help N X' R. 

%   [(pi N R\ divisor N R :- help N 1 R),
%   (pi N X\ help N X X :- 0 is N mod X),
%   (pi N X R X'\ help N X R :- X < N, X' is X + 1, help N X' R)] => divisor 10 R. 
% \end{elpicode}

From now on let \elpiIn{divisor} be the predicate from \elpiIn{int} to
\elpiIn{int} taking an integer and returning its divisors, one by one in
increasing order.

Let \elpiIn{once} be a predicate with only one clause ``\elpiIn{once P (P, !)}''.
From this implementation, we see that the \elpiIn{once} predicate has
the following property: it takes a proposition and returns its deterministic
version, i.e. the output is the call to \elpiIn{P} where all of its choice
points have been cut away (note the presence of the \cut\ in the second argument). To be more concrete, the query
\elpiIn{once (divisor 5 X) P, P} will instantiate \elpiIn{X} only once
to \elpiIn{1} (note that the query \elpiIn{divisor 5 X}
has two solutions for \elpiIn{X}, namely \elpiIn{1} and \elpiIn{5}). Another
information about \elpiIn{once} is that it is a deterministic predicate, that
is, not only its output is a function but \elpiIn{once} itself is a function.

To provide the compiler all of these pieces of information about the predicate
\elpiIn{once}, the user should add a signature to the predicate.
\Elpi's signatures are as follows:
GRAMMAR

TODO: dire che func sta per funzionale e rel sta per relazionale

So the signature of \elpiIn{once} will be: ``\elpiIn{func once i:pred, o:func}''
where \elpiIn{once} is a function, it takes a
relation and returns a function.

% Since predicate parameters can now be passed to other predicate calls, and since
% these calls may affect the determinacy of a predicate, we need to specialize
% our determinacy checker.
\begin{elpicode}
  func apply5 i:(func int -> int), o:int.
  apply5 F R :- F 5 R.
\end{elpicode}

Consider now, the \elpiIn{apply5} predicate depicted above. It is a function
that takes a function from \elpiIn{int} to \elpiIn{int} and returns the result of
applying that function to \elpiIn{5}. What happens if we
execute the query \elpiIn{apply
  divisors X}? We see that its output is not deterministic: the assignment for
\elpiIn{X} is not deterministically determined -- there are, in fact, two
possible assignments: one where \elpiIn{X} is assigned to \elpiIn{1} and another
where it is assigned \elpiIn{5}.

RIUTILIZZARE CODICE!!

SEPARARE IL CHIAMARE GIUSTO UN PREDICATO (per riusare codice)

Another problem is showed by the followig code:
\begin{elpicode}
  func idF i:func, o:func.
  idF X X.
\end{elpicode}
% func p i:(func int -> int), o:(pred i:int, o:int).
% p X X :- X = divisors.

In the snippet, we define the identity function over functions.

With \elpi's dynamic mode system, the call ``\elpiIn{idF Y Y, Y = divisor 5
  X, Y}'' succeeds because we can pass flexible terms in input positions. The problem
here is that, based on the signature of \elpiIn{idF}, its output is a function.
This allows us to assume that the variable \elpiIn{Y} is a function. However,
after the unification between \elpiIn{Y} and \elpiIn{divisor 5 X}, we lose that
property: calling \elpiIn{Y} produces several results for \elpiIn{X}.

DIRE CHE DIAMO L'ALGORITMO DI DETERMINACY CHECKING, PRIMA ATTRAVERSO ESEMPI E POI
RIASSIUMIAMO TUTTO

To address this issue, we could statically annotate terms with their determinacy
status in a way similar to the static mode checking for ground terms. Then,
when a unification is performed between two terms, a compilation error
could be raise if their determinacy tag mismatch.
In the example above, \elpiIn{Y = divisor} would be rejected since \elpiIn{Y}
would be annotated as a function and \elpiIn{divsor} is a relation.

% \newcommand{\detT}[1]{\text{\mlIn{~\PYG{n+nc}{#1}~}}}


The labels we need are defined with the following inductive:

\begin{coqcode}
  Inductive ~\detlab~ := Exp | Rel | Det | arr (i:detlab) (o:detlab).
\end{coqcode}

A term is either an expression (an non executable peice of code), a relational
or a deterministic predicate or finally an arrow (just like the arrow used for
the types of functions) between two \detlab. For the last constructor we
will use the notation $d_1 \myTo d_2$ where $d_1$ and $d_2$ are instances of\todo{i:detlab list if multiple args}
\detlab, moreover we consider $d_1$ to be an input and $d_2$ to be an output.
We are again considering binary relations. This can always be generalized to
functions (or relations) of any arity by slightly changing the signature of
the \coqIn{arr} constructor.

The problem of this first algorithm of determinacy check is that it does not
take into account a natural relation that exists between functions and
relations, i.e. a function is a relation such that all of the member in its
domain points to a unique value in its codomain. This means that a fuction can
be always passed in place of a relation. We define below the inclusion relation
between two \detlab.

\begin{coqcode}
  Fixpoint a ~\mySub~ b := match a, b with
  | Rel, Func -> false
  | Func, Rel | Rel, Rel | Func, Func | Exp, Exp -> true
  | a ~\myTo~ b, a' ~\myTo~ b' -> a' ~\mySub~ a && b ~\mySub~ b'
  end.
\end{coqcode}

The \mySub\ relation is intentionally non-complete since we suppose that before
performing any determinacy checking the program has been type-checked. This
means that it is never possible to have unification between, for example,
expressions and relations, this would lead to a fatal type-error.

The base cases of \mySub\ are quite intuitive: a relation is not a function. The
interesting case is the \coqIn{arr} constructor. Here, we are comparing two
propositions and therefore some attention should be paid for its inputs and
outputs: the inputs of the left memeber should be at least as restrictive as the
right one and the outputs of the left memeber are at most as restrictive as the
right one.

As an example consider two terms $t_1 \coloneq \texttt{idF}$ and $t_2 \coloneq
  \texttt{once}$. The determinacy of $t_1$ is $\detT{Func} \myTo \detT{Func}$ and
the determinacy of $t_2$ is $\detT{Rel} \myTo \detT{Func}$. We intuitively
remark that $\forall p_1\ p_2\ p_3, \texttt{once}\ p_1\ p_2 \to \texttt{idF}\
  p_1\ p_3 \to p_2 \mySub p_3$. This is because the two predicates can be called
with a relation and the output of \texttt{idF} is still a relation whereas the
output of \texttt{once} is still a function, i.e. the determinacy type of
\texttt{once} is more constraining. Said in other words, $\detT{Rel} \myTo
  \detT{Func} \mySub \detT{Func} \myTo \detT{Func}$.

What may seem weird at first sight is that in the example above, we call
\texttt{idF} with a relation in input position. This creates a mismatch
between the dtype of the signature and the dtype of the argument.\todo{dtype := determinacy type}
However, we want our system to be as expressive as possible. This means that
we allows the user the wrongly call a predicate. In that particular case the dtype of the
outputs will not be guaranteed to have the expected determinacy: they will be labeled
with the less restrictive determinacy for its type. To continue our example,
the query \elpiIn{idF (divisor 3 X) Y} will label \elpiIn{Y} with the \relI\
tag, since the determinacy of \elpiIn{divisor 3 X} is \relI\ and $\relI \not\mySub \detI$.

Thanks to the \mySub\ relation we can define a min (resp. max) relation between
two determinacy relations.

$$
  \minT\ f_1\ f_2 = \begin{cases}
    \maxT\ a'\ a \myTo \minT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
    f_1                             & \text{else if } f_1 \mySub f_2                     \\
    f_2                             & \text{otherwise}
  \end{cases}
$$
$$
  \maxT\ f_1\ f_2 = \begin{cases}
    \minT\ a'\ a \myTo \maxT\ b\ b' & \text{if } f_1 = a \myTo b \land f_2 = a' \myTo b' \\
    f_1                             & \text{else if } f_2 \mySub f_1                     \\
    f_2                             & \text{otherwise}
  \end{cases}
$$

% \begin{coqcode}
%   Fixpoint min a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => max a' a && min b b'
%     | a, b -> if a ~\mySub~ b then a else b
%   end with max a b = match a, b with
%     | a ~\myTo~ b, a' ~\myTo~ b' => min a' a && max b b'
%     | a, b -> if a ~\mySub~ b then b else a
%   end.
% \end{coqcode}

These two functions become particularly useful
when trying to determine the determinacy of unification variables. Let's
take the following example.

\begin{elpicode}
  pred give_rel i:int, o:pred.
  func give_fun i:int, o:func.
  give_rel _ (divisors 5 X).
  give_rel _ (succ 1 X).
  give_fun _ (succ 1 X).
\end{elpicode}

In the snippet above, both \txt{give\_rel} and \txt{give\_fun} are functions
that take a dummy integer as input (we conventionally work with binary
predicates) and return, respectively, a relation and a function.

Now, consider the following query: \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}.
The first goal tells us that \elpiIn{Z} is \relI, while the second tells us that
\elpiIn{Y} is \detI. After unifying the two variables, what determinacy label
should they have? Unification succeeds if the two terms are unifiable, meaning
that, in the end, \elpiIn{Z} and \elpiIn{Y} will be the same term and will
therefore share the same \detlab. Their label will be updated and set to the
minimum determinacy between them, which is \coqIn{min Rel Fun} $=$ \detI.

If we take back the query \elpiIn{give_fun 1 Y, give_rel 1 Z, Z = Y}, we may
want to statically determine if it create choice points. The determinacy of each
goal is \detI, \relI, \detI, the determinay of the query is the maximum of them,
that is \relI.

With this, we now have all the ingredients needed to propose the full static
determinacy checker for the higher-order setting. This checker is implemented in
\detCheck, which ensures that a deterministic predicate has at most one solution
per call. Furthermore, it is extended to certify that each output of a clause
has the expected determinacy, which is crucial since outputs can be used as new
queries in the program.

TODO: redifine \cref{def:det-prem}: we can have variables has props.


\begin{figure}
  \centering

  \ruleCheckClauseM{1}


  \ruleCheckCutM{.45}
  \ruleCheckEmptyM{.35}

  \ruleCheckPiM{.7}
  \ruleCheckImplM{.7}

  \ruleCheckUnifM{.7}

  % \ruleCheckMatchM{.7}
  \ruleCheckCallM{1}
  \ruleCheckCallFailM{1}

  \caption{Static check rules}
  \label{fig:static-check}
\end{figure}

$$-----$$

For instance, we would like that the call \elpiIn{idF divisors X} is valid for
determinacy, but, since the input has not the expected determinacy, then the
output will not be a deterministic predicate. Indeed, we propose the following
ordering relation between deterministic and relational predicates.

TODO: presentare l'algoritmo di static check of determinacy with varaible flow.

Dare un esempio in cui l'input ground non è garantito e in cui il checkin viene
invalidato

\subsection{Mode checking: input-ground mode}
\label{sec:mc}
Dire come funziona il mode checking e spiegare che è una condizione sufficiente
per avere la determinacy.

\subsection{Mutual exclusion for local clauses}
Polarity check: inner clauses when using the impl construct

Da spostare prima della sezione \cref{sec:mc}

\subsection{Determinacy polymorphism}

Il problema è ad esmepio la funzione identità

\begin{elpicode}
  pred id i:A, o:A.
\end{elpicode}

Se id viene chiamato con una deterministic-predicate, allora l'output sarà
anch'esso deterministic. Il problema è che non è sempre vero che la determinacy
è passata tra due oggetti che hanno lo stesso tipo.

Per esempio:

\begin{elpicode}
  pred wrong_id i:A, o:A.
  wrong_id fun rel.
\end{elpicode}

Per l'identià si potrebbe definire versioni specializzate:

\begin{elpicode}
  pred id1 i:(func A -> A) (func A -> A).
  id1 X X.
\end{elpicode}

Ma ovviamente questo è tedioso, ci vorrebbe la possibilità di avere un
polimorphismo di determinacy.
Qualcosa tipo:

\begin{elpicode}
  pred id2 i:X~$^\texttt{Y}$~, o:X~$^\texttt{Y}$~.
\end{elpicode}

Dove $^\texttt{Y}$ trasmette l'informazione che i due argomenti di id2 hanno
la stessa funzionalità.