\section{Preliminaries}

Before providing a formal definition of determinacy and mode analysis, we
first describe the language we are working with, namely a dialect of \lamprolog
called \elpi.

Since we have structured our paper into two main sections: 1) the first
discusses a basic version of \elpi with only Horn clauses and the cut operator,
and 2) the second extends this version by introducing hereditary-Harrop
formulas, we will keep the presentation of the types and functions we need
simple, expanding them further when needed.

Data are represented by terms. For now, terms live in the datatype, they are
variables, constants or compound terms. A compound term is term with a rigid
head followed by a list of other terms. 
Predicates are binary relations of type \\\elpiIn{tm -> tm -> prop}
where \elpiIn{tm} is a notation for term. The first argument of a predicate is
considered has its input and the second is its output. This choice aims to ease
the presentation of mode checking (see \cref{sec:modes}). By convention
variables are indicated with capital letters, whereas predicate names and
terms are indicated with lower case letters.

An atom is either a fully applied predicate or the cut operator, noted
\cut.

A variable is a term not yet instantiated. We can assign variables thanks to the
unification procedure. The notation \unifyCmd{t_1}{t_2}{\subst}{\subst[']} represents
the unification between the terms $t_1$ and $t_2$ from an intial substitution \subst
to a final substition \subst[']. A substitution is a mapping from a variable name to its
assignment $t$. Unification provides, when possible, a most general substitution
between the two terms. If this substitution, sometime called unifier, does not
exists, then the following property holds:

\begin{definition}[Unification negation]
  $(\forall \subst, \subst t_1 \neq \subst t_2) \to (\neg (\exists t_3~\subst_1~\subst_2,
  \subst_1 t_1 = \subst_1 t_3 \land \subst_2 t_2 = \subst_2 t_3))$
\end{definition}

The notation $\subst t$ is the application of a term to a substitution.
It returns a new term where all variables in $t$ have been recursively been
replaced by heir assignment in \subst.

A clause is made of a predicate name, its two arguments and a body made of a
list of atoms. The list of these atoms are called premises and should be
considered as a list of subgoals in conjunction. By convention a clause is noted
with ``\clauseCmd{p}{i\ o}{b}'' where p is the predicate name i and o are its
parameters and b is the body. It should be read as follows: if $b$ holds
then $p\ i\ o$ holds. 

A program is a mapping from predicate names to clauses. These clauses are in
disjunction and the order of their visit depend on the chronological order in
which clauses have been declared. We have no builtin \textit{or} operator but
it's behavior can be replicated by adding several implementation of the same
rule.

Unlike other prolog system, such as \mercury \cite{1996Somogy}, \elpi is not a
compiled language and we do not transform the list $\mathcal{L}$ of clauses of a
predicate $p$ in super-homogenous form, i.e. a sole clause containing the
disjunction of $\mathcal{L}$. This is mainly due to the fact that \elpi is an
homoiconic language and its program definition can change during the evaluation
of the code.

A program is a mapping from predicate name to clauses.

A goal is a triple made of a program \prog, an atom
\g and a list of alternatives \alt. In particular,
\g is evaluated by looking into the clauses inside \prog.
\alt
contains the choice-points used by the interpreter during the evaluation of a
cut, the aim of this piece of data will be clarified further in the section
dedicated to the interpreter implementation (see \cref{sec:basic-elpi}).

The interpreter takes a program a query and returns a substitution if the query
is a consequence of the program. Each time a predicate call has multiple clauses
implementing it, it commits the first choice and keep the other as global
alternatives. If that choice leads to a failure, the interpreter will try to execute
the first alternative. This non-deterministic behavior can be controlled by
the user thanks to the cut operator which allows to cut out alternatives (see
\cref{sec:cut}).

TODO: dire cosa significa che una clausola can be applied successfully on a
goal.

To be more precise, we give below the type structure of each cunstruct we have
defined above:

\begin{coqcode}
  Definition tm := Set.
  Definition pn := string. (*predicate names are strings*)
  Definition vn := string. (*variable  names are strings*)
  Inductive atom := 
    | Call (p:pn) (i:tm) (o:tm) : t  (*binary predicates taking integers*)
    | Cut : t                        (*binary predicates taking integers*)
    ...                              (*this is extended in section XX*)
  Inductive clause := Clause (p:pn) (i:tm) (i:tm) (A:list atom) : Clause.
  Notation "P I O :- Bo" := (Clause P I O Bo) (at level 200, right associativity).
  Definition sbst := T.
  Definition prog := pn -> list clause.
  Inductive goal := Goal (P:prog) (a:atom) (A:list alt) -> goal.
  with alt := sbst * list goal.
\end{coqcode}

Below we provide the signature of the intepreter which is expressed by
the \run predicate. Its implementation will be provided thanks to derivation
rules in \cref{sec:basic-elpi} and \cref{sec:full-elpi}.
%
\begin{minted}[autogobble]{coq}
  Inductive run : goal -> list alt -> subst -> list alt -> subst := ...
\end{minted}

The inductive \coqIn{run} should be read as a relation between a goal \g, a list of
alternative \alt (which are in disjunction with the current goal) and an initial
substitution \subst. These three objects produce a new list of alternatives
\alt['] and a new substitution \subst[']. The idea is that the intepreter stop
when it finds the first solution, which is a valid substitutions for the query
wrt the program. In order to find all the solution of query from the current
program, that is all the valid substutions for the query, it is sufficient to
iterate over all the alternatives \alt['].

In the following we use the following notation for call to the run predicate:
%
$$ \runCmd{\mathcal{G}}{\mathcal{A}}{\subst}{\mathcal{A}'}{\subst'} $$

\subsection{The cut operator}
\label{sec:cut}

Logic programs are known for their non-deterministic behavior: there can be
multiple distinct ways to derive a query from a knowledge base, and logic
programs aim to find all of these solutions. While non-determinism is a key
feature, it is sometimes important to allow the user to control if and when
alternatives should be rejected. The cut operator is designed to address this
problem.

Since we use the elpi dialect of \lamprolog, it is important to clarify how
the cut behaves in our development. It is that case that each prolog-ish language
has its own cut implementation, for example in the official page of
swi-prolog (\href{www.swi-prolog.org}{www.swi-prolog.org}) we see that
there are two different cut implementations: the \textit{soft cut} noted with
``\texttt{C *-> T ; E}'' runs E if C has no solution otherwise the result is the
same as running the conjunction of C and T. The \textit{hard cut} noted with the
``\texttt{!}'', "discards all choice points created since entering the predicate
in which the cut appears".

The \mercury system \cite{1996Somogy} is meant to be a pure programming language
extended with types, modes, determinism and module systems. In order to satisfy
its purity, \Mercury only accepts a version of the soft cut.

It is also interesting to see that further representations of cut may exists,
such as the firm cut explained in \cite{2003Andrews} where they provide a
restricted version of the hard cut which has some concistency properties.

\Elpi implementation uses the hard cut definition. Even though the hard cut have
no equivalent representation from pure logic, we are convinced that, from a
programming perspective, it is quite practical. It allows us to eliminate not
only alternative implementations of a predicate but also to prevent backtracking
of all choice points born from the begin of the clause-body to the current cut
position.

For example, in \elpi, the \textit{if-then-else} construct, which is not a\todo{wrong if pred are bin + no prop as arg}
primitive of the language, can be impelented as follows:
\begin{elpicode}
  if C T E :- C, !, T. % if1
  if _ _ E :- E.       % if2
\end{elpicode}
Due to the hard cut, the query ``\elpiIn{if C T E}'' executes the \texttt{if1} rule.
If \elpiIn{C} has $n > 0$ solutions then only the first is kept, the other being
cut away as the rule \texttt{if2}. The call then succeeds only if \elpiIn{T} has
a solution. The rule \texttt{if2} will be run only if \elpiIn{C} has no
solution.

For example, in the following database:

\begin{elpicode}
  p 1.
  p 2.
  q 2.
\end{elpicode}
The query ``\elpiIn{if (p X) (q X) (0 = 1)}'' fails. Note that the usage of the
soft-cut would make the same query to have a solution, since the backtracking in
the condition would be authorized.
\todo{cut di teyjus}

\subsection{Concerning modes}
\label{sec:modes}

Before talking about determinacy and the impact that hard-cut has on it. We
prefer to spend some few words about the definition of modes, because as
explained in \cite{1989Warren,1996Somogy} modes are the basis for determinim.

The general idea is that a logic program allows to express relations, but,
sometimes it is also needed to express \textit{directed} relations, where arguments are
differenciated between inputs and output. Said in an other way, output arguments
can be derived from input arguments. It is often the case that the user of a
logic programming langauge tend, in most of cases, to express directed
predicates. The typical example of this need is the \texttt{append} predicate
aiming to concatate two lists.

In a prolog-ish program without modes, the following program:

\begin{elpicode}
append [X|Xs] L [X|L'] :- append Xs L L'. % app1
append [] L L.                            % app2
\end{elpicode}

\noindent
makes the query ``\elpiIn{append Y [] L, 0 = 1}'' to diverge. 
Here the variable \elpiIn{Y} is unified with a list of infinite
length, the rule \texttt{app1} being continously applied.

Modes are there to avoid this situation. The most widespread mode definition
in the literature are two: the input
mode and the output mode. The idea is that each predicate is annotated with a
mode signature, and a static mode checker verifies that the clauses of the
program are consistent with the mode declrations of the predicates. Essentially,
in the head of a clause, 1) terms appearing in input position are supposed to be
ground whereas 2) terms in output position must become ground in the body of the
clause. Within each premise of the body, 3) terms appering in output positions become
ground while 4) terms appearing in input positions are checked to be ground. If
condition 2) or 4) are not satisfied a mode compilation error is raised.

In \twelf \cite{1996pfenning}, which is an implementation of \lamprolog, mode
checking is extended to work with local nominal variables and higher-order
variable unification within the pattern fragment.

\begin{coqcode}
  Definition ~\customlabel{wellmoded}{\texttt{well\_moded}}~ ~\prog\!\!~:
    forall p i o (HG: ground i) ~\subst \subst[']~, 
      (H: ~\runCmd{[\goalCmd{\prog}{\callCmd{\texttt{p}}{\texttt{i}}{\texttt{o}}}{\EmptyList}]}{\EmptyList}{\subst}{a}{\subst[']}~),
        ground (~\subst' ~o).
\end{coqcode}

The definition above can be rephrased as follows: a program \prog is well moded
if for any (binary in our setup) predicate \pred called with a ground input
\texttt{i} and any output term \texttt{o}, if the call succeeds producing a
substitution \subst['] then the application of that substitution to \texttt{o}
is a ground term.

It is interesting to note that mode checking under the groundness condition is
sometime too restrictive. In some situation it is in fact sufficient to work
with term that are "enough" ground to guarantee the wanted properties. As an
example, both \cite{1994apt-oc} and \cite{2002overton}, even though they
researches concern different areas, present a version of this mode checking with
"enough" instantiated terms together with some condition of variable linearty.

In our paper, we will combine these ideas. In particular,
since \elpi is used as a
meta-language for proof verification
\cite{tassi2018,tassi2019,tassi2023,fissore2023,fissore2024}, we
need to work with a higher-order setup where inputs (and outputs) may not be
fully instantiated: the role of the search engine is to potentially assign
unification variables. In the first part of the paper, we will introduce the
seamantics of the input mode which is used in \elpi. 
In the second part, we extend it so that it works with predicates taking
predicate calls as arguments.

\subsection{Concerning determinacy}
\label{sec:det}


Determinacy, as anticipated, is the property of a predicate that returns at most\todo{dire che funciton == determistic predicate}
one solution per call. Determinism checking statically ensures that
the clauses implementing a deterministic predicate respects this condition.
In the literature, several papers discuss this topic, although
they provide different descriptions and different usages of it.

Determinacy checking (or inference) is statically performed on a program on
predicates annotated (or inferred) as deterministic. Under the hypothesis to work
with program statically mode-checked, a necessary condition for a
predicate to be deterministic is that no two clauses can be applied successfully
on the same predicate call. Two clauses respecting this property are called
mutually-exclusive.

\begin{definition}[Mutual-exclusion on heads]
  \begin{coqcode}
    Definition ~\customlabel{mutexcl}{\texttt{mutual\_exclusive}}\prog \pred\!\!~:
      ~$\forall\ i1\ o1\ bo1\ i2\ o2\ bo2$~ (H1: ~\clauseCmd{p}{i1\ o1}{bo1}~ \in ~$\prog\ p$~) (H2: ~\clauseCmd{p}{i2\ o2}{bo2}~ \in ~$\prog\ p$~),
          not (exists ~\subst\!\!~, ~\unifyCmd{i1}{i2}{\EmptySubst}{\subst}~)
  \end{coqcode}   
  \label{def:mut-excl} 
\end{definition}

% \begin{coqcode}
%   Definition mutual_exclusive_head '(p i _ :- _) '(p i' _ :- _) :=
%     not (exists ~\subst\!\!~, ~\unifyCmd{i1}{i2}{\EmptySubst}{\subst}~)

%   Definition mutual_exclusive_cut c1 c2 :=
%     before c1 c2 -> with_cut c1
    
%   Definition mutual_exclusive prog p :=
%     forall c1 c2, c1 <> c2 -> c1 \in prog p -> c2 \in prog p ->
%       mutual_exclusive_clause c1 c2 \/ mutual_exclusive_cut c1 c2

% \end{coqcode}


\begin{definition}[Mutual-exclusion with \cut]
  Given a program \prog and deterministic predicate \pred, let $c_0, \dots, c_n$
  be the non-mutually exclusive clauses of \pred in \prog, then mutual exclusion
  is guaranteed if all clauses $c_i$ with $0 \leq i < n$ have a \cut\ as a
  premise in their body.
  \label{def:mut-excl+cut}
\end{definition}


The second important condition
for determinacy is the following: 

\begin{definition}[Deterministic premises]
  Let \prog be a program and \pred a deterministic-annotated predicate, then let
  $p_1,...p_n$ be the premises in the bodies of all the clauses of \pred in
  \prog. If there is no cut in $p_1 ... p_n$ then all $p_i$ for $1 \leq i \leq n$
  are calls to deterministic predicates, else, le $i$ be the position of the
  last \cut in the premises list, then all $p_j$ $i+1 \leq j \leq n$ is a call
  to a deterministic predicate.
  \label{def:det-prem}
\end{definition}

\begin{definition}[Determinacy checking]
  Determinacy checking (noted \coqIn{det_check}) on a program
  \prog is defined as the combination of 
  \cref{def:mut-excl,def:mut-excl+cut,def:det-prem}
\end{definition}

In \cite{1989Warren}, the authors describe a property subsuming
determinism: they describe functionality. A predicate (clause or query) is
functional if it produces at most one \textit{distinct} solution per predicate
call. The key word here is \textit{distinct}, since, in the determinacy setting,
a predicate call producing the same solution twice is not considered as
deterministic, while, it is functional. In the paper they explain that mutual
exclusivness of clauses can be improved not only by looking at the head and at
the presence of the cut but also by instructing the checker that premises can
put clauses in mutual exclusivness.

In \cite{1991Sahlin}, and more formally in \cite{1996mogensen}, determinacy is
used to work with \mixtus, a partial evaluator of \prolog. In that case,
determinacy is inferred so that it is possible to derive a new specialiezed,
and therefore more efficient, version of the original program under the
guarantee that the two program share the same semantics.

Finally, in \cite{1996henderson}, a determinacy checker for \mercury 
captures different behaviours of a predicate. A predicate can return
exactly zero and/or one solution, zero and/or multiple solution. In \mercury the
user is allowed to annotate predicates with determinacy information. A
non-annotated predicate will be inferred with the lowest derived tag.
Determinacy, in \mercury, besides giving a guarantee on the program, allows to
specialized it so that a faster routine can be used in the compiled program.

Several work of King et al \cite{king2005, king2006, 2011king} has been pursued
in order to build an inference model for determinacy in \prolog system with cut.
Moreover, they explain that determinacy inference subsume determinacy checking.
Even though this last claim, we think that an inference model does not fit
well with our language.

The first motivation is that since \elpi is an interpreted dialect of \lamprolog,
program can change dynamically on the run of a program. This means that
rules can be added \textit{à la volée} making impossible to infer
determinacy as the user expects. 
It's 
up to the user to choose what should be the behavior of a predicate wrt
determinacy. The checker is meant to assist the user by rejecting, a predicate,
that does not respect the declared determinacy. 

As explained in some of the previously cited papers, determinacy (and so
functionality) checking is an undecidable problem. The checking property is
sound: if a predicate passes the analysis then it is for sure deterministic.
However, it is not complete: there could exists false negatives. We are
convinced, that completeness, is not a big deal, since, as also claimed in ...
every deterministic predicate not passing the determinacy check,
can be rewritten in a equivalent way
so that it is no more classified as non-deterministic.

\begin{coqcode}
Definition ~\customlabel{detpred}{\texttt{det\_pred}}~(~\prog~: prog) (p: pn) :=
  forall ~$i$~ ~$o$~ ~$a$~ ~\subst~(HG: ground i) 
    (H : ~\runCmd{[\goalCmd{\prog}{\callCmd{p}{i}{o}}{\EmptyList}]}{\EmptyList}{\EmptySubst}{a}{\subst}~), ~$a$~ = ~\EmptyList~.
\end{coqcode}

The definition above explains what it means for a predicate to be deterministic. 
The idea is that in a given program \prog and a predicate $p$,
if for any call to $p$ with arbitrary input and output terms
starting with the empty substitution and the empty list of alternatives,
we have a solution, i.e. the couple $(a, \subst)$ then the list of
alternatives $a$ is empty. This essentailly means that any functional
predicate produces no choice points.

Following the literature, this claim is proven true:

\begin{theorem}
  Let \pred be a deterministic-annotated predicate, the following holds
  \begin{coqcode}
    Theorem ~\customlabel{is_detpred}{\texttt{det\_pred\_prop}}~(~\prog~: prog) (p: pn) :=
      forall (HM : well_moded ~\prog\!\!~) (HD: det_check ~\prog\!\!~),
          det_pred ~\prog~p
  \end{coqcode}    
\end{theorem}

This to say that for any well-moded (hypothesis \coqIn{HM}) and
determinacy-checked (hypothesis \coqIn{HD}) program and a predicate \pred such,
then \pred is a deterministic predicate.

\subsection{Contributions and paper structure}

In our paper we will provide a description about a new mode and functionality
checkers to verify that clauses are consistent wrt the user annotation. We
introduce these concepts with the \elpi programming language. We start by a
light version of \elpi in the first-order setting, i.e. with no $\lambda$-terms.
Here we provide the derivation system allowing to evaluate a query. Few words
will be spent on the mode checker in this subset of the \elpi language. These
derivation rule, together with the mode checker, are used to prove that any
functional predicate can be rewritten so that all of its rules have at least one
cut by keeping the semantics of the original program. 

In the second part of the paper we will extend the intepreter so that it can
work with higher-order variables, hereditary-arrop clauses insertion and local
$\forall$-quantified variable declaration. Here predicates will also take
propositions as arguments. Thanks to this extention we will propose a new mode
checking algorithm working with a new definition of groundness, called
\textit{input-ground}. The signature of a predicate can be annotated so that
output arguments are guaranteed to be deterministic. This will make the
determinacy checker to analyse not only deterministic clauses but also relational
one, since a check should be performed wrt the determinacy annotation of its
outputs.