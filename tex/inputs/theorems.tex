
\section{Determinacy analysis}\label{sec:thm}

% \begin{definition}[Functionality (\isfunc)]\label{def:is-func}
%   Given a program \prog and a term $t$,
%   \isdet\ is defined as follows:
%   $$\forall a\ \subst, \isFuncCmd{t}$$
% \end{definition}

We are interested in identifying predicates that leave no choice points
called \emph{semidet} in \cite{1996henderson}, or in the wording of \cite{nakamura1986}
are \emph{operationally deterministic}. Due to the lack of space, we leave the
proofs of the following theorems in the appendix.

\begin{definition}[Operational determinacy (\isdet)]\label{def:is-det}
  Given a program \prog and a term $\predt$,
  \isdet\ is defined as follows:
  $$\forall a\ \subst, \isDetCmd{\predt}$$
\end{definition}

\noindent Said in other words, a predicate call \isdet if its execution does not
create choice points. Without loss of generality, we can rephrase the lemma in
the following way:

\begin{definition}[Operational determinacy empty prog (\isdetE)]\label{def:is-det-empty}
  The execution of an atom $t$ is deterministic iff
  $$\forall a\ \subst, \isDetCmd[\EmptyList]{t}$$
\end{definition}

\noindent The main difference from the first definition is that we begin with an
empty program and handle a generic term \( t \). Notably, due to the implication
operator, this second definition remains equivalent to the first, as local
clauses can be dynamically loaded during the evaluation of \( t \), thereby
reconstructing the same program referenced in \cref{def:is-det}.  

\def\atomtoprog{\ensuremath{\mathcal{T}}}

\begin{definition}[Split atom (\atomtoprog)]
  Given $\Ainst = \piImplCmd[ty_1]{x_1}{c_1}{\dots \impl\
  \piImplCmd[ty_n]{x_n}{c_n}{s}}$, then $\atomtoprog(\prog) = \langle \{c_n,\cdots,c_1\}, s \rangle$ 
\end{definition}

\begin{lemma}
  Given an atom $\Ainst$ and let $(\prog, \Ainst') = \atomtoprog(\Ainst)$, then
  $$\isdetE\ \Ainst \Rightarrow \isdet\ \prog\ \Ainst'$$
  \label{th:run-empty}
\end{lemma}

Thanks to the definition of \isdet, we can provide the semantics of determinacy
signatures.
The intuition is given by the following formula.

\begin{definition}[Meaning of a signature $(\sem{\func}\ (\predt))$ given a context \ctx and a program \prog]\label{def:sem}
\vspace{-1em}
\newcommand{\funcF}[1][]{\ensuremath{\mathcal{F}#1}}
\begingroup\makeatletter\def\f@size{8}\check@mathfonts
$$
\arraycolsep=1.4pt
\begin{array}{rll}
  \sem{\detI}\ (\predt) & = %
      \bigwedge \vecL{\semi{\func_i}\ t_i} \Rightarrow \isdet\ \prog\ {(\predt)} \land \bigwedge \vecL{\semi{\func_o}\ t_o} %
      & \mathrm{s.t.\ } \ctx\ \pred{} = \dtype{\detI}{\func_i}{\func_o} \\
  \semi{\dtype{\detI}{\func_i}{\func_o}}\ (\predt) & = %
    \forall \vec{u}\ \vec{v}, |\func[_i]| = |\vec{u}| \land |\func[_o]| = |\vec{v}| %
      \land \bigwedge \vecL{\semi{\func_i}\ u} \Rightarrow \\ %
      & \qquad \isdet\ \prog\ {(\pred\ (\vec{t}@\vec{u}@\vec{v}))} \land \bigwedge \vecL{\semi{\funcF}\ t_i}  
      & \mathrm{s.t.\ } \ctx\ \pred{} = \dtype{\detI}{(\funcF @ \func_i)}{\func_o} \\
  \semi{\dtype{\detI}{\EmptyList}{\func_o}}\ (\predt) & = %
    \forall \vec{v}, |\func[_o]| = |\vec{v}| %
        \Rightarrow  %
        \isdet\ \prog\ {(\pred\ (\vec{t}@\vec{v}))} \land \bigwedge \vecL{\semi{\funcF}\ t_i} %
      & \mathrm{s.t.\ } \ctx\ \pred{} = \dtype{\detI}{\funcF}{(\funcF_o @ \func_o)} \\
  \semi{\dtype{\relI}{\_}{\_}}\ (\predt) & = \top \\
  \semi{\dtype{\expI}{\_}{\_}}\ (\predt) & = \top 
\end{array}
$$
\endgroup
\end{definition}
The first equation states that if the preconditions of a signature are satisfied
then the call to a predicate of that signature is
functional and the post conditions on the outputs hold.
The link with \mySub is evident, and justifies the variance and contravariance
used in the arrow case of a determinacy type. Given a term $t$, if $f_1 \mySub f_2$, then
$\sem{f_1} t \Rightarrow \sem{f_2} t$:
the post-conditions of $f_1$ can be stronger than the ones of $f_2$ while
the pre-conditions of $f_1$ must be weaker than the ones of $f_2$.

The theorem we want to prove is the following.

\begin{theorem}
  Given a context \ctx and an atom $t$, such that all local clauses for
  deterministic predicates have a \cut, then
  $$\checkCmd{\ctx}{\detI}{t}{\_}{\detI} \Rightarrow \isdetE\ t$$
  \label{th:1}
\end{theorem}

\noindent
This theorem is crucial for establishing the connection between our determinacy
checker and the a program execution. Specifically, if our \checkk\ procedure
verifies that a given atom is \detI, we can guarantee that its interpretation
will produce no choice points.

The invariant we preserve in the proof is that \checkk\ ensures $\sem{\detI}\ t$
while guaranteeing that all the input terms appearing in $t$ respect
$\semi{\cdot}$.

\Cref{th:1} can be generalized to work in a context where a concrete program
\prog is provided (instead of having the initial empty program). This program is
possible thanks to \cref{th:run-empty}. The program \prog is extracted thanks to
the \atomtoprog\ function.

The hypothesis in \cref{th:1} about the fact that local clauses for
deterministic predicate should have a \cut can be relaxed in some situations.
The interesting property allowing to remove \cut while respecting the semantics
of the program is the so-called mutual-clause exclusion.

\begin{definition}[Mutual exclusion \mutExclAll]
  Given a clause $c$ and a program \prog. $\mutExclAll\ \prog\ c$ holds iff forall
  clauses $c'$ declared after $c$ in \prog, there exists an input position that
  discriminating them, i.e. s.t. the inputs in $c$ and $c'$ respectively do not
  unify.
\end{definition}

% \begin{lemma}[\mutExcl]
%   Given a program \(\prog\), it exists an equivalent program \(\prog'\) that
%   contains the minimal number of \cut\ operators. 
% \end{lemma}

\def\remCut{\ensuremath{\mathcal{R}}}

\begin{definition}[Remove redundant \cut (\remCut)]
  Given a program \prog, we can build a program $\prog'$, which is a copy of
  \prog where for each clause \( c = \clauseCmd{\pred}{\vec{t}}{\vecL{bs}, \cut,
  \vecL{ds}} \) in \(\prog\), if all premises in \(\vecL{bs}\) are valid calls to
  deterministic predicates and $\mutExclAll\ \prog\ c$, then
  the \cut\ can be safely removed.
\end{definition}

Finally, we can generalize \cref{th:1} as follows.

\begin{theorem}[Deterministic execution] \label{th:2}
  Given a predicate context \ctx, a program \prog\ and a predicate \pred, s.t.
  $\ctx\ \pred = \dtype{\detI}{\_}{\_}$, then
  $$
  \mutExclAll\ \ctx\ \prog \land
  (\forall c \in \prog, \checkc\ \ctx\ c) \land
  \checkk\ \ctx\ (\pred\ \vec{t})
  \Rightarrow
  \isdet\ \prog\ (\pred\ \vec{t})
  $$
\end{theorem}

\begin{proof}
  We can prove this final lemma thank to \cref{th:run-empty}, combining the

\end{proof}
