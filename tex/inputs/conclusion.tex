\vspace{-1.5em}
\section{Related work and conclusions}

\begin{table}[t]
  \begin{center}
  \begin{tabular}{c|c|c|c|c}
    Paper         & Mode check & HO programs        & Wrong calls           & Open program    \\
    \hline
    Warren et al. & required   & \xmark          & \xmark          & \xmark \\
    Mercury       & required      & \cmark$\ddagger$ & \xmark$\dagger$ & \xmark \\
    % Mixtus        & \cmark      & \xmark          & \nicefrac{1}{2} & \xmark  & \xmark \\
    RedAlert      & required      & \xmark          & \xmark          & \xmark \\
    Elpi          & no need    & \cmark          & \cmark          & \cmark
  \end{tabular}
\end{center}
\vspace{-1em}
  \caption{Comparison with related work}
% \vspace{-1em}
\label{tab:comparison}
\end{table}


Several studies have explored determinacy analysis in logic programs.
\Cref{tab:comparison} summarizes the main differences between our approach to
determinacy checking and related work.

The papers referenced in the first column of the table correspond to
\cite{1989Warren,1996Somogy,2011king}. One key difference between our work and
these studies is that they focus on \textit{closed}
programs, that do not evolve during query execution, while 
the \impl\ operator of Elpi  allows clauses to be dynamically asserted.
%
For closed programs, predicates can be transformed into
\textit{super-homogeneous} form by merging all clauses into one with
disjunctions. This aids determinacy inference and may improve efficiency.
However, this transformation is not feasible in our open-world setting.



Our
operational semantics shares similarities with \cite{1990Vink}, where a list of
alternatives is maintained -- these alternatives are consumed on failure and
discarded upon encountering a \cut\ operator. The primary distinction between
our semantics and that of \cite{1990Vink} (beyond rule
\ref{rule:piimpl} to add local clauses to the program dynamically) 
is that we do not require special built-in predicates for \textit{fail} and \textit{or}.
Instead, we encode them directly in our language: for example \textit{fail} is
represented as a predicate with no implementation. % \textit{or} is a predicate with two propositional arguments
% $p_1$ and $p_2$, and two clauses: the first executes $p_1$, while the second
% retains the execution of $p_2$ as a choice point.
We also point out that our semantics is the concrete semantics of the Elpi
language from \cite{dunchev15lpar}, except for the $\mathcal{H}$ function. In
Elpi we employ deep indexing for clause retrieval, while complete
unification is kept lazy in the stack of alternatives, as explained in
\cref{sec:digression-h}.

Our operational semantics 
explicitly represents choice points, enabling us to identify
operationally deterministic predicates as those that do not leave any choice points.
This approach differs from \cite{2011king}, which employs a denotational semantics
where choice points are encoded as continuations.
%
Regarding modes, Elpi’s matching procedure over input arguments allows us to
dispense with explicit mode checking -- an essential component in the other works.

Our determinacy analysis encompasses numerous higher-order features, some of which
are absent in other higher-order logic programming languages.
In particular, it handles partially applied predicates, non-ground
atoms as arguments and the inspection of
atoms (as demonstrated in \cref{sec:examplesx}) ($\ddagger$).

% Additionally, Elpi’s strong integration with an interactive theorem prover like
% Rocq prevents us from relying on ground input terms.

Finally the \mySub\ relation allows higher-order predicates to
be wrongly applied. %, as illustrated by the \elpiIn{map} procedure. 
In the Mercury
language (\cite{1996Somogy}),
this notion of a ``wrong call'' does not exist. Instead, the language enforces
correctness by requiring higher-order functions to be annotated with explicit
mode and determinacy signatures for each possible behavior. As a result, Mercury
ascribes 
\href{https://github.com/Mercury-Language/mercury/blob/5900de3e8c1bc1dcc75799b350b381ff9b9774f2/library/list.m#L1587C1-L1597C75}{$11$ signatures}
to the \texttt{foldr} predicate
and any call that does not match exactly one of these signatures results in a
compilation failure ($\dagger$). % For instance, \textit{list.filter\_map\_corresponding} fails
% if the higher-order function is deterministic rather than semi-deterministic.

Elpi targets less technically inclined users, more familiar with functional programming languages
than logic ones, hence we strive for simplicity,
defining only one determinacy class and immediately classifying wrong calls as
non-deterministic.
As a result \elpiIn{foldr} is decorated with just the following signature: 
\elpiIn{func foldr (func L, A -> A), list L, A -> A}, which is familiar to our audience.
Finally this design choice aligns
with our goal of providing static guarantees on programs rather than
helping the compiler to produce
efficient, specialized, machine code.

% We applied our determinacy checker to the Hierarchy-Builder tool by
% \cite{cohen_et_al:LIPIcs.FSCD.2020.34}. It consists of $5,031$ lines of
% code organized into $495$ predicates. %, of which $482$ had declared signatures. 
% As a result $460$ predicates are functions at the cost of adding
% % $13$ signatures and
% $37$ cuts — $26$ of which arguably should have been present from
% the beginning.

We applied our determinacy checker to Rocq-Elpi by
\cite{tassi2018}
and Hierarchy-Builder by
\cite{cohen_et_al:LIPIcs.FSCD.2020.34}. Together, they consist of 14,062 lines of
code organized into 1,126 predicates. %, of which $482$ had declared signatures. 
As a result 1,073 predicates are functions at the cost of adding
% $13$ signatures and
137 cuts — 105 of which arguably should have been present from
the beginning (they were lurking bugs).
The determinacy checker runs, on average, faster than the type checker.

Elpi is free software available at \url{https://github.com/LPCIC/elpi}.

% TODO: bench on HB



% SE NON HO MATCH
% \todo{fare P! + well moded}

% SE FACCIAMO PI IMPL:
% Unlike other prolog system, such as \mercury \cite{1996Somogy}, \elpi is not a
% compiled language and we do not transform the list $\mathcal{L}$ of clauses of a
% predicate $p$ in super-homogenous form, i.e. a sole clause containing the
% disjunction of $\mathcal{L}$. This is mainly due to the fact that \elpi is an
% homoiconic language and its program definition can change during the evaluation
% of the code.

% In \cite{1991Sahlin}, and more formally in \cite{1996mogensen}, determinacy is
% used to work with \mixtus, a partial evaluator of \prolog. In that case,
% determinacy is inferred so that it is possible to derive a new specialiezed,
% and therefore more efficient, version of the original program under the
% guarantee that the two program share the same semantics.

% Finally, in \cite{1996henderson}, a determinacy checker for \mercury
% captures different behaviours of a predicate. A predicate can return
% exactly zero and/or one solution, zero and/or multiple solution. In \mercury the
% user is allowed to annotate predicates with determinacy information. A
% non-annotated predicate will be inferred with the lowest derived tag.
% Determinacy, in \mercury, besides giving a guarantee on the program, allows to
% specialized it so that a faster routine can be used in the compiled program.

% Determinacy, as previously mentioned, is the property of a predicate that
% returns at most one solution per call. Such a predicate behaves like a function,
% which is why we refer to it as a deterministic predicate or simply a function.
% Determinism checking statically ensures that the clauses implementing a
% deterministic predicate adhere to this condition. The literature contains
% numerous discussions on this topic, offering various descriptions and
% applications of determinism.

% In \cite{1989Warren}, the authors describe a property subsuming
% determinism: they describe functionality. A predicate is
% functional if it produces at most one \textit{distinct} solution per predicate
% call. The keyword here is \textit{distinct}, since, in the determinacy setting,
% a predicate call producing the same solution twice is not considered as
% deterministic, while, it is functional. %In the paper they explain that mutual
% exclusivness of clauses can be improved not only by looking at the head and at
% the presence of the cut but also by instructing the checker that premises can
% put clauses in mutual exclusivness.

% \todo{look at 1,2,5 of \url{https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=b52fc2c62a2f78b8565e96f97dc7cbf6c86b45d4}}

% TABLING cache entry for func only requires 2 cases, ongoing and done with 1 solution



% \subsection{Future work}

% \paragraph{Problem of charging local clauses with weaker conditions}
% Overlapping check che rompe:

% \begin{elpicode}
%   pi x\ (pi Y\ f x Y) => (pi y => f x y) => Bo
% \end{elpicode}

% Dove i modi per f sono input, input.

% In questo esempio se Bo = ``f x y'' allora ci sono due soluzioni,
% in quanto entrambe le regole caricate colla freccia si applicherebbero