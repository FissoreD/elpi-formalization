\section{Conclusion and related works}

\begin{table}
  \centering
  \begin{tabular}{c|c|c|c|c|c}
    Paper         & Mode check & Hard Cut & HO prog         & SubT.           & HHF    \\
    \hline
    Warren et al. & Assumed    & \cmark   & \xmark          & \xmark          & \xmark \\
    Mercury       & \cmark     & \xmark   & \nicefrac{1}{2} & \nicefrac{1}{2} & \xmark \\
    % Mixtus        & \cmark     & \cmark   & \xmark          & \nicefrac{1}{2} & \xmark  & \xmark \\
    RedAlert      & \cmark     & \cmark   & \xmark          & \xmark          & \xmark \\
    Elpi          & \xmark     & \cmark   & \cmark          & \cmark          & \cmark \\
  \end{tabular}

  \caption{Comparison}
  \label{tab:comparison}
\end{table}


Several studies have explored determinacy analysis in logic programs.
\Cref{tab:comparison} summarizes the main differences between our approach to
determinacy checking and existing work from the literature.

The papers referenced in the first column of the table correspond to
\cite{1989Warren,1996Somogy,2011king}. One key difference between our work and
these studies is that prior research primarily focuses on \textit{closed}
programs, i.e., programs that do not evolve during query execution. In contrast,
our approach, leveraging the \impl\ operator, allows clauses to be dynamically
loaded in subqueries, making the program mutable.

For closed programs, a transformation into \textit{super-homogeneous} form is
possible, where all clauses of a predicate are collapsed into a single clause
containing a disjunction for each original clause. This transformation
facilitates determinacy inference and can sometimes yield more efficient
programs. However, in our open-world setting, such a transformation is not
feasible.

The mutability of programs also impacts our operational semantics: rule
\ref{rule:piimpl} must add local clauses to the program dynamically. Our
operational semantics shares similarities with \cite{1990Vink}, where a list of
alternatives is maintained -- these alternatives are consumed on failure and
discarded upon encountering a \cut\ operator. The primary distinction between
our semantics and that of \cite{1990Vink} (beyond the acceptance of hereditary
Harrop formulas in our system) is that we do not require special built-in
predicates for \textit{fail} and \textit{or}. Instead, we encode them directly
in our language: \textit{fail} is represented as a predicate with no
implementation; \textit{or} is a predicate with two propositional arguments
$p_1$ and $p_2$, and two clauses: the first executes $p_1$, while the second
retains the execution of $p_2$ as a choice point.

Our operational semantics enables reasoning with concrete objects, making it
easier to define what it means for a predicate to be deterministic. This
approach differs from \cite{2011king}, which employs a denotational semantics.

Regarding modes, Elpi’s matching procedure over input arguments allows us to
dispense with explicit mode checking—an essential component in the other works.
Additionally, Elpi’s strong integration with an interactive theorem prover like
Rocq prevents us from relying on ground input terms.

Finally, in higher-order programming, the \mySub\ relation allows predicates to
be wrongly applied, as illustrated by the \elpiIn{map} procedure. In Mercury,
this notion of a "wrong call" does not exist. Instead, the language enforces
correctness by requiring higher-order functions to be annotated with explicit
mode and determinacy signatures for each possible behavior. As a result, Mercury
requires $11$ mode signatures for the \textit{foldr} predicate
(\href{https://github.com/Mercury-Language/mercury/blob/5900de3e8c1bc1dcc75799b350b381ff9b9774f2/library/list.m#L1587C1-L1597C75}{source
here}), and any call that does not match an exact mode signature results in a
compilation failure. For instance, \textit{list.filter\_map\_corresponding} fails
if the higher-order function is deterministic rather than semi-deterministic.

Elpi takes a more high-level approach, defining fewer determinacy classes and
immediately classifying wrong calls as non-deterministic. For instance,
\elpiIn{foldr} has only the signature
\dtype{\detI}{[(\dtype{\detI}{[L,A]}{[A]}), \mathrm{list } L, A]}{A}. This
design choice aligns with our goal of providing static guarantees on programs
rather than producing specialized program transformations based on predicate
usage.




% SE NON HO MATCH
% \todo{fare P! + well moded}

% SE FACCIAMO PI IMPL:
% Unlike other prolog system, such as \mercury \cite{1996Somogy}, \elpi is not a
% compiled language and we do not transform the list $\mathcal{L}$ of clauses of a
% predicate $p$ in super-homogenous form, i.e. a sole clause containing the
% disjunction of $\mathcal{L}$. This is mainly due to the fact that \elpi is an
% homoiconic language and its program definition can change during the evaluation
% of the code.

% In \cite{1991Sahlin}, and more formally in \cite{1996mogensen}, determinacy is
% used to work with \mixtus, a partial evaluator of \prolog. In that case,
% determinacy is inferred so that it is possible to derive a new specialiezed,
% and therefore more efficient, version of the original program under the
% guarantee that the two program share the same semantics.

% Finally, in \cite{1996henderson}, a determinacy checker for \mercury
% captures different behaviours of a predicate. A predicate can return
% exactly zero and/or one solution, zero and/or multiple solution. In \mercury the
% user is allowed to annotate predicates with determinacy information. A
% non-annotated predicate will be inferred with the lowest derived tag.
% Determinacy, in \mercury, besides giving a guarantee on the program, allows to
% specialized it so that a faster routine can be used in the compiled program.

% Determinacy, as previously mentioned, is the property of a predicate that
% returns at most one solution per call. Such a predicate behaves like a function,
% which is why we refer to it as a deterministic predicate or simply a function.
% Determinism checking statically ensures that the clauses implementing a
% deterministic predicate adhere to this condition. The literature contains
% numerous discussions on this topic, offering various descriptions and
% applications of determinism.

% In \cite{1989Warren}, the authors describe a property subsuming
% determinism: they describe functionality. A predicate is
% functional if it produces at most one \textit{distinct} solution per predicate
% call. The keyword here is \textit{distinct}, since, in the determinacy setting,
% a predicate call producing the same solution twice is not considered as
% deterministic, while, it is functional. %In the paper they explain that mutual
% exclusivness of clauses can be improved not only by looking at the head and at
% the presence of the cut but also by instructing the checker that premises can
% put clauses in mutual exclusivness.

% \todo{look at 1,2,5 of \url{https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=b52fc2c62a2f78b8565e96f97dc7cbf6c86b45d4}}

% TABLING cache entry for func only requires 2 cases, ongoing and done with 1 solution



% \subsection{Future work}

% \paragraph{Problem of charging local clauses with weaker conditions}
% Overlapping check che rompe:

% \begin{elpicode}
%   pi x\ (pi Y\ f x Y) => (pi y => f x y) => Bo
% \end{elpicode}

% Dove i modi per f sono input, input.

% In questo esempio se Bo = ``f x y'' allora ci sono due soluzioni,
% in quanto entrambe le regole caricate colla freccia si applicherebbero