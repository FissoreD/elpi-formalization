\section{First-order prolog}
\label{sec:basic-elpi}

\subsection{First-order interpreter}
In this first section we start with a first-order version of a logic language.

The interpreter we are going to present is a system based on the derivation
rules depicted in \cref{fig:basic-interp}. Its structure is similar to the
operational semantics in \cite{1990Vink}. The choice to use operational
semantics, rather than denotational semantics (as in \cite{2011king}), is due to
our preference for maintaining a concrete representation of the objects we are
manipulating. Instead of using continuations to store the state of a choice
point, we prefer to represent this information as lists containing the
alternatives, along with the substitution existing at the moment the choice
point was created.

\begin{figure}
  
  \ruleStopM{.45}
  \ruleFailM{.45}
  \vspace{0.3em}%
  
  \ruleUnifM{.50}
  \ruleBangM{.40}
  \vspace{0.3em}%
  
  \ruleCallM{1}
  
  \caption{Basic derivation rules}
  \label{fig:basic-interp}
\end{figure}

The semantics expressed by \runCmd{g}{a}{s}{a'}{s'} relates a list of
goals $g$, a list of alternatives $a$ and an initial substitution $s$ with a
new substitution $s'$ and a new list of alternatives $a'$. The list of goals
should be understood as a list of goal put in cunjunction, whereas the
alternatives represent a disjunction of goals. In the derivation above we use
the two colon symbol ($::$) has separator between the head of a list and its tail;
$@$ stands for list concatenation; $[\ ]$ is the empty list. $\prog p$ is the
application of \prog to the predicate $p$; it returns a list of clauses. The
function $\mathcal{F}$ is defined as follows:
%
$$
\mathcal{F}(r, i, o, s, a) := [(s, (\Cons{(p, i = i', a)}\Cons{(p, o = o', a)}{[(p, g, a) \mid g \in bs]})) \mid cl\ i'\ o'\ bs \in r]
$$

It takes a list of clauses, two terms, i.e. $i$ and $o$ representing the two
arguments of the predicate call a substitution $s$ and a list of alternatives $a$. For each clause
$(cl\ i'\ o'\ bs)$, it builds a new list of pairs where the first argument
is the substitution $s$ and the second are goals made by 1) the unification of
the first argument $i'$ with the first argument $i$ of the predicate call 2) the
unification between the second arguments $o'$ and $o$ 3) the map of each premise
$g$ in the body $bs$ which return a new list of goals having the program $p$,
the atom $g$ and the list of alternatives $a$.

The behaviour of the program depends on the shape of the list of goal and its
alternatives. Starting from a configuration it is possible to execute the
program. It means that it exists a sequence of reductions allowing to reach the
\textit{stop rule}, symbolyzed with \ruleStop.

More precisely, \textit{stop rule} caputres the
configurations with an empty list of goals. By convention, this configuration is
the final one: there are no more goal to treat; therefore, we can stop and
return the same alternatives and substitution received in input.

The \textit{fail rule} (\ruleFail) is used to consume the list of alternatives,
if for example, the current goal leads to a failure or a loop. In fact, this
rule allows to break loop since it can non-determinalistically applied on any
configuration, provided that the list of alternatives is not empty. It is
possible to make the algorithm deterministic by chainging \ruleFail so that it
is applied if the current goal is a call to a predicate with no alternatives,
but we prefer to simplify our rule system.

The \textit{unify rule} (\ruleUnif) is applied when a unification $t1 = t2$
occurs in the head of the current goal list. It calls the unification algorithm
between the two terms $t1$ and $t2$ under the current substitution $s$ and
returns the updated substitution $s'$. Finally the \run procedure is called the
list of remaining goals $gs$ and the new substitution $s'$.

The \textit{cut rule} (\ruleBang) refers to goals where the first conjunct is is
the \texttt{!} atom. This is where the cut-alternatives $ca$ become interesting.
The rule tells that the list of goal $gl$ can be launched using $ca$ and the
new list of alternatives.

The \textit{call rule} (\ruleCall) deals with goals starting with a predicate
call. In this case the function $\mathcal{F}$ is called with the parameters as
explained above and if the result of this operation is the list
\ConsHd{b}\ConsTl{bs}, then a recursive call to \run is done by prepending $b$ to
the list of remaining goals $gl$ and $bs$ is prepended to the list of
alternatives $a$.

The combination of the \ruleCall and \ruleBang are crucial to reproduce the
behaviour of the hard cut. When a call to a predicate gives several rules as new
choice points, thanks to the function $\mathcal{F}$ we can associate each atom
of each body of $\prog p$ to the current alternatives $a$. If a clause $b_i$ in
\ConsHd{b}\ConsTl{bs} with $0 \leq i \leq | bs |$ has a cut, then all the
choice points $b_j$ with $i < j \leq | bs |$ will be cut away.

As an example, let's consider the following program called \prog:

\begin{elpicode}
p1 X Y :- p2 X Y.           % r1
p1 3 3.                     % r2
p2 X Y :- p3 X Y, !, Y = 1. % r3
p2 1 1.                     % r4
p3 1 2.                     % r5
\end{elpicode}

{
\def\goalG{\goalCmd{\prog}{call\ (\text{\elpiIn{p1 3 Z}})}{\EmptyList}}

Let $\mathcal{G} :=\ \goalG$ be a goal, the execution of
``\runCmd{\mathcal{G}}{\EmptyList}{\EmptySubst}{?A}{?S}'' will apply \ruleCall
producing a new goal for the rule $r1$ and an alternative list containing $r2$,
we leave out details concerning unifications of head terms. The execution of
$r1$ will try to solve $r3$. This will add three goals \elpiIn{r 1 Y, !, Y = 1}
with cut-alternatives equal to $r2$ whereas the new alternatives will be $r4 @
r2$. The execution of $r3$ will solve \elpiIn{p3 1 Y} with substitution $s :=
\{X \gets 1; Y \gets 2\}$. The \elpiIn{!} will cut away the alternative $r4 @
r2$ and will keep the cut-alternative $r2$. The failing premise \elpiIn{Y = 1}
will cause a backtracking thanks to \ruleFail and try to apply $r2$ from the
empty substitution. This last unification succeed with final substution $?A :=
\{X \gets 3; Y \gets 3\}$ and final list of alternatives $?A := \EmptyList$.

% \begin{myRule}{1}
%   \AxiomC{}
%   \RightLabelM{\ruleCall}
%   \UnaryInfC{\runCmd{\mathcal{G}}{\EmptyList}{\EmptySubst}{?A}{?S}}
% \end{myRule}

}


\subsection{First-order mode checker}

Mode checking in this setting is performed using the classical groundness
verification where term groundness is derived from their flow in the body of a
clause. We start with the hypothesis that a term in input position in the head
of a clause is ground. The premises in the body representing calls to predicates
must be called with ground input terms, while output are supposed to become
ground. At the end of the body analyse, we check that the output terms in the
head of the clause has become ground. If this is not the case, or if a call in
the body is done with a non-ground term in input position a mode-checking error
is raised.

\subsection{First-order functionality checker}

As anticipated, functionality checking can be performed in 


