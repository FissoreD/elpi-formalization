\section{Basic prolog}
\label{sec:basic-elpi}

\subsection{Basic interpreter}
In this first section we start with a first-order version of a logic language.

The interpreter we are going to show is a system made by the derivation rules
depicted in \cref{fig:basic-interp}. It's structure is not far from the
operational semantic in \cite{1990Vink}.

TODO: diverse semantiche a confronto: KING, ANDREWS,
https://arxiv.org/pdf/0911.5203 (forse), VINK -> denotational vs operation quindi
mi porto una funzione vs mi porto uno lista

\begin{figure}
  
  \ruleStopM{.45}
  \ruleFailM{.45}
  \vspace{0.3em}%
  
  \ruleUnifM{.50}
  \ruleBangM{.40}
  \vspace{0.3em}%
  
  \ruleCallM{1}
  
  \caption{Basic derivation rules}
  \label{fig:basic-interp}
\end{figure}

The small-step semantics expressed by \runCmd{g}{a}{s}{a'}{s'} relates a list of
goals $g$, a list of alternatives $a$ and an initial substitution $s$ with a
new substitution $s'$ and a new list of alternatives $a'$. The list of goals
should be understood as a list of goal put in cunjunction, whereas the
alternatives represent a disjunction of goals. In the derivation above we use
the two colon symbol ($::$) has separator between the head of a list and its tail;
$@$ stands for list concatenation; $[\ ]$ is the empty list. $\prog p$ is the
application of \prog to the predicate $p$; it returns a list of clauses. The
function $\mathcal{F}$ is defined as follows:
%
$$
\mathcal{F}(r, i, o, s, a) := [(s, (\Cons{(p, i = i', a)}\Cons{(p, o = o', a)}{[(p, g, a) \mid g \in bs]})) \mid cl\ i'\ o'\ bs \in r]
$$

It takes a list of clauses, two terms, i.e. $i$ and $o$ representing the two
arguments of the predicate call a substitution $s$ and a list of alternatives $a$. For each clause
$(cl\ i'\ o'\ bs)$, it builds a new list of pairs where the first argument
is the substitution $s$ and the second are goals made by 1) the unification of
the first argument $i'$ with the first argument $i$ of the predicate call 2) the
unification between the second arguments $o'$ and $o$ 3) the map of each premise
$g$ in the body $bs$ which return a new list of goals having the program $p$,
the atom $g$ and the list of alternatives $a$.

The behaviour of the program depends on the shape of the list of goal and its
alternatives. Starting from a configuration it is possible to execute the
program. It means that it exists a sequence of reductions allowing to reach the
\textit{stop rule}, symbolyzed with \ruleStop.

More precisely, \textit{stop rule} caputres the
configurations with an empty list of goals. By convention, this configuration is
the final one: there are no more goal to treat; therefore, we can stop and
return the same alternatives and substitution received in input.

The \textit{fail rule} (\ruleFail) is used to consume the list of alternatives,
if for example, the current goal leads to a failure or a loop. In fact, this
rule allows to break loop since it can non-determinalistically applied on any
configuration, provided that the list of alternatives is not empty. It is
possible to make the algorithm deterministic by chainging \ruleFail so that it
is applied if the current goal is a call to a predicate with no alternatives,
but we prefer to simplify our rule system.

The \textit{unify rule} (\ruleUnif) is applied when a unification $t1 = t2$
occurs in the head of the current goal list. It calls the unification algorithm
between the two terms $t1$ and $t2$ under the current substitution $s$ and
returns the updated substitution $s'$. Finally the \run procedure is called the
list of remaining goals $gs$ and the new substitution $s'$.

The \textit{cut rule} (\ruleBang) refers to goals where the first conjunct is is
the \texttt{!} atom. This is where the cut-alternatives $ca$ become interesting.
The rule tells that the list of goal $gl$ can be launched using $ca$ and the
new list of alternatives.

The \textit{call rule} (\ruleCall) deals with goals starting with a predicate
call. In this case the function $\mathcal{F}$ is called with the parameters as
explained above and if the result of this operation is the list
\ConsHd{b}\ConsTl{bs}, then a recursive call to \run is done by prepending $b$ to
the list of remaining goals $gl$ and $bs$ is prepended to the list of
alternatives $a$.

The combination of the \ruleCall and \ruleBang are crucial to reproduce the
behaviour of the hard cut. When a call to a predicate gives several rules as new
choice points, thanks to the function $\mathcal{F}$ we can associate each atom
of each body of $\prog p$ to the current alternatives $a$. If a clause $b_i$ in
\ConsHd{b}\ConsTl{bs} with $0 \leq i \leq | bs |$ has a cut, then all the
choice points $b_j$ with $i < j \leq | bs |$ will be cut away.

As an example, let's consider the following program called \prog:

\begin{elpicode}
p1 X Y :- p2 X Y.           % r1
p1 3 3.                     % r2
p2 X Y :- p3 X Y, !, Y = 1. % r3
p2 1 1.                     % r4
p3 1 2.                     % r5
\end{elpicode}

{
\def\goalG{\goal{\prog}{call\ (\text{\elpiIn{p1 3 Z}})}{\EmptyList}}

Let $\mathcal{G} :=\ \goalG$ be a goal, the execution of
``\runCmd{\mathcal{G}}{\EmptyList}{\EmptySubst}{?A}{?S}'' will apply \ruleCall
producing a new goal for the rule $r1$ and an alternative list containing $r2$,
we leave out details concerning unifications of head terms. The execution of
$r1$ will try to solve $r3$. This will add three goals \elpiIn{r 1 Y, !, Y = 1}
with cut-alternatives equal to $r2$ whereas the new alternatives will be $r4 @
r2$. The execution of $r3$ will solve \elpiIn{p3 1 Y} with substitution $s :=
\{X \gets 1; Y \gets 2\}$. The \elpiIn{!} will cut away the alternative $r4 @
r2$ and will keep the cut-alternative $r2$. The failing premise \elpiIn{Y = 1}
will cause a backtracking thanks to \ruleFail and try to apply $r2$ from the
empty substitution. This last unification succeed with final substution $?A :=
\{X \gets 3; Y \gets 3\}$ and final list of alternatives $?A := \EmptyList$.

% \begin{myRule}{1}
%   \AxiomC{}
%   \RightLabelM{\ruleCall}
%   \UnaryInfC{\runCmd{\mathcal{G}}{\EmptyList}{\EmptySubst}{?A}{?S}}
% \end{myRule}

}


\subsection{Static mode checker}

\subsection{Static functionality checker}




