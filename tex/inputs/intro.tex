\section{Introduction}

We are interested in the static analsysis of Elpi programs, in particular
in checking their determinacy. Elpi is a higher-order logic programming
language, a dialect of $\lambda$Prolog~\cite{1991miller-pf,Miller_Nadathur_2012} well suited to manipulate
incomplete syntax trees with binders~\cite{dunchev15lpar,TASSI_2019}.
Elpi finds applications as an extension
language for The Rocq\footnote{formerly known as Coq} Interactive prover, where
it has been used for program and proof synthesis~\cite{tassi2018,tassi2019,tassi2023,cohen_et_al:LIPIcs.FSCD.2020.34} and more recently
as the target language for type-class resolution~\cite{fissore2023,fissore2024}.
Type-class resolution is typically used to implement overloading~\cite{wadler1996-hs,sozeau2008-tc}
where the solution to a query provides the meaning of the overloaded symbol.
In this context it is of paramount\todo{dipende, no?} importance that this solution is unique,
i.e. non ambiguous. A static check for this property is of particular
interest in the context of the platform of Rocq libraries: code developed
by different teams is combined together in order to lower the cost
of mechanization.

As of today Elpi comes with a quite standard type-checker~\cite{1992nadathur} but
features no determinacy analisys. The literature provides
many works on the subject~\cite{robaDescrittaDopoNeiRelatedWorks} but none of these
works can be applied to Elpi due to its higher-order nature, inherited from
$\lambda$Prolog, and its nonstandard notion of input.

\subsection{Motivating examples}\label{sec:examples}

A first motivating example is the \elpiIn{map} predicate, widely used in
all Elpi applications. Elpi
follows the $\lambda$Prolog convention of
writing application with no parentheses: \elpiIn{map F L R}
should be understood as the atom \elpiIn{map(F, L, R)}.

\begin{elpicode}
pred map i:(pred i:A, o:B), i:list A, o:list B. % basic signature
func map (func A -> B), list A -> list B.       % better signature (this paper)
map _ [] [].                                    % code  
map F [X|XS] [Y|YS] :- F X Y, map F XS YS.      % code
\end{elpicode}

The basic predicate signature says that \elpiIn{map} has two input arguments
and one output. The first argument is a higher order predicate with an inupt
of type \elpiIn{A} and an output of type \elpiIn{B}, while the other two
arguments are respectively of type \elpiIn{list A} and \elpiIn{list B}.
The better signature we describe in this paper subsumes the  basic one by
additionally asserting that
if the higher order argument \elpiIn{F} is a function, then also \elpiIn{map F} is.
In this reasoning ``function'' means single-valued relation,
we will give amore precise, operational, meaning in section~\ref{sec:thm}.

We need this new signature to be added to an existing code base where
\elpiIn{map} is potentially called by passing a relation as the first
argument, say \elpiIn{P}.
In this case the call to \elpiIn{map P L R} has to be accepted but not
considered to be a function for the analisys of the surrounding code.
In the examples below we give three (alternative) one-line
implementations of a \elpiIn{meal} predicate building a list of dishes
to satisfy the guests.

\begin{elpicode}
pred likes i:guest, o:dish.
... % same guest may lake more than one dish ...
func likes! guest -> dish.
likes! G D :- likes D G, !.
func meal list guest -> list dish.
meal Gs M :- map likes! Gs M.     % a function
meal Gs M :- map likes Gs M, !.   % also a function
meal Gs M :- map likes Gs M.      % not really a function
\end{elpicode}

\noindent The first implementation is accepted since \elpiIn{likes!} is a
function, hence also \elpiIn{map likes! Gs M} is.
The second implementation miscalls \elpiIn{map} by passing the relation
\elpiIn{likes}, but then commits to the first solution,
hence it is a function.
The third one is rejected since it miscalls \elpiIn{map} without
compensating for it.

The hard-cut operator of Elpi lets one turn a relation into a function
by committing to its first result, as in the body of \elpiIn{like!}, but it also
discards the clauses following the current one.
Luckily the language of signatures we
introduce is expressive enough to encapsulate the desired ``if-then''
behavior into the \elpiIn{once} predicate. Its signature
states that the higher-order argument \elpiIn{P} can be any predicate, not
necessarily a function, but still \elpiIn{once P} acts as a function.

\begin{elpicode}
func once (pred i:A, o:B), A -> B.
once P X R :- P X R, !.
meal Gs M :- map (once likes) Gs M. % ok since (once likes) is a function
\end{elpicode}

\noindent Not only the inputs, but also the outputs of predicates
can be predicates. The determinacy analysis we present tracks their
functional status.
    
\begin{elpicode}
func commit (pred i:A, o:B) -> (func A -> B).          
commit P (once P).                             
func id (func A -> B) -> (func A -> B).
id F F.
meal Gs M :- commit likes F, map F Gs M. % ok
meal Gs M :- id likes! F, map F Gs M.    % ok
meal Gs M :- id likes F, map F Gs M.     % nope
\end{elpicode}

\noindent Here the output of \elpiIn{commit} is a function \elpiIn{F} that
in turn makes \elpiIn{map F Gs M} produce a single value for \elpiIn{M}.
Moreover \elpiIn{commit} is a function, so the whole body of \elpiIn{meal} also
is. The last example is rejected since \elpiIn{id} is miscalled: the outputs
are considered as functions only if the signature of the inputs is respected.

The real domain where Elpi shines is the manipulation of higher-order data
via the so-called $\lambda$-tree syntax by~\cite{Miller2018MechanizedMR}
also called HOAS by~\cite{1988pfenning}.
Such data is pervasive in interactive provers based on type theory
such as Rocq. In the paradigmatic example below \elpiIn{tm} is
the data type for $\lambda$-terms.

\begin{elpicode}
kind tm type.
type app tm -> tm -> tm.
type lam (tm -> tm) -> tm.
func copy tm -> tm.
copy (app A B) (app C D) :- copy A C, copy B D.
copy (lam F) (lam G) :- pi x\ copy x x => copy (F x) (G x).
func whd tm -> tm.
whd (app H A) R :- whd H (lam F), !, (pi x\ copy x A => copy (F x) S), whd S R.
whd X X.
\end{elpicode}

The copy \elpiIn{predicate} behaves like the identity.
Each time a \elpiIn{lam} node is crossed the second clause creates a fresh
symbol \elpiIn{x} via the \elpiIn{pi} operator:
This \elpiIn{x} stands for the bound variable in the function body
\elpiIn{F x}. Since no (static) clause handles this new symbol \elpiIn{x},
the second rule crafts a (dynamic) clause for copying \elpiIn{x} to itself
and adds it to the program via the \elpiIn{=>} operator (intuitively a
local \texttt{assert}).
The \elpiIn{whd} predicate computes the weak head normal form by
contracting the application of a $\lambda$-abstraction to an argument.
The argument is put in place of the abstracted variable by running
\elpiIn{copy} with the addition of a special clause for the variable
being replaced.
The two predicates are functions even if they dynamically assert caluses:
Since \elpiIn{x} is fresh it does not unify
with \elpiIn{app}, \elpiIn{lam} or any previously generated fresh \elpiIn{x}.
Our static analysis understands this programming pattern.

\paragraph{Contributions and paper structure}

Our contribution is a determinacy checker that:
\begin{itemize}
\item covers higher-order logic programming constructs such as first-class predicates and dynamic clauses
\item can be applied incrementally to pre-existing code bases since it tracks miscalled higher-order functions rather than aborting
\end{itemize}
Last but not least we provide an operational semantics for
the Elpi dialect of $\lambda$Prolog: a higher-order logic programming language
with cut.
