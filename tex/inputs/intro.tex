\section{Introduction}

We are interested in the static analsysis of Elpi programs, in particular
in checking their determinacy. Elpi is a higher oreder logic programming
language, a dialect of $\lambda$Prolog~\cite{dale} well suited to manipulate
incomplete syntax trees with binders~\cite{lpar,journal}.
Elpi finds applications as an extension
language for The Rocq\footnote{formerly known as Coq} Interactive prover, where
Elpi has been used for program and proof synthesis~\cite{derive1,derive2,hb} and more recently
as the target language for type class resolution~\cite{coqws,ppdp}.
Type class resolution is typically used to implement overloading~\cite{haskell,ms}
where the solution to a query provides the meaning of the overloaded symbol.
In this context it is of paramount importance that this solution is unique,
i.e. non ambiguous. A static check for this property is of particular
interest in the context of the platform of Rocq libraries: code developed
by different teams is combined together, reused in order to lower the cost
of mechanization.

As of typday Elpi comes with a quite standard type checker~\cite{pf} but
features no mode nor determinacy analisys. The literature provides
many works on the subject~\cite{robadescrittadopo} but none of these
works can be applied to Elpi due to its higher order nature, inherited from
$\lambda$Prolog, and its nonstandard notion of input.

Our contributions is a  determinacy checking algorithm that
\begin{itemize}
\item covers logic programs with cut
\item covers higher order logic programming constructs such as first class predicates and clauses
\item can be applied to pre-existing code bases, i.e. tracks miscalled functions rather than aborting
\end{itemize}
Last but not least we provide an operational semantics for higher order logic programs
with cut that poses the bases for our definitions and paves the way to a
mechanization of the determinacy checking algorithm.

\subsection{Motivating examples}

A first motivating example is the \elpiIn{map} predicate, widely used in
all Elpi applications. The first line gives the signature of \elpiIn{map}:
given a predicate between any types \elpiIn{A} and \elpiIn{B},
it relates a list of \elpiIn{A} with a list of \elpiIn{B}. Elpi
follows the $\lambda$Prolog convention ($\lambda$-0calculus actually) of
writing application with no parentheses, e.g. \elpiIn{map F L R}
can be understood as the atom \elpiIn{map(F, L, R)}.

\begin{elpicode}
pred map i:(pred i:A, o:B), i:list A, o:list B.
map _ [] [].
map F [X|XS] [Y|YS] :- F X Y, map F XS YS.
\end{elpicode}

This code happens to compute a function of the first two arguments, that we
consider inputs, if and only if the higher order predicate \elpiIn{F} is a
function and if the first list is ground. We want to author of this code
to be able to ascribe a more precise signature on the code above, namely:

\begin{elpicode}
func map (func A -> B), list A -> list B.
\end{elpicode}

The syntax \elpiIn{func name? inputs -> outputs} asserts that name is
a function of the inputs (before the arrow) to the outputs if all the
requirements on the inputs are satisfied, in this specific case if the
first input is a functional, binary, predicate. We need this ascription to
be given on an existing code base where \elpiIn{map} is potentially
called by passing a relation as the first argument, say \elpiIn{P}.
In this case the call to \elpiIn{map P L R} has to be accepted but not
coinsidered to be functional for the analisys of the surrounding code.


\begin{elpicode}
func mask! list A, list A -> list bool.
mask! Bad L R :- map (x\y\ if mem! x Bad then y = ff else y = tt) L R. % ok

func mask list A, list A -> list bool. % error
pred mask i:list A, i:list A, o:list bool. % ok
mask Bad L R :- map (x\y\ if mem X Bad then Y = ff else Y = tt) L R.
\end{elpicode}

The cut oeprator is the privileged way to impose functionality on a relation
by committing to its first result.

\begin{elpicode}
func once (pred) -> .
once P :- P, !.

pred mem i:A, i:list A.
mem X [X|_].
mem X [_|XS] :- mem X XS.

func mem! A, list A -> .
mem! X XS :- once (mem X XS).
\end{elpicode}

The signature of \elpiIn{once} states that the higher order argument
\elpiIn{P} can be a predicate, but still \elpiIn{once P} acts as a function.
The determinacy analysis we present tracks functionality from the inputs
to outputs, that can be themselves predicates.

    
\begin{elpicode}
func force (pred) -> (func).
force P (once P).

func foo (pred), list A -> list B.
foo P L R :- force P F, map L F R.
\end{elpicode}

Here the output of \elpiIn{force} is a function \elpiIn{F} and in turn
makes \elpiIn{map L F R} produce a single value for \elpiIn{R} out
of \elpiIn{P} and \elpiIn{L}, making \elpiIn{foo} itself a function.

The higher order term in Elpi (and $\lambda$Prolog) also applies to data
via the so called $\lambda$-tree syntax (also known as HOAS~\cite{dalemechaniz}).
 
\begin{elpicode}
kind tm type.
type app tm -> tm -> tm.
type lam (tm -> tm) -> tm.

func copy tm -> tm.
copy (app A B) (app C D) :- copy A C, copy B D.
copy (lam F) (lam G) :- pi x\ copy x x => copy (F x) (G x).

func whd tm -> tm.
whd (app H A) R :- whd H (lam F), !, pi x\ copy x A => copy (F x) R.
whd X X.
\end{elpicode}

todo explain, can we have the ad hoc rule for pi x?



% We have a rule based language integrated in Coq. Rules are useful
% to model a grown knowledge base (extend existing programs) and manage
% the context in HOAS.

% We want to add to it some of the benefits of functional programming,
% eg statically enforce the absence of global backtracking. Eg twice the same
% rule can turn linear into exponential. Even worse two overlapping rules can
% inadvertently change the meaning when loading two libraries.

% checking or inferring functionality of relations is studied in the literature,
% but does only partially cover HO programming but no HOAS nor homoiconicity, all features
% that are widely used. The former, as in FP, to reuse code via HO iterators,
% eg map. The second for manipulating syntax with binders. The third to
% have programs that extend themselves by synthesizing rules.

% in practice a function is a relation where 1) we identify the arguments
% that are seen as input 2) we prove that the outputs are uniquely determined
% by the inputs. The first part is called mode analysis. We study both
% in the HO setting, eg $\lambda$Prolog, in the dialect of Elpi that has
% a special runtime input mode.

% \section{Motivating examples explained}

% We give a short intro to Elpi and functional analysis with examples
% that cover the use cases we want to cover.

% Convention that capitals are parameters, programs are written in rules
% preceeeded by a signature. prop is the type of predicate, eg code that runs.
% List syntax is bla bla. :- separates the head from the body, the head
% is unified with the goal, then each premise is executed.

% \subsection{Higher order programming}

% A typical HO predicate is map that takes a relation  in A x B
% to a relation in list A x list B.

% \begin{elpicode}
% type map (A -> B -> prop) -> list A -> list B -> prop.
% map _ [] [].
% map F [X|XS] [Y|YS] :- F X Y, map F XS YS.
% \end{elpicode}

% Explain that unlike functional languages, command and expressions are not
% mixed, and prop stuff is executable, hence you don't put F X in place of Y
% but rather run F X Y.

% Also explain that a relation that can go both sides, but
% that this feature is not very useful, for example it does not always
% work and if one calls passing a wrong relation, it is easy to diverge. 

% find a simple example.

% \begin{elpicode}
% filter P [] []
% filter P [X|XS] [X|YS] :- P X, !, filter P XS YS.
% filter P [_|XS] YS :- filter P XS YS.
% \end{elpicode}
  
% We want to annotate with usage info.

% \begin{elpicode}
% pred map i:(pred i:A, o:B), i:list A, o:list B.
% \end{elpicode}

% Explain syntax (pred [name] X, ... = X -> .. -> prop).

% This first step seems to be stringent for little reason, since map can work
% both ways. But it necessary to further refine the annotation with functionality
% assertions.

% \begin{elpicode}
% func map (func A -> B), list A -> list B.
% \end{elpicode}

% Explain syntax (func [name] X, ... -> Y, .. = pred i:X, .. , o:Y, ..).

% Note (map succ) is func list int -> list int (assuming succ is a function).

% \subsection{Higher Order Abstract Syntax programming}

% In HOAS, we want out analysis to accept this code that adds a dynamic rule

% \begin{elpicode}
% kind tm type.
% type app tm -> tm -> tm.
% type lam (tm -> tm) -> tm.

% func copy tm -> tm.
% copy (app F A) (app G B) :- copy F G, copy A B.
% copy (lam F) (lam G) :- pi x\ copy x x => copy (F x) (G x).

% func whd tm -> tm.
% whd (app H A) R :- whd H (lam F), whd (F A) R.
% whd (lam _ as X) X.

% kind ty type.
% type arr ty -> ty -> ty.

% func of tm -> ty.
% of (app F A) T :- of F (arr S T), of A S.
% of (lam F) (arr S T) :- pi x\ of x S => of (F x) T.
% \end{elpicode}

% \subsection{Homoiconicity}

% Since the language is homoiconic we also want this to pass

% \begin{elpicode}
% func comp (func A -> B), (func B -> C) -> (func A -> C).
% comp F G X Y :- F X Tmp, G Tmp Y.

% func fuse (func A -> B) -> (func A -> B).
% fuse (comp (map F) (map G)) (map H) :- fuse (comp F G) H.
% fuse X X.
% \end{elpicode}

% But we don't want to break code that uses map as a relation

% \begin{elpicode}
% func do list (func) -> .
% do [].
% do [P|PS] :- P, do PS.

% pred do-with-trace i:list (pred).
% do-with-trace Code :- map spy Code InstrumentedCode, do Code.
  
% func spy (pred) -> (pred).
% spy P (do [print "before", P, print "after"]).
% \end{elpicode}

% Finally, we want to take advantage of cut across iterators

% \begin{elpicode}
% func once (pred) -> .
% once P :- P, !.

% func do! list (pred) -> .
% do! [] [].
% do! [P|PS] :- once P, do! PS.

% % alternative

% func tcut (pred) -> (func).
% tcut R F :- F = once R.

% func do! list (pred) ->.
% do! LR :- map tcut LR LF, do LF.
% \end{elpicode}