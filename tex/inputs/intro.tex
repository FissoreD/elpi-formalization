\section{Introduction}

% We are interested in the static analsysis of Elpi programs, in particular
% in checking their determinacy. Elpi is a higher-order logic programming
% language, a dialect of $\lambda$Prolog well suited to manipulate
% incomplete syntax trees with binders (see
% \cite{1991miller-pf,Miller_Nadathur_2012} and \cite{dunchev15lpar,TASSI_2019}).
% Elpi finds applications as an extension
% language for the Rocq Prover (formerly known as the Coq proof assistant)
% where it has been used for program and proof synthesis by~\cite{tassi2018,tassi2019,tassi2023,cohen_et_al:LIPIcs.FSCD.2020.34} and more recently
% as the target language for type-class resolution by~\cite{fissore2023,fissore2024}.

% In Rocq type-class resolution is used for multiple purposes: From automatic
% proof search as in~\cite{sozeau2008-tc} to Haskell-style symbol overloading as in~\cite{wadler1996-hs}.
% For this last application
% the solution to a query provides the formal meaning of the overloaded symbol
% and it is of paramount importance that this solution is unique.
% A static check for this property is of particular
% interest in the context of the platform of Rocq libraries where code developed
% by different teams is combined together.

% As of today, Elpi comes equipped with a standard type checker~\cite{1992nadathur} but
% features no determinacy analisys. The literature provides
% many works on the subject~(among them \cite{1989Warren,1996Somogy,2011king}), but none
% can be applied to Elpi due to its higher-order nature.



We are interested in the static analysis of Elpi programs, particularly in
verifying their determinacy. Elpi is a higher-order logic programming language,
a dialect of \(\lambda\)Prolog, well suited for manipulating incomplete syntax
trees with binders (see \cite{1991miller-pf, Miller_Nadathur_2012} and
\cite{dunchev15lpar, TASSI_2019}).

Elpi has been used as a meta language for the Rocq Prover (formerly known
as the Coq proof assistant) for program and proof synthesis
by \cite{tassi2018, tassi2019, tassi2023, cohen_et_al:LIPIcs.FSCD.2020.34}. More
recently, it has also been employed as the target language for type-class
resolution by \cite{fissore2023, fissore2024}.

In Rocq, type-class resolution serves multiple purposes, ranging from automatic
proof search (\cite{sozeau2008-tc}) to Haskell-style symbol overloading
(\cite{wadler1996-hs}). In the latter case, the solution to a query determines
the formal meaning of an overloaded symbol, making it crucial that this
solution is unique. Ensuring this uniqueness through a static check is
particularly relevant in the context of the Rocq library platform, where code
developed by different teams is integrated.

Currently, Elpi includes a standard type checker (see \cite{1992nadathur}) but lacks
a determinacy analysis. While the literature offers numerous studies on this
topic (e.g., \cite{1989Warren, 1996Somogy, 2011king}), none are directly
applicable to Elpi due to its higher-order nature.


\subsection{Examples of higher-order predicates and their signatures}\label{sec:examples}

A first motivating example is the \elpiIn{map} predicate, widely used in
all Elpi applications. Elpi
follows the $\lambda$Prolog convention of
writing application with no parentheses: \elpiIn{map F L R}
should be understood as the atom \elpiIn{map(F, L, R)}.

\begin{elpicodeln}[1]
pred map i:(pred i:A, o:B), i:list A, o:list B. % basic signature
func map   (func   A -> B),   list A -> list B. % better signature (this paper)
map _ [] [].                                    % code  
map F [X|XS] [Y|YS] :- F X Y, map F XS YS.      % code
\end{elpicodeln}

The basic predicate signature says that \elpiIn{map} has two input arguments
and one output. The first argument is a predicate with an inupt
of type \elpiIn{A} and an output of type \elpiIn{B}, while the other two
arguments are respectively of type \elpiIn{list A} and \elpiIn{list B}.
The better signature we describe in this paper subsumes the  basic one by
%additionally 
asserting that
if the higher-order argument \elpiIn{F} is a function, then also \elpiIn{map F} is.
In this section ``function'' intuitively means single-valued relation; 
we will give a more precise definition in Section~\ref{sec:thm}.

We need this new signature to be added to an existing code base where
\elpiIn{map} is potentially called by passing a relation as the first
argument, say \elpiIn{P}.
In this case the call to \elpiIn{map P L R} has to be accepted but not
considered to be a function for the analisys of the surrounding code.
In the examples below we give three (alternative) one-line
implementations of a \elpiIn{meal} predicate building a list of dishes
to satisfy the guests.

\begin{elpicodeln}[5]
pred likes i:guest, o:dish.
... % the same guest may like more than one dish ...
func likes! guest -> dish.
likes! G D :- likes D G, !.
func meal list guest -> list dish.
meal Gs M :- map likes! Gs M.     % accepted: map is well called
meal Gs M :- map likes Gs M, !.   % accepted: alternatives are cut
meal Gs M :- map likes Gs M.      % rejected: meal is not a function
\end{elpicodeln}

\noindent The first implementation given at line 10 is accepted since \elpiIn{likes!} is a
function, hence also \elpiIn{map likes! Gs M} is.
The second implementation miscalls \elpiIn{map} by passing the relation
\elpiIn{likes}, but then commits to the first solution,
hence it behaves like as function.
The third one, at line 12, is rejected since it miscalls \elpiIn{map} without
compensating for it.

The hard-cut operator of Elpi lets one turn a relation into a function
by committing to its first result, as in the body of \elpiIn{likes!}, but it also
discards the clauses following the current one.
The language of signatures we
introduce is expressive enough to encapsulate the desired ``if-then''
behavior into the \elpiIn{once} predicate. Its signature
states that the higher-order argument \elpiIn{P} can be any predicate, not
necessarily a function, but still \elpiIn{once P} acts as a function.

\begin{elpicode}
func once (pred i:A, o:B), A -> B.
once P X R :- P X R, !.
meal Gs M :- map (once likes) Gs M. % accepted: map is well called
\end{elpicode}

\noindent Not only the inputs, but also the outputs of predicates
can be predicates. The determinacy analysis we present tracks their
functional status.
    
\begin{elpicodeln}[13]
func commit (pred i:A, o:B) -> (func A -> B).          
commit P (once P).                       % wraps a predicate P into once
func id (func A -> B) -> (func A -> B).
id F F.
meal Gs M :- commit likes F, map F Gs M. % accepted: F is a function
meal Gs M :- id likes! F, map F Gs M.    % accepted: F is a function
meal Gs M :- id likes F, map F Gs M.     % rejected: id miscalled => F relation
\end{elpicodeln}

\noindent In line 17 the output of \elpiIn{commit} is a function \elpiIn{F} that
in turn makes \elpiIn{map F Gs M} produce a single value for \elpiIn{M}.
Moreover \elpiIn{commit} is a function, so the whole body of \elpiIn{meal} also
is. The example at line 19 is rejected since \elpiIn{id} is miscalled: the outputs
are considered functions only if the signature of the inputs is respected.

The domain where Elpi really shines is the manipulation of higher-order data
via the so-called $\lambda$-tree syntax by~\cite{Miller2018MechanizedMR}
also called HOAS by~\cite{1988pfenning}.
Such data is pervasive in interactive provers based on type theory
such as Rocq. In the paradigmatic example below \elpiIn{tm} is
the data type for $\lambda$-terms.

\begin{elpicodeln}[20]
kind tm type.                              % type of $\lambda$-terms in HOAS form
type app tm -> tm -> tm.                   %  - binary application
type lam (tm -> tm) -> tm.                 %  - $\lambda$-abstraction
func copy tm -> tm.                        % deep copy of a term
copy (app A B) (app C D) :- copy A C, copy B D.
copy (lam F) (lam G)     :- pi x\ copy x x => copy (F x) (G x).
func whd tm -> tm.                         % weak head reduction
whd (app H A) R :- whd H (lam F), !, (pi x\ copy x A => copy (F x) S), whd S R.
whd X X.
\end{elpicodeln}

The \elpiIn{copy} predicate performs a \emph{deep} copy of a term. The interesting
code is at line 25 where we cross the binder in \elpiIn{F} by performing two
operations:
1) create a fresh symbol \elpiIn{x} via the \elpiIn{pi} operator, and
2) assert a new clause to copy \elpiIn{x} to itself via the \elpiIn{=>} operator.
This fresh \elpiIn{x} stands for the bound variable in the function body
\elpiIn{F x} and its dedicated clause is only active in that scope (intuitively it
is a local \texttt{assert/1}).

The \elpiIn{whd} predicate computes the weak head normal form by
contracting the application of a $\lambda$-abstraction to an argument.
The argument is put in place of the abstracted variable by running
\elpiIn{copy} with the addition of a special clause for the variable
being replaced.

Both \elpiIn{copy} and \elpiIn{whd} are functions even if they
dynamically assert caluses:
Since \elpiIn{x} is fresh it does not unify
with \elpiIn{app}, \elpiIn{lam} or any previously generated fresh \elpiIn{x}.
Our static analysis understands this programming pattern.

\paragraph{Contributions}

Our main contribution is a determinacy checker that:
\begin{itemize}
\item covers higher-order logic programming constructs such as first-class
      predicates and dynamic clauses,
\item can be applied incrementally to a pre-existing code bases since it tracks
      miscalled higher-order functions rather than aborting.
\end{itemize}
Last, but not least, we provide an operational semantics for
the Elpi dialect of $\lambda$Prolog: a higher-order logic programming language
with cut.
